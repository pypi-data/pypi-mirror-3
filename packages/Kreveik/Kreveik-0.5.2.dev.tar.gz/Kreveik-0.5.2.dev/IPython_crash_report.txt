***************************************************************************

IPython post-mortem report

IPython version: 0.10.2 

Platform info  : os.name -> posix, sys.platform -> linux2

***************************************************************************

Current user configuration structure:

{'__allownew': True, 'args': None, 'opts': None}

***************************************************************************

Crash traceback:

---------------------------------------------------------------------------
error                                         Python 2.7.1: /usr/bin/python
                                                   Sun Oct  2 19:43:20 2011
A problem occured executing Python code.  Here is the sequence of function
calls leading up to the error, with the most recent (innermost) call last.

/usr/bin/ipython in <module>()
     13 
     14 [or simply IPython.Shell.IPShell().mainloop(1) ]
     15 
     16 and IPython will be your working environment when you start python. The final
     17 sys.exit() call will make python exit transparently when IPython finishes, so
     18 you don't have an extra prompt to get out of.
     19 
     20 This is probably useful to developers who manage multiple Python versions and
     21 don't want to have correspondingly multiple IPython versions. Note that in
     22 this mode, there is no way to pass IPython any command-line options, as those
     23 are trapped first by Python itself.
     24 """
     25 
     26 import IPython.Shell
     27 
---> 28 IPython.Shell.start().mainloop()
        global IPython.Shell.start.mainloop = undefined
     29 
     30 
     31 
     32 
     33 
     34 
     35 
     36 
     37 
     38 
     39 
     40 
     41 
     42 
     43 

/usr/lib/python2.7/site-packages/IPython/Shell.pyc in start(user_ns=None)
   1227             th_mode = special_opts.pop()
   1228         except KeyError:
   1229             th_mode = 'tkthread'
   1230         return th_shell[th_mode]
   1231 
   1232 
   1233 # This is the one which should be called by external code.
   1234 def start(user_ns = None):
   1235     """Return a running shell instance, dealing with threading options.
   1236 
   1237     This is a factory function which will instantiate the proper IPython shell
   1238     based on the user's threading choice.  Such a selector is needed because
   1239     different GUI toolkits require different thread handling details."""
   1240 
   1241     shell = _select_shell(sys.argv)
-> 1242     return shell(user_ns = user_ns)
   1243 
   1244 # Some aliases for backwards compatibility
   1245 IPythonShell = IPShell
   1246 IPythonShellEmbed = IPShellEmbed
   1247 #************************ End of file <Shell.py> ***************************
   1248 
   1249 
   1250 
   1251 
   1252 
   1253 
   1254 
   1255 
   1256 
   1257 

/usr/lib/python2.7/site-packages/IPython/Shell.pyc in __init__(self=<IPython.Shell.IPShell instance>, argv=None, user_ns=None, user_global_ns=None, debug=1, shell_class=<class 'IPython.iplib.InteractiveShell'>)
     58 # Default timeout for waiting for multithreaded shells (in seconds)
     59 GUI_TIMEOUT = 10
     60 
     61 #-----------------------------------------------------------------------------
     62 # This class is trivial now, but I want to have it in to publish a clean
     63 # interface. Later when the internals are reorganized, code that uses this
     64 # shouldn't have to change.
     65 
     66 class IPShell:
     67     """Create an IPython instance."""
     68     
     69     def __init__(self,argv=None,user_ns=None,user_global_ns=None,
     70                  debug=1,shell_class=InteractiveShell):
     71         self.IP = make_IPython(argv,user_ns=user_ns,
     72                                user_global_ns=user_global_ns,
---> 73                                debug=debug,shell_class=shell_class)
        global For = undefined
        global more = undefined
        global details = undefined
        global see = undefined
        global the = undefined
        global __call__ = undefined
        global method = undefined
        global below. = undefined
     74 
     75     def mainloop(self,sys_exit=0,banner=None):
     76         self.IP.mainloop(banner)
     77         if sys_exit:
     78             sys.exit()
     79 
     80 #-----------------------------------------------------------------------------
     81 def kill_embedded(self,parameter_s=''):
     82     """%kill_embedded : deactivate for good the current embedded IPython.
     83 
     84     This function (after asking for confirmation) sets an internal flag so that
     85     an embedded IPython will never activate again.  This is useful to
     86     permanently disable a shell that is being called inside a loop: once you've
     87     figured out what you needed from it, you may then kill it and the program
     88     will then continue to run without the interactive shell interfering again.

/usr/lib/python2.7/site-packages/IPython/ipmaker.pyc in make_IPython(argv=['/usr/bin/ipython', '--help'], user_ns=None, user_global_ns=None, debug=1, rc_override=None, shell_class=<class 'IPython.iplib.InteractiveShell'>, embedded=False, **kw={})
    309     except DPyGetOpt.ArgumentError, exc:
    310         print cmd_line_usage
    311         warn('\nError in Arguments: "%s"' % exc)
    312         sys.exit(1)
    313 
    314     # convert the options dict to a struct for much lighter syntax later
    315     opts = Struct(getopt.optionValues)
    316     args = getopt.freeValues
    317 
    318     # this is the struct (which has default values at this point) with which
    319     # we make all decisions:
    320     opts_all.update(opts)
    321 
    322     # Options that force an immediate exit
    323     if opts_all.help:
--> 324         page(cmd_line_usage)
    325         sys.exit()
    326 
    327     if opts_all.Version:
    328         print Release.version
    329         sys.exit()
    330 
    331     if opts_all.magic_docstrings:
    332         IP.magic_magic('-latex')
    333         sys.exit()
    334 
    335     # add personal ipythondir to sys.path so that users can put things in
    336     # there for customization
    337     sys.path.append(os.path.abspath(opts_all.ipythondir))
    338 
    339     # Create user config directory if it doesn't exist. This must be done

/usr/lib/python2.7/site-packages/IPython/genutils.pyc in page(strng="\nIPython -- An enhanced Interactive Python\n=====...n't break your code in bizarre ways by doing so.\n", start=0, screen_lines=0, pager_cmd=None)
   1665     # auto-determine screen size
   1666     if screen_lines <= 0:
   1667         if (TERM=='xterm' or TERM=='xterm-color') and sys.platform != 'sunos5':
   1668             use_curses = USE_CURSES
   1669         else:
   1670             # curses causes problems on many terminals other than xterm.
   1671             use_curses = False
   1672         if use_curses:
   1673             # There is a bug in curses, where *sometimes* it fails to properly
   1674             # initialize, and then after the endwin() call is made, the
   1675             # terminal is left in an unusable state.  Rather than trying to
   1676             # check everytime for this (by requesting and comparing termios
   1677             # flags each time), we just save the initial terminal state and
   1678             # unconditionally reset it every time.  It's cheaper than making
   1679             # the checks.
-> 1680             term_flags = termios.tcgetattr(sys.stdout)
   1681             scr = curses.initscr()
   1682             screen_lines_real,screen_cols = scr.getmaxyx()
   1683             curses.endwin()
   1684             # Restore terminal state in case endwin() didn't.
   1685             termios.tcsetattr(sys.stdout,termios.TCSANOW,term_flags)
   1686             # Now we have what we needed: the screen size in rows/columns
   1687             screen_lines += screen_lines_real
   1688             #print '***Screen size:',screen_lines_real,'lines x',\
   1689             #screen_cols,'columns.' # dbg
   1690         else:
   1691             screen_lines += screen_lines_def
   1692 
   1693     #print 'numlines',numlines,'screenlines',screen_lines  # dbg
   1694     if numlines <= screen_lines :
   1695         #print '*** normal print'  # dbg

error: (22, 'Invalid argument')

***************************************************************************

History of session input:

*** Last line of input (may not be in above history):
