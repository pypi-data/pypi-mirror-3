 * API

make the choice of alphabet controllable at run-time

 * design of the encoding

 1. Research the choice of symbols.  The current ones were chosen by me in an adhoc fashion: omitting `0', `2', `l', and `u' and arranging it so that the most common ending characters would be `y' and `o', followed by `r', `x', `n', `w', `1' and `8', followed by `c', `g', `k', `q', `a', `y', `4', and `6'.  It would be better to find some quantitative research on which characters are most likely to be mistranscribed in handwriting, printouts, OCR, screenshots, voice, etc..  In addition there are other criteria like memorability (? maybe it is worth considering that as a factor), and how long it takes to speak the names of the characters in English.

 2. Solicit public feedback on the design that results from #1.

 3. Publish the design than results from #1 and #2 in RFCs etc.


 * Python

make wrappers so that base32.py imports compiled native implementations of the functions if they are available


 * C

benchmark Duff's versus naive versus naive plus 4 byte memcpy
examine asm output
