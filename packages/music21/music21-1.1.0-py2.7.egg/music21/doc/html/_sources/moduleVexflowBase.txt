.. _moduleVexflow.base:

music21.vexflow.base
====================

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED. Edit the .py file directly

.. module:: music21.vexflow.base

Objects for transcribing music21 objects as VexFlow code

Here's the hierarchy:

A VexflowContext can be used to display multiple VexflowParts.
Each VexflowPart contains multiple VexflowStaves (one for each measure)
Each VexflowStave might contain multiple VexflowVoices




.. function:: fromChord(thisChord, mode='txt')


    Parses a music21 chord into VexFlow code



    >>> from music21 import *
    >>> a = chord.Chord(['C3', 'E-3', 'G3', 'C4'])
    >>> print vexflow.fromChord(a, mode='txt')
    new Vex.Flow.StaveNote({keys: ["Cn/3", "Eb/3", "Gn/3", "Cn/4"], duration: "q"})
    ⁠ 
    >>> print vexflow.fromChord(a, mode='html')
    <!DOCTYPE HTML>
    <html>
    <head>
        <meta name='author' content='Music21' />
        <script src='http://code.jquery.com/jquery-latest.js'></script>
        <script src='http://www.vexflow.com/vexflow.js'/></script>
    </head>
    <body>
        <canvas width="525" height="120" id='music21canvas'></canvas>
        <script>
            $(document).ready(function(){
                var canvas = $('#music21canvas')[0];
                var renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
                var ctx = renderer.getContext();
                var stave = new Vex.Flow.Stave(10,0,500);
                stave.addClef('treble').setContext(ctx).draw();
                var notes = [new Vex.Flow.StaveNote({keys: ["Cn/3", "Eb/3", "Gn/3", "Cn/4"], duration: "q"})];
                var voice = new Vex.Flow.Voice({
                    num_beats: 1.0,
                    beat_value: 4,
                    resolution: Vex.Flow.RESOLUTION
                });
                voice.addTickables(notes);
                var formatter = new Vex.Flow.Formatter()
                formatter.joinVoices([voice])
                formatter.format([voice], 500);
                voice.draw(ctx, stave);
            });
        </script>
    </body>
    </html>



.. function:: fromMeasure(thisMeasure, mode='txt')


    Parses a music21 measure into VexFlow code



    >>> from music21 import *
    >>> b = corpus.parse('bwv1.6.mxl')
    >>> m = b.parts[0].measures(0,1)[2]
    >>> d = vexflow.fromMeasure(m)
    >>> print d
    var music21Voice0 = new Vex.Flow.Voice({num_beats: 4.0, beat_value: 4, resolution: Vex.Flow.RESOLUTION});
    var music21Voice0Notes = [new Vex.Flow.StaveNote({keys: ["Gn/4"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Fn/4"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Fn/3"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["An/3"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Fn/3"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["An/3"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_UP})];
    music21Voice0.addTickables(music21Voice0Notes);
    ⁠ 
    >>> c = vexflow.fromMeasure(m, 'html')



.. function:: fromNote(thisNote, mode='txt')


    Parses a music21 note into VexFlow string code



    >>> from music21 import *
    >>> print vexflow.fromNote(note.Note('C4'), mode='txt')
    new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "q"})

    See VexFlowNote.generateCode() for an example of mode='html'



.. function:: fromObject(thisObject, mode='txt')


    Attempts to translate an arbitrary Music21Object into vexflow

    Able to translate anything in vexflow.supportedMusic21Classes

    TODO: Unit Tests (one for each supportedMusic21Class)



    >>> from music21 import *
    >>> print vexflow.fromObject(note.Note('C4'))
    new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "q"})
    ⁠ 
    >>> print vexflow.fromObject(pitch.Pitch('C4'))
    new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "q"})



    >>> print vexflow.fromObject(note.Rest())
    new Vex.Flow.StaveNote({keys: ["b/4"], duration: "qr"})
    ⁠ 
    >>> print vexflow.fromObject(chord.Chord(['C4', 'E-4', 'G4']))
    new Vex.Flow.StaveNote({keys: ["Cn/4", "Eb/4", "Gn/4"], duration: "q"})



    >>> bwv666 = corpus.parse('bwv66.6')
    >>> soprano = bwv666.parts[0]
    >>> measure1 = soprano.getElementsByClass('Measure')[0]
    >>> trebleVoice = bwv666.partsToVoices()[1][1][0]
    >>> bwv666
    <music21.stream.Score ...>
    >>> soprano
    <music21.stream.Part Soprano>
    >>> measure1
    <music21.stream.Measure 0 offset=0.0>
    >>> trebleVoice
    <music21.stream.Voice 0>




    >>> print vexflow.fromObject(measure1)
    var music21Voice0 = new Vex.Flow.Voice({num_beats: 1.0, beat_value: 4, resolution: Vex.Flow.RESOLUTION});
    var music21Voice0Notes = [new Vex.Flow.StaveNote({keys: ["C#/5"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_DOWN}), new Vex.Flow.StaveNote({keys: ["Bn/4"], duration: "8", stem_direction: Vex.Flow.StaveNote.STEM_DOWN})];
    music21Voice0.addTickables(music21Voice0Notes);
    ⁠ 
    >>> print vexflow.fromObject(trebleVoice)
    var music21Voice0 = new Vex.Flow.Voice({num_beats: 4.0, beat_value: 4, resolution: Vex.Flow.RESOLUTION});
    var music21Voice0Notes = [new Vex.Flow.StaveNote({keys: ["An/4"], duration: "q", stem_direction: Vex.Flow.StaveNote.STEM_UP}), new Vex.Flow.StaveNote({keys: ["Bn/4"], duration: "q", stem_direction: Vex.Flow.StaveNote.STEM_DOWN}), new Vex.Flow.StaveNote({keys: ["C#/5"], duration: "q", stem_direction: Vex.Flow.StaveNote.STEM_DOWN}).addArticulation(0, new Vex.Flow.Articulation("a@a").setPosition(3)), new Vex.Flow.StaveNote({keys: ["En/5"], duration: "q", stem_direction: Vex.Flow.StaveNote.STEM_DOWN})];
    music21Voice0.addTickables(music21Voice0Notes);



    >>> #print vexflow.fromObject(soprano)
    >>> #print vexflow.fromObject(bwv666)
    >>> #print vexflow.fromObject(tinyNotation.TinyNotationStream("E4 r f# g=lastG b-8 a g c4~ c", "3/4"), mode='txt')



.. function:: fromPart(thisPart, mode='txt')


    Parses a music21 part into VexFlow code



    >>> from music21 import *
    >>> a = corpus.parse('bwv66.6').parts[1]
    >>> textOut = vexflow.fromPart(a, mode='txt')



.. function:: fromRest(thisRest, mode='txt')


    Parses a music21 rest into VexFlow code



    >>> from music21 import *
    >>> a = note.Rest()
    >>> print vexflow.fromRest(a, mode='txt')
    new Vex.Flow.StaveNote({keys: ["b/4"], duration: "qr"})
    ⁠ 
    >>> print vexflow.fromRest(a, mode='html')
    <!DOCTYPE HTML>
    <html>
    <head>
        <meta name='author' content='Music21' />
        <script src='http://code.jquery.com/jquery-latest.js'></script>
        <script src='http://www.vexflow.com/vexflow.js'/></script>
    </head>
    <body>
        <canvas width="525" height="120" id='music21canvas'></canvas>
        <script>
            $(document).ready(function(){
                var canvas = $('#music21canvas')[0];
                var renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
                var ctx = renderer.getContext();
                var stave = new Vex.Flow.Stave(10,0,500);
                stave.addClef('treble').setContext(ctx).draw();
                var notes = [new Vex.Flow.StaveNote({keys: ["b/4"], duration: "qr"})];
                var voice = new Vex.Flow.Voice({
                    num_beats: 1.0,
                    beat_value: 4,
                    resolution: Vex.Flow.RESOLUTION
                });
                voice.addTickables(notes);
                var formatter = new Vex.Flow.Formatter()
                formatter.joinVoices([voice])
                formatter.format([voice], 500);
                voice.draw(ctx, stave);
            });
    </script>
    </body>
    </html>



.. function:: fromScore(thisScore, mode='txt')


    Parses a music21 score into VexFlow code



    >>> from music21 import *
    >>> a = corpus.parse('bwv66.6')
    >>> #print vexflow.fromScore(a, mode='txt')




.. function:: fromStream(thisStream, mode='txt')


    Parses a music21 stream into VexFlow code

    Checks if it has parts. If so, parses like a Score.
    Otherwise, just flattens it and parses it like a Part



    >>> from music21 import *
    >>> #print vexflow.fromStream(tinyNotation.TinyNotationStream('c8 d8 e-4 dd4 cc2'), mode='txt')
    >>> #print vexflow.fromStream(tinyNotation.TinyNotationStream('C8 D8 E-4 d4 c2'), mode='txt')



.. function:: staffString(xPosStr='10', yPosStr='0', staffWidth='500', staveName='stave')


    	returns a string formated new VexFlow Stave.

    	Arguments are strings representing the x and y position and the width.

    	They are strings because a Javascript function can be used in lieu of the number.

    	>>> from music21 import *
    	>>> vexflow.staffString()
    	'var stave = new Vex.Flow.Stave(10,0,500);'

    	>>> vexflow.staffString('(0 * (((($(window).width()-10) - (2*10))) / 4) + 10)', '((0 * ((4 * (90 + 20)) + 60)) + 10 + (0*(90+20)))', '(((($(window).width()-10) - (2*10))) / 4)')
    	'var stave = new Vex.Flow.Stave((0 * (((($(window).width()-10) - (2*10))) / 4) + 10),((0 * ((4 * (90 + 20)) + 60)) + 10 + (0*(90+20))),(((($(window).width()-10) - (2*10))) / 4));'



.. function:: vexflowClefFromClef(music21clef)


    Given a music21 clef object, returns the vexflow clef



    >>> from music21 import *
    >>> vexflow.vexflowClefFromClef(clef.TrebleClef())
    'treble'
    ⁠ 
    >>> vexflow.vexflowClefFromClef(clef.BassClef())
    'bass'



    >>> vexflow.vexflowClefFromClef(clef.TenorClef())
    'tenor'
    ⁠ 
    >>> vexflow.vexflowClefFromClef(clef.AltoClef())
    'alto'



    >>> vexflow.vexflowClefFromClef(clef.Treble8vbClef())
    'bass'
    ⁠ 
    >>> vexflow.vexflowClefFromClef(clef.PercussionClef())
    'percussion'



    >>> vexflow.vexflowClefFromClef(clef.GClef())
    'treble'



UIDCounter
----------



.. class:: UIDCounter(UIDStart=0)


    generic counter object for keeping track of the number of objects used.



    >>> from music21 import *
    >>> uidc = vexflow.UIDCounter(UIDStart = 20)
    >>> uidc.UID
    20
    >>> uidc.readAndIncrement()
    20
    >>> uidc.readAndIncrement()
    21
    >>> uidc.UID
    22



    **UIDCounter** **attributes**

        Attributes without Documentation: `UID`

    **UIDCounter** **methods**

        .. method:: readAndIncrement()

            No documentation.



VexflowChord
------------

Inherits from: :class:`~music21.vexflow.base.VexflowObject`

.. class:: VexflowChord(music21Chord=None, clef=None)


    A simultaneous grouping of notes

    TODO: __str__ should just call the str() method on the original notes
    TODO: Also store original notes as Chord object
    TODO: write unit tests




    notes must be an array_like grouping of either Music21 or VexFlow Notes
    notes can instead be a music21.chord.Chord object



    **VexflowChord** **attributes**

        Attributes inherited from :class:`~music21.vexflow.base.VexflowObject`: :attr:`~music21.vexflow.base.VexflowObject.tieStart`, :attr:`~music21.vexflow.base.VexflowObject.indent`, :attr:`~music21.vexflow.base.VexflowObject.tieStop`, :attr:`~music21.vexflow.base.VexflowObject.originalObject`, :attr:`~music21.vexflow.base.VexflowObject.clefContext`, :attr:`~music21.vexflow.base.VexflowObject.clef`, :attr:`~music21.vexflow.base.VexflowObject.beamStart`, :attr:`~music21.vexflow.base.VexflowObject.beamStop`

    **VexflowChord** **methods**

        .. method:: vexflowCode()


            returns a string showing the vexflow code needed to display this chord in a browser




        Methods inherited from :class:`~music21.vexflow.base.VexflowObject`: :meth:`~music21.vexflow.base.VexflowObject.accidentalCode`, :meth:`~music21.vexflow.base.VexflowObject.dotCode`, :meth:`~music21.vexflow.base.VexflowObject.fermataCode`, :meth:`~music21.vexflow.base.VexflowObject.generateCode`, :meth:`~music21.vexflow.base.VexflowObject.getVoiceString`, :meth:`~music21.vexflow.base.VexflowObject.setBeamStatus`, :meth:`~music21.vexflow.base.VexflowObject.setTieStatus`, :meth:`~music21.vexflow.base.VexflowObject.staveDefaultClefAddString`, :meth:`~music21.vexflow.base.VexflowObject.stemDirectionCode`, :meth:`~music21.vexflow.base.VexflowObject.vexflowDuration`, :meth:`~music21.vexflow.base.VexflowObject.vexflowKey`


VexflowContext
--------------



.. class:: VexflowContext(params={'width': '($(window).width()-10)', 'height': '$(window).height()'}, canvasName=None)


    Contains information about the canvas, formatter, and renderer




    `canvasName` is the name of the canvas within the html code.

    `params` is a dictionary containing width, height, and other parameters
    to be passed to the canvas object



    **VexflowContext** **attributes**

        .. attribute:: UIDCounter


            generic counter object for keeping track of the number of objects used.



            >>> from music21 import *
            >>> uidc = vexflow.UIDCounter(UIDStart = 20)
            >>> uidc.UID
            20
            >>> uidc.readAndIncrement()
            20
            >>> uidc.readAndIncrement()
            21
            >>> uidc.UID
            22



        Attributes without Documentation: `contextName`, `contextCode`, `canvasHTML`, `rendererName`, `canvasJSCode`, `params`, `canvasHTMLName`, `canvasJSName`, `rendererCode`, `UID`

    **VexflowContext** **methods**

        .. method:: generateHTML(applyAttributes=False)


            Generates the HTML for the canvas and stores it in self.canvasHTML

            (End users should use the getCanvasHTML() method)

            If applyAttributes is True, then apply the attributes in the
                HTML code instead of in the Javascript

            Note: There is no checking that the values aren't also set
                in Javascript



        .. method:: generateJS(applyAttributes=True)


            Generates the Javascript to set up the canvas for VexFlow and stores it
                in self.canvasJSCode, self.rendererCode, and self.contextCode

            (End users should use the get methods)

            If applyAttributes is True, then apply the attributes in the Javascript
                instead of the HTML.

            Note: applying the attributes in Javascript will overwrite any
                attributes set in the HTML



        .. method:: getCanvasHTML(cache=True, applyAttributes=False)

            No documentation.


        .. method:: getHeight()

            No documentation.


        .. method:: getJSCode(indentation=1, cache=True, applyAttributes=True)

            No documentation.


        .. method:: getWidth()

            No documentation.


        .. method:: setHeight(height)

            No documentation.


        .. method:: setWidth(width)

            No documentation.



VexflowNote
-----------

Inherits from: :class:`~music21.vexflow.base.VexflowObject`

.. class:: VexflowNote(music21note=None, clef=None)


    A VexflowNote object has a .generateCode() method which produces VexFlow
    code to represent a :class:`music21.note.Note` object.

    TODO: Verify that I'm not overwriting any base attribute names of music21

    TODO: add setters/getters

    TODO: __str__



    >>> from music21 import *
    >>> n = note.Note('C-')
    >>> v = vexflow.VexflowNote(n)
    >>> v.vexflowKey()
    'Cb/4'
    >>> v.vexflowDuration()
    'q'
    >>> v.vexflowCode()
    'new Vex.Flow.StaveNote({keys: ["Cb/4"], duration: "q"})'
    ⁠ 
    >>> n = tinyNotation.TinyNotationNote('c##2.').note
    >>> n.stemDirection = 'up'
    >>> v = VexflowNote(n)
    >>> v.vexflowKey()
    'C##/4'
    >>> v.vexflowDuration()
    'hd'
    >>> v.stemDirectionCode()
    'stem_direction: Vex.Flow.StaveNote.STEM_UP'
    >>> v.vexflowCode()
    'new Vex.Flow.StaveNote({keys: ["C##/4"], duration: "hd", stem_direction: Vex.Flow.StaveNote.STEM_UP}).addDotToAll()'




    music21note must be a :class:`music21.note.Note` object.



    **VexflowNote** **attributes**

        Attributes inherited from :class:`~music21.vexflow.base.VexflowObject`: :attr:`~music21.vexflow.base.VexflowObject.tieStart`, :attr:`~music21.vexflow.base.VexflowObject.indent`, :attr:`~music21.vexflow.base.VexflowObject.tieStop`, :attr:`~music21.vexflow.base.VexflowObject.originalObject`, :attr:`~music21.vexflow.base.VexflowObject.clefContext`, :attr:`~music21.vexflow.base.VexflowObject.clef`, :attr:`~music21.vexflow.base.VexflowObject.beamStart`, :attr:`~music21.vexflow.base.VexflowObject.beamStop`

    **VexflowNote** **methods**

        .. method:: vexflowCode()


            returns a string representing the vexflow code for this note



        Methods inherited from :class:`~music21.vexflow.base.VexflowObject`: :meth:`~music21.vexflow.base.VexflowObject.accidentalCode`, :meth:`~music21.vexflow.base.VexflowObject.dotCode`, :meth:`~music21.vexflow.base.VexflowObject.fermataCode`, :meth:`~music21.vexflow.base.VexflowObject.generateCode`, :meth:`~music21.vexflow.base.VexflowObject.getVoiceString`, :meth:`~music21.vexflow.base.VexflowObject.setBeamStatus`, :meth:`~music21.vexflow.base.VexflowObject.setTieStatus`, :meth:`~music21.vexflow.base.VexflowObject.staveDefaultClefAddString`, :meth:`~music21.vexflow.base.VexflowObject.stemDirectionCode`, :meth:`~music21.vexflow.base.VexflowObject.vexflowDuration`, :meth:`~music21.vexflow.base.VexflowObject.vexflowKey`


VexflowObject
-------------



.. class:: VexflowObject(music21Object=None, clef=None)


    A general class for all VexflowObjects to inherit from.  See specific
    objects such as :class:`~music21.vexflow.base.VexflowNote`,
    :class:`~music21.vexflow.base.VexflowChord`, and
    :class:`~music21.vexflow.base.VexflowRest` for more details



    **VexflowObject** **attributes**

        Attributes without Documentation: `tieStart`, `indent`, `tieStop`, `originalObject`, `clefContext`, `clef`, `beamStart`, `beamStop`

    **VexflowObject** **methods**

        .. method:: accidentalCode(pitch=None, index=0)


            returns code to add an accidental to a Vex.Flow.Note or key

            index refers to the pitch within a chord to be altered (0 for notes)



        .. method:: dotCode()


            generates VexFlow code for the number of dots in the object.

            Currently Vexflow's layout engine only supports single dotted notes however!



            >>> from music21 import *
            >>> n = note.Note()
            >>> n.duration.dots = 1
            >>> vn = vexflow.VexflowNote(n)
            >>> vn.dotCode()
            '.addDotToAll()'



        .. method:: fermataCode()


            returns a string of Vexflow code if there is a fermata and '' if not



            >>> from music21 import *
            >>> n = note.Note()
            >>> n.expressions.append(expressions.Fermata())
            >>> vn = vexflow.VexflowNote(n)
            >>> vn.fermataCode()
            '.addArticulation(0, new Vex.Flow.Articulation("a@a").setPosition(3))'



        .. method:: generateCode(mode='txt')


            Returns the VexFlow code for a single note in the desired display mode

            Currently supported modes are `txt` (returns the VexFlow code which can be used in conjunction with
            other VexFlow code) and `html` (returns standalone HTML code for displaying just this note.)



            >>> from music21 import *
            >>> n = note.Note('C-')
            >>> v = vexflow.VexflowNote(n)
            >>> v.generateCode('txt')
            'new Vex.Flow.StaveNote({keys: ["Cb/4"], duration: "q"})'
            ⁠ 
            >>> print v.generateCode('html')
            <!DOCTYPE HTML>
            <html>
            <head>
                <meta name='author' content='Music21' />
                <script src='http://code.jquery.com/jquery-latest.js'></script>
                <script src='http://www.vexflow.com/vexflow.js'/></script>
            </head>
            <body>
                <canvas width="525" height="120" id='music21canvas'></canvas>
                <script>
                    $(document).ready(function(){
                        var canvas = $('#music21canvas')[0];
                        var renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
                        var ctx = renderer.getContext();
                        var stave = new Vex.Flow.Stave(10,0,500);
                        stave.addClef('treble').setContext(ctx).draw();
                        var notes = [new Vex.Flow.StaveNote({keys: ["Cb/4"], duration: "q"})];
                        var voice = new Vex.Flow.Voice({
                            num_beats: 1.0,
                            beat_value: 4,
                            resolution: Vex.Flow.RESOLUTION
                        });
                        voice.addTickables(notes);
                        var formatter = new Vex.Flow.Formatter()
                        formatter.joinVoices([voice])
                        formatter.format([voice], 500);
                        voice.draw(ctx, stave);
                    });
                </script>
            </body>
            </html>



        .. method:: getVoiceString(numBeats, voiceName='voice', currentIndentLevel=3)


            returns a string creating a new Vex.Flow.Voice with the number of beats
            at the current indentation level.



            >>> from music21 import *
            >>> vo = vexflow.VexflowObject()
            >>> print vo.getVoiceString(2.0).rstrip()
                    var voice = new Vex.Flow.Voice({
                        num_beats: 2.0,
                        beat_value: 4,
                        resolution: Vex.Flow.RESOLUTION
                    });
            >>> print vo.getVoiceString(3.0, voiceName='myVoice', currentIndentLevel = 0).rstrip()
            var myVoice = new Vex.Flow.Voice({
                num_beats: 3.0,
                beat_value: 4,
                resolution: Vex.Flow.RESOLUTION
            });



        .. method:: setBeamStatus()


            Set the beamStatus for a note by setting beamStart to True, beamStop to True, or neither



        .. method:: setTieStatus()


            Set the tieStatus for a note by setting tieStart to True, tieStop to True, or neither



        .. method:: staveDefaultClefAddString()

            No documentation.


        .. method:: stemDirectionCode()


            gets the Vexflow StemDirection String



            >>> from music21 import *
            >>> n = note.Note()
            >>> vfn = vexflow.VexflowNote(n)
            >>> vfn.stemDirectionCode()
            ''
            >>> n.stemDirection = 'up'
            >>> vfn.stemDirectionCode()
            'stem_direction: Vex.Flow.StaveNote.STEM_UP'



        .. method:: vexflowDuration()


            Given a music21 Note (or Pitch) object, returns the vexflow duration



            >>> from music21 import *
            >>> n = note.Note()
            >>> vfn = vexflow.VexflowNote(n)
            >>> vfn.vexflowDuration()
            'q'
            >>> n.quarterLength = 0.75
            >>> vfn.vexflowDuration()
            '8d'



        .. method:: vexflowKey(clef=None, usePitch=None)


            Generate a VexFlow Key from self.originalObject.

            Since a VexFlow key is the position on a staff, we need to know the
            current clef in order to give a key.  The key is a position as if
            the clef were treble clef.

            Why the accidental is included is beyond me, since it is rendered
            separately, it might store information actual pitch, but that's
            weird since we're storing a position as if it's treble clef.

            if usePitch is given then we use this pitch instead of self.originalObject,
            which is needed for iterating through chord pitches

            if clef is None then we look at self.clefContext for more information,
            otherwise treble is assumed.  Clef is a Vexflow clef name #TODO: CHANGE THIS!



            >>> from music21 import *
            >>> vfn1 = vexflow.VexflowNote(note.Note('C4'))
            >>> vfn1
            <music21.vexflow.base.VexflowNote object at 0x...>
            >>> vfn1.vexflowKey() #'treble')
            'Cn/4'
            >>> vfn2 = vexflow.VexflowNote(note.Note('C4'))
            >>> vfn2.vexflowKey('bass')
            'An/5'
            ⁠ 
            >>> c = chord.Chord(['C4','G#4','E-5'])
            >>> vfc = vexflow.VexflowChord(c)
            >>> vfc.vexflowKey('treble', c.pitches[0])
            'Cn/4'
            >>> vfc.vexflowKey('treble', c.pitches[1])
            'G#/4'
            >>> vfc.vexflowKey('treble', c.pitches[2])
            'Eb/5'




VexflowPart
-----------



.. class:: VexflowPart(music21part, params={})


    A part is a wrapper for the vexflow code representing multiple measures
    of music that should go in the same musical staff (as opposed to
    a vexflow Stave)



    **VexflowPart** **methods**

        .. method:: beamCode(contextName, indentation=3)


            Generates the code for beaming all of the staves in this part

            Returns as an array containing the preamble and postamble



        .. method:: generateCode(mode='txt')


            generates the vexflow code necessary to display this part in a browser




VexflowRest
-----------

Inherits from: :class:`~music21.vexflow.base.VexflowObject`

.. class:: VexflowRest(music21rest=None, clef=None)


    Class for representing rests in VexFlow




    music21rest must be a :class:`music21.note.Rest` object.

    position is where the rest should appear on the staff
        'b/4' is the middle of the treble clef



    **VexflowRest** **attributes**

        Attributes inherited from :class:`~music21.vexflow.base.VexflowObject`: :attr:`~music21.vexflow.base.VexflowObject.tieStart`, :attr:`~music21.vexflow.base.VexflowObject.indent`, :attr:`~music21.vexflow.base.VexflowObject.tieStop`, :attr:`~music21.vexflow.base.VexflowObject.originalObject`, :attr:`~music21.vexflow.base.VexflowObject.clefContext`, :attr:`~music21.vexflow.base.VexflowObject.clef`, :attr:`~music21.vexflow.base.VexflowObject.beamStart`, :attr:`~music21.vexflow.base.VexflowObject.beamStop`

    **VexflowRest** **methods**

        .. method:: vexflowCode()


            Returns a string which is the generated the vexflow code needed to render this rest object



            >>> from music21 import *
            >>> r = note.Rest()
            >>> vr = vexflow.VexflowRest(r)
            >>> vr.vexflowCode()
            'new Vex.Flow.StaveNote({keys: ["b/4"], duration: "qr"})'



        Methods inherited from :class:`~music21.vexflow.base.VexflowObject`: :meth:`~music21.vexflow.base.VexflowObject.accidentalCode`, :meth:`~music21.vexflow.base.VexflowObject.dotCode`, :meth:`~music21.vexflow.base.VexflowObject.fermataCode`, :meth:`~music21.vexflow.base.VexflowObject.generateCode`, :meth:`~music21.vexflow.base.VexflowObject.getVoiceString`, :meth:`~music21.vexflow.base.VexflowObject.setBeamStatus`, :meth:`~music21.vexflow.base.VexflowObject.setTieStatus`, :meth:`~music21.vexflow.base.VexflowObject.staveDefaultClefAddString`, :meth:`~music21.vexflow.base.VexflowObject.stemDirectionCode`, :meth:`~music21.vexflow.base.VexflowObject.vexflowDuration`, :meth:`~music21.vexflow.base.VexflowObject.vexflowKey`


VexflowScore
------------



.. class:: VexflowScore(music21score, params={})


    Represents the code for multiple VexflowPart objects



    **VexflowScore** **methods**

        .. method:: generateCode(mode='txt')


            returns the vexflow code needed to render this object in a browser



        .. method:: vexflowCode()


            Generates the code necessary to display this score




VexflowStave
------------



.. class:: VexflowStave(params={'width': 500, 'position': (10, 0), 'notesWidth': '(500 - 75)'})


    A "Stave"[sic] in VexFlow is the object for the graphic staff to be displayed.
    It usually represents a Measure that might have one or more Voices on it.

    TODO: generateCode should take a VexflowContext object as a param




    params is a dictionary containing position, width, and other parameters to be passed to the stave object



    **VexflowStave** **attributes**

        .. attribute:: UIDCounter


            generic counter object for keeping track of the number of objects used.



            >>> from music21 import *
            >>> uidc = vexflow.UIDCounter(UIDStart = 20)
            >>> uidc.UID
            20
            >>> uidc.readAndIncrement()
            20
            >>> uidc.readAndIncrement()
            21
            >>> uidc.UID
            22



        Attributes without Documentation: `vexflowVoices`, `params`, `UID`, `staveName`

    **VexflowStave** **methods**

        .. method:: beamCode(contextName, indentation=3)


            Generates the code for beaming all of the voices on this stave

            Returns an array containing the preamble and postamble



        .. method:: formatterCode()


            code for setting up a formatter to join voices



        .. method:: generateCode(mode='txt')


            Generates the vexflow code to display this staff in a browser



        .. method:: getLineNum()


            Tries to get the line number of this stave




        .. method:: getWidth()

            No documentation.


        .. method:: setVoices(theseVexflowVoices)


            Replaces any existing voices attached to this Stave with theseVexflowVoices (a list of instances of VexflowVoice)



        .. method:: staveCode()


            JavaScript/VexFlow code for putting clefs, timeSignatures, etc. on the staff.



        .. method:: vexflowCode()

            No documentation.



VexflowVoice
------------



.. class:: VexflowVoice(music21measure=None, params={'beaming': True, 'name': 'music21Voice0', 'beatValue': 4, 'numBeats': 0.0})


    A Voice in VexFlow is a "lateral" grouping of notes in one measure
        It's the equivalent to a :class:`~music21.stream.Measure`

    Requires either a :class:`~music21.stream.Measure` object or a
    :class:`~music21.stream.Voice` object

    If those objects aren't already flat, flattens them in the process.

    params is a dict containing various parameters to be passed to the
    voice object.  Most important is the UIDCounter parameter which keeps
    track of the number of objects created




    **VexflowVoice** **attributes**

        .. attribute:: originalFlat

            A representation of a Measure organized as a Stream.

            All properties of a Measure that are Music21 objects are found as part of
            the Stream's elements.



        .. attribute:: UIDCounter


            generic counter object for keeping track of the number of objects used.



            >>> from music21 import *
            >>> uidc = vexflow.UIDCounter(UIDStart = 20)
            >>> uidc.UID
            20
            >>> uidc.readAndIncrement()
            20
            >>> uidc.readAndIncrement()
            21
            >>> uidc.UID
            22



        .. attribute:: originalMeasure

            A representation of a Measure organized as a Stream.

            All properties of a Measure that are Music21 objects are found as part of
            the Stream's elements.



        Attributes without Documentation: `voiceName`, `UID`, `beatValue`, `clefDisplayStatus`, `keySignature`, `keySignatureDisplayStatus`, `params`, `timeSignature`, `numBeats`, `clef`

    **VexflowVoice** **methods**

        .. method:: createBeamCode(contextName='ctx', indentation=3)


            returns the code to create beams for this staff.



        .. method:: drawBeamCode(contextName='ctx', indentation=3)


            returns the code to draw beams on this staff.



        .. method:: generateCode(mode='txt')


            returns the vexflow code necessary to display this Voice in a browser
                as a string



        .. method:: getBeaming()


            Beaming is a boolean value determining if the voice should be beamed

            Note: So far only VexFlow's automatic beaming is supported
                Cannot manually modify beams



        .. method:: notesCode()


            note the plural.  Generates an String that is a Javascript array
            of all the vexflow notes in a measure:



            >>> from music21 import *
            >>> s = stream.Measure()
            >>> s.append(note.Note('c4'))
            >>> s.append(note.Note('d4'))
            >>> vfv = vexflow.VexflowVoice(s)
            >>> vfv.voiceName = 'myVoice'
            >>> vfv.notesCode()
            'var myVoiceNotes = [new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "q"}), new Vex.Flow.StaveNote({keys: ["Dn/4"], duration: "q"})];'



        .. method:: setBeaming(beaming)


            Beaming is a boolean value determining if the voice should be beamed

            Note: So far only VexFlow's automatic beaming is supported
                Cannot manually modify beams



        .. method:: tieCode(contextName='ctx', indentation=3)


            Returns the code for the ties for this voice

            Returns it as a two-element tuple containing [0] a list of code
            for the completed ties within this voice,
            and [1] a two-element array for partial ties that go across the bar line
            consisting of (0) a two-element tuple of the start index,
            and end index (None), and (1) the string name of the Note group
            to which element [0][0] belongs.

            N.B. Bug: Only the first index of a chord is tied.



        .. method:: vexflowCode()


            Returns a string that generates the code necessary to display this voice.



            >>> from music21 import *
            >>> s = stream.Measure()
            >>> s.append(note.Note('c4'))
            >>> s.append(note.Note('d4'))
            >>> vfv = vexflow.VexflowVoice(s)
            >>> vfv.voiceName = 'myVoice'
            >>> print vfv.vexflowCode()
            var myVoice = new Vex.Flow.Voice({num_beats: 2.0, beat_value: 4, resolution: Vex.Flow.RESOLUTION});
            var myVoiceNotes = [new Vex.Flow.StaveNote({keys: ["Cn/4"], duration: "q"}), new Vex.Flow.StaveNote({keys: ["Dn/4"], duration: "q"})];
            myVoice.addTickables(myVoiceNotes);



        .. method:: vexflowObjects()


            returns a list of all the notesAndRests in the originalMeasure
            represented as VexflowObjects



            >>> from music21 import *
            >>> s = stream.Measure()
            >>> s.append(note.Note('c4'))
            >>> s.append(note.Note('d4'))
            >>> vfv = vexflow.VexflowVoice(s)
            >>> vfv.vexflowObjects()
            [<music21.vexflow.base.VexflowNote object at 0x...>, <music21.vexflow.base.VexflowNote object at 0x...>]



        .. method:: voiceCode()


            Creates the code to create a new voice object with the
            name stored in `self.voiceName`.



            >>> from music21 import *
            >>> s = stream.Measure()
            >>> s.append(note.Note('c4'))
            >>> s.append(note.Note('d4'))
            >>> vfv = vexflow.VexflowVoice(s)
            >>> vfv.voiceName = 'myVoice'
            >>> vfv.voiceCode()
            'var myVoice = new Vex.Flow.Voice({num_beats: 2.0, beat_value: 4, resolution: Vex.Flow.RESOLUTION});'




