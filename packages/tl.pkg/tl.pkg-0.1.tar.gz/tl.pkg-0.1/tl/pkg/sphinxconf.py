# coding: utf-8
# Copyright (c) 2012 Thomas Lotze
# See also LICENSE.txt

import datetime
import inspect
import os
import os.path
import pkg_resources
import pkginfo
import sphinx.application
import sphinxcontrib.issuetracker
import sys


class Mock(object):
    """Mock module to stand in for an unavailable module such a one
       implemented in C when building the docs at http://readthedocs.org/.

    """

    def __init__(self, *args, **kwargs):
        pass

    def __call__(self, *args, **kwargs):
        return Mock()

    @classmethod
    def __getattr__(self, name):
        if name in ('__file__', '__path__'):
            return '/dev/null'
        elif name[0] == name[0].upper():
            return type(name, (), {})
        else:
            return Mock()


def register_mock_modules(*mod_names):
    for mod_name in mod_names:
        sys.modules[mod_name] = Mock()


def link_text_files_from_source(project):
    """Link any txt documents from the Python source tree into the Sphinx
       source tree so we need not maintain those links manually.

    """
    namespace, package = project.split('.')
    for name in os.listdir(os.path.join('..', namespace, package)):
        if not name.endswith('txt'):
            continue
        os.symlink(os.path.join('..', namespace, package, name),
                   '%s-%s' % (project, name))


def autodoc_skip_member(app, what, name, obj, skip, options):
    """Event handler that filters methods to be documented by autodoc when
       that is used from dumb stub pages generated by autosummary.

    """
    if obj.__doc__ and obj.__doc__.strip().endswith('.. sphinx-autodoc-skip'):
        return True
    return skip


def register_autodoc_skip_member():
    # XXX hack hack; seen to work with Sphinx 1.1.2
    for frame in inspect.stack():
        app = frame[0].f_locals.get('self')
        if not isinstance(app, sphinx.application.Sphinx):
            continue
        app._events['autodoc-skip-member'] = 'dummy'
        app.connect('autodoc-skip-member', autodoc_skip_member)
        del app._events['autodoc-skip-member']
        break


def offline_bitbucket_issue(app, tracker_config, issue_id):
    return sphinxcontrib.issuetracker.Issue(
        id=issue_id,
        title=None,
        closed=None,
        url=sphinxcontrib.issuetracker.BITBUCKET_URL.format(
            tracker_config, issue_id))


def compute_copyright(confpy, dist):
    year = datetime.date.today().year
    _year_started = confpy.get('_year_started', year)
    if str(year) != str(_year_started):
        year = u'%s-%s' % (_year_started, year)
    return u'%s %s' % (year, dist.author)


def compute_version(dist):
    version = []
    for x in dist.version:
        try:
            version.append(str(int(x)))
        except ValueError:
            break
    return '.'.join(version)


def set_defaults():
    _confpy = sys._getframe(1).f_locals
    _dist = pkginfo.Develop('..')
    _bitbucket_name = _confpy.get('_bitbucket_name', 'BITBUCKET-NAME')

    needs_sphinx = '1.0'

    project = _confpy.get('project', _dist.name)
    source_suffix = _confpy.get('source_suffix', '.txt')
    master_doc = 'index'

    extensions = [
        'sphinx.ext.autosummary',
        'sphinx.ext.viewcode',
        'sphinx.ext.inheritance_diagram',
        'sphinxcontrib.cheeseshop',
        'sphinxcontrib.issuetracker',
        ]

    autosummary_generate = ['api' + source_suffix]
    inheritance_graph_attrs = dict(rankdir='TD')
    issuetracker = 'bitbucket'
    issuetracker_project = '%s/%s' % (_bitbucket_name, project)

    templates_path = [
        pkg_resources.resource_filename('tl.pkg', 'themes/tl-pkg/templates')]
    html_theme_path = [pkg_resources.resource_filename('tl.pkg', 'themes')]
    html_theme = 'tl-pkg'
    html_sidebars = {
        '**': ['project-links.html', 'globaltoc.html', 'searchbox.html'],
    }
    html_domain_indices = False
    html_show_sourcelink = False

    htmlhelp_basename = project + '-doc'

    latex_documents = [
      ('index', _dist.name + '.tex', _dist.name + ur' Documentation',
       _dist.author, 'manual'),
    ]

    html_context = dict(
        bitbucket_name=_bitbucket_name,
        )

    _flattr_url = _confpy.get('_flattr_url')
    if _flattr_url:
        html_context.update(flattr_url=_flattr_url)

    copyright = compute_copyright(_confpy, _dist)
    version = compute_version(_dist)
    release = _dist.version

    for key, value in locals().items():
        if key not in _confpy:
            _confpy[key] = value

    link_text_files_from_source(project)
    register_autodoc_skip_member()
    if _confpy.get('_issuetracker_offline'):
        sphinxcontrib.issuetracker.BUILTIN_ISSUE_TRACKERS['bitbucket'] = \
            offline_bitbucket_issue
