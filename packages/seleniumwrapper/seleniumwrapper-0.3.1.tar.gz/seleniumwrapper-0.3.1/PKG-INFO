Metadata-Version: 1.1
Name: seleniumwrapper
Version: 0.3.1
Summary: selenium webdriver wrapper to make manipulation easier.
Home-page: https://github.com/keitaoouchi/seleniumwrapper
Author: Keita Oouchi
Author-email: keita.oouchi@gmail.com
License: BSD License
Description: About this module
        -----------------
        selenium webdriver wrapper to make manipulation easier.
        
        Features
        --------
        
        * Support remote webdriver.
        * Easy to type aliases. (find_element_by_xpath => xpath, etc.)
        * Wrapped WebdriverWait( ... ).until( ... ) pattern.
        * Polling at the time of clicking or selecting.
        * Wrapping chaining.
        
        How to install
        --------------
        Requires python2.6 or later (exclude python3.x).
        You need *pip* or *distribute* or *setuptools*::
        
            $ pip install seleniumwrapper
        
        or use easy_install::
        
            $ easy_install seleniumwrapper
        
        also you need selenium::
        
            $ pip install selenium
        
        Example to use
        --------------
        
        **create** function helps you to init webdriver and wrap it easily::
        
            >>> import seleniumwrapper as selwrap
            >>> br = selwrap.create("chrome")
        
        **connect** function helps you to use remote webdriver and wrap it::
        
            >>> br = connect("android", "http:\//localhost:9999", {"acceptSslCerts": True})
        
        SeleniumWrapper delegate to its wrapped webdriver::
        
            >>> br.get("http://www.example.com")
            <seleniumwrapper.wrapper.SeleniumWrapper object at 0x...>
            >>> br.xpath("//div[@class='main'])
            <seleniumwrapper.wrapper.SeleniumWrapper object at 0x...>
        
        Setting **eager=True** to invoke find_elements::
        
            >>> br.xpath("//a", eager=True)
            <seleniumwrapper.wrapper.SeleniumContainerWrapper object at 0x...>
        
        SeleniumContainerWrapper also delegate to its wrapped container::
        
            >>> links = [i.get_attribute("href") for i in br.xpath("//a", eager=True)]
        
        Each contents in SeleniumContainerWrapper also SeleniumWrapper::
        
            >>> tds = [tr.xpath("//td", eager=True) for tr in br.xpath("//tr", eager=True)]
        
        Basic API
        ---------
        * seleniumwrapper.create(drivername)
            Create webdriver instance and wrap it with SeleniumWrapper.
        
        SeleniumWrapper
        ^^^^^^^^^^^^^^^
        * unwrap
            Retrieves WebDriver or WebElement from wrapped object::
        
                >>> isinstance(br.unwrap, WebElement)
                True
        
        * parent
            find_element_by_xpath("./parent::node()")::
        
                >>> price = br.by_tag("th", "Price").parent.by_tag("td").text
        
        * alert
            Returns Alert(switch_to_alert()) object::
        
                >>> br.alert.accept()
        
        * click(timeout=3, presleep=0, postsleep=0)
            Continue to polling until timeout or element is displayed and clickable::
        
                >>> br.button("Send").click()
        
        * waitfor(type, target, eager=False, timeout=3)
            See source::
        
                >>> br.waitfor("xpath", "//input[@type='submit']")
        
        * xpath(target, eager=False, timeout=3)
            find_element_by_xpath(target, timeout)::
        
                >>> buttons = br.xpath("//input[@type='submit' or @type='button']", eager=True)
        
        * css(target, eager=False, timeout=3)
            find_element_by_css_selector(target, timeout)::
        
                >>> [li.text for li in br.css("ul li")]
        
        * by_tag(self, tag, eager=False, timeout=3, \*\*attributes)
            Returns specified tagged element with specified attributes optionally.::
        
                >>> br.by_tag("link", rel="stylesheet")
        
        * by_text(text, tag='*', partial=False, eager=False, timeout=3)
            similar to find_element_by_link_text or find_element_by_partial_link_text, but this method can be applicable to any tag::
        
                >>> br.by_text("Go back to Top Page", "a")
        
        * by_class(target, eager=False, timeout=3)
            find_element_by_class_name(target, timeout)::
        
                >>> br.by_class("colored")
        
        * by_id(target, eager=False, timeout=3)
            find_element_by_id(target, timeout)::
        
                >>> br.by_id("main_contents")
        
        * by_name(target, eager=False, timeout=3)
            find_element_by_name(target, timeout)::
        
                >>> br.by_name("page_password")
        
        * by_linktxt(target, eager=False, timeout=3, partial=False)
            find_element_by_link_text(target, timeout). if partial=True, then find_element_by_partial_link_text::
        
                >>> br.by_linktxt("Go back to", partial=True)
        
        * href(partialurl=None, eager=False, timeout=3):
            find_element_by_xpath("//a", timeout). if partialurl was given, search 'a' tag which href contains partialurl::
        
                >>> phplinks = br.href(".php", eager=True)
        
        * img(alt=None, ext=None, eager=False, timeout=3)
            find_elements_by_xpath("//img", timeout)::
        
                >>> br.img(alt="I am sorry", ext="sorry.gif")
        
        * button(value, eager=False, timeout=3)
            find_element_by_xpath("//input[@type='submit' or @type='button' and @value='{}']".format(value), timeout)::
        
                >>> br.button("Send this form").click()
        
        * checkbox(self, eager=False, timeout=3, \*\*attributes)
            Returns 'input' element type='checkbox'::
        
                >>> br.checkbox(name='checked_value', id='hoge')
        
        * radio(self, eager=False, timeout=3, \*\*attributes)
            Retuns 'input' element type='radio'.::
        
                >>> br.radio(name='hoge', id='fuga').click()
        
        * select(self, eager=False, timeout=3, \*\*attributes)
            Returns Select(self.by_tag("select", eager, timeout, \*\*attributes) or their wrapped SeleniumContainerWrapper::
        
                >>> br.select(name="hoge").select_by_index(1)
                >>> [select.is_multiple for select in br.select(eager=True, name="hoge")]
        
        SeleniumContainerWrapper
        ^^^^^^^^^^^^^^^^^^^^^^^^
        
        * sample(size)
            Returns random.sample(self._iterable, size)::
        
                >>> br.img(eager=True).sample(10)
        
        * choice()
            Returns random.choice(self._iterable)::
        
                >>> br.img(eager=True).choice()
        
        Recent Change
        -------------
        * 0.3.1
            * Add **connect** functon.
        * 0.3.0
            * Change **tag** method to **by_tag**.
            * Add **checkbox**, **radio**.
            * Change **select** property to method.
            * Add **sample**, **choice** methods to SeleniumContainerWrapper.
            * Fix **click** bug.
        * 0.2.4
            * Fix bug.
        * 0.2.3
            * Add ext argument to **img** (alt and ext are both optional.)
        * 0.2.2
            * Add new property **alert**
            * Change **img**'s argument from ext to alt( find_element_by_xpath("//img[@alt='{}'.format(alt)) )
            * Modify SeleniumContainerWrapper's __contains__ behavior to unwrap given object if it is a SeleniumWrapper.
        
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Topic :: Software Development :: Libraries :: Python Modules
