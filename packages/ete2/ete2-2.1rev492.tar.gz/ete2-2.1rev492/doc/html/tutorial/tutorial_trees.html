

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Working With Tree Data Structures &mdash; A Python Environment for (phylogenetic) Tree Exploration</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="A Python Environment for (phylogenetic) Tree Exploration" href="../index.html" />
    <link rel="up" title="The ETE tutorial" href="index.html" />
    <link rel="next" title="The Programmable Tree Drawing Engine" href="tutorial_drawing.html" />
    <link rel="prev" title="The ETE tutorial" href="index.html" />
 

<!-- <div class="warning" align="center"> -->
<!--   This site is still under construction and refers to -->
<!--   the new <b>ETE 2.1</b> version (temporary module -->
<!--   name: <b>ete2a1</b>). Many sections may be incomplete or contain -->
<!--   errors. -->
<!-- </div> -->


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-783841-4']);
  _gaq.push(['_setCookiePath', '/ete2/']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>






  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial_drawing.html" title="The Programmable Tree Drawing Engine"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="The ETE tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">ETE documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The ETE tutorial</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-ete2"></span><div class="section" id="working-with-tree-data-structures">
<h1><a class="toc-backref" href="#id1">Working With Tree Data Structures</a><a class="headerlink" href="#working-with-tree-data-structures" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#working-with-tree-data-structures" id="id1">Working With Tree Data Structures</a><ul>
<li><a class="reference internal" href="#trees" id="id2">Trees</a></li>
<li><a class="reference internal" href="#reading-and-writing-newick-trees" id="id3">Reading and Writing Newick Trees</a><ul>
<li><a class="reference internal" href="#reading-newick-trees" id="id4">Reading newick trees</a></li>
<li><a class="reference internal" href="#writing-newick-trees" id="id5">Writing newick trees</a></li>
</ul>
</li>
<li><a class="reference internal" href="#understanding-ete-trees" id="id6">Understanding ETE Trees</a></li>
<li><a class="reference internal" href="#basic-tree-attributes" id="id7">Basic tree attributes</a><ul>
<li><a class="reference internal" href="#root-node-on-unrooted-trees" id="id8">Root node on unrooted trees?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#browsing-trees" id="id9">Browsing trees</a><ul>
<li><a class="reference internal" href="#getting-leaves-descendants-and-node-s-relatives" id="id10">Getting Leaves, Descendants and Node&#8217;s Relatives</a></li>
<li><a class="reference internal" href="#traversing-browsing-trees" id="id11">Traversing (browsing) trees</a></li>
<li><a class="reference internal" href="#iterating-instead-of-getting" id="id12">Iterating instead of Getting</a></li>
<li><a class="reference internal" href="#finding-nodes-by-their-attributes" id="id13">Finding nodes by their attributes</a><ul>
<li><a class="reference internal" href="#search-all-nodes-matching-a-given-criteria" id="id14">Search_all nodes matching a given criteria</a></li>
<li><a class="reference internal" href="#search-nodes-matching-a-given-criteria-iteration" id="id15">Search nodes matching a given criteria (iteration)</a></li>
<li><a class="reference internal" href="#find-the-first-common-ancestor" id="id16">Find the first common ancestor</a></li>
<li><a class="reference internal" href="#custom-searching-functions" id="id17">Custom searching functions</a></li>
<li><a class="reference internal" href="#shortcuts" id="id18">Shortcuts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#node-annotation" id="id19">Node annotation</a></li>
<li><a class="reference internal" href="#modifying-tree-topology" id="id20">Modifying Tree Topology</a><ul>
<li><a class="reference internal" href="#creating-trees-from-scratch" id="id21">Creating Trees from Scratch</a></li>
<li><a class="reference internal" href="#deleting-eliminating-and-removing-detaching-nodes" id="id22">Deleting (eliminating) and Removing (detaching) nodes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pruning-trees" id="id23">Pruning trees</a></li>
<li><a class="reference internal" href="#concatenating-trees" id="id24">Concatenating trees</a></li>
<li><a class="reference internal" href="#tree-rooting" id="id25">Tree Rooting</a></li>
<li><a class="reference internal" href="#working-with-branch-distances" id="id26">Working with branch distances</a><ul>
<li><a class="reference internal" href="#getting-distances-between-nodes" id="id27">Getting distances between nodes</a></li>
<li><a class="reference internal" href="#getting-midpoint-outgroup" id="id28">getting midpoint outgroup</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="trees">
<h2><a class="toc-backref" href="#id2">Trees</a><a class="headerlink" href="#trees" title="Permalink to this headline">¶</a></h2>
<p>Trees are a widely-used type of data structure that emulates a tree
design with a set of linked nodes.  Formally, a tree is considered an
acyclic and connected graph. Each node in a tree has zero or more
child nodes, which are below it in the tree (by convention, trees grow
down, not up as they do in nature). A node that has a child is called
the child&#8217;s parent node (or ancestor node, or superior). A node has at
most one parent.</p>
<p>The height of a node is the length of the longest downward path to a
leaf from that node. The height of the root is the height of the
tree. The depth of a node is the length of the path to its root (i.e.,
its root path).</p>
<ul class="simple">
<li>The topmost node in a tree is called the root node. Being the
topmost node, the root node will not have parents. It is the node at
which operations on the tree commonly begin (although some
algorithms begin with the leaf nodes and work up ending at the
root). All other nodes can be reached from it by following edges or
links. Every node in a tree can be seen as the root node of the
subtree rooted at that node.</li>
<li>Nodes at the bottommost level of the tree are called leaf
nodes. Since they are at the bottommost level, they do not have any
children.</li>
<li>An internal node or inner node is any node of a tree that has child nodes and
is thus not a leaf node.</li>
<li>A subtree is a portion of a tree data structure that can be viewed
as a complete tree in itself. Any node in a tree T, together with
all the nodes below it, comprise a subtree of T. The subtree
corresponding to the root node is the entire tree; the subtree
corresponding to any other node is called a proper subtree (in
analogy to the term proper subset).</li>
</ul>
<p>In bioinformatics, trees are the result of many analyses, such as
phylogenetics or clustering. Although each case entails specific
considerations, many properties remains constant among them. In this
respect, ETE is a python toolkit that assists in the automated
manipulation, analysis and visualization of any type of hierarchical
trees. It provides general methods to handle and visualize tree
topologies, as well as specific modules to deal with phylogenetic and
clustering trees.</p>
</div>
<div class="section" id="reading-and-writing-newick-trees">
<span id="sec-newick-formats"></span><h2><a class="toc-backref" href="#id3">Reading and Writing Newick Trees</a><a class="headerlink" href="#reading-and-writing-newick-trees" title="Permalink to this headline">¶</a></h2>
<p>The Newick format is one of the most widely used standard
representation of trees in bioinformatics. It uses nested parentheses
to represent hierarchical data structures as text strings. The
original newick standard is able to encode information about the tree
topology, branch distances and node names. Nevertheless, it is not
uncommon to find slightly different formats using the newick standard.</p>
<p>ETE can read and write many of them:</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="33%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FORMAT</th>
<th class="head">DESCRIPTION</th>
<th class="head">SAMPLE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>flexible with support values</td>
<td>((D:0.723274,F:0.567784)1.000000:0.067192,(B:0.279326,H:0.756049)1.000000:0.807788);</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>flexible with internal node names</td>
<td>((D:0.723274,F:0.567784)E:0.067192,(B:0.279326,H:0.756049)B:0.807788);</td>
</tr>
<tr class="row-even"><td>2</td>
<td>all branches + leaf names + internal supports</td>
<td>((D:0.723274,F:0.567784)1.000000:0.067192,(B:0.279326,H:0.756049)1.000000:0.807788);</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>all branches + all names</td>
<td>((D:0.723274,F:0.567784)E:0.067192,(B:0.279326,H:0.756049)B:0.807788);</td>
</tr>
<tr class="row-even"><td>4</td>
<td>leaf branches + leaf names</td>
<td>((D:0.723274,F:0.567784),(B:0.279326,H:0.756049));</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>internal and leaf branches + leaf names</td>
<td>((D:0.723274,F:0.567784):0.067192,(B:0.279326,H:0.756049):0.807788);</td>
</tr>
<tr class="row-even"><td>6</td>
<td>internal branches + leaf names</td>
<td>((D,F):0.067192,(B,H):0.807788);</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>leaf branches + all names</td>
<td>((D:0.723274,F:0.567784)E,(B:0.279326,H:0.756049)B);</td>
</tr>
<tr class="row-even"><td>8</td>
<td>all names</td>
<td>((D,F)E,(B,H)B);</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>leaf names</td>
<td>((D,F),(B,H));</td>
</tr>
<tr class="row-even"><td>100</td>
<td>topology only</td>
<td>((,),(,));</td>
</tr>
</tbody>
</table>
<p>Formats labeled as <em>flexible</em> allow for missing information. For
instance, format 0 will be able to load a newick tree even if it does
not contain branch support information (it will be initialized with
the default value). However, format 2 would raise an exception.  In
other words, if you want to control that your newick files strictly
follow a given pattern you should use <strong>strict</strong> format definitions.</p>
<div class="section" id="reading-newick-trees">
<h3><a class="toc-backref" href="#id4">Reading newick trees</a><a class="headerlink" href="#reading-newick-trees" title="Permalink to this headline">¶</a></h3>
<p>In order to load a tree from a newick text string you can use the
constructor <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode" title="ete2.TreeNode"><tt class="xref py py-class docutils literal"><span class="pre">TreeNode</span></tt></a> or its <a class="reference internal" href="../reference/reference_tree.html#ete2.Tree" title="ete2.Tree"><tt class="xref py py-class docutils literal"><span class="pre">Tree</span></tt></a> alias, provided by the main module
<a class="reference internal" href="#module-ete2" title="ete2: provides main objects and modules"><tt class="xref py py-mod docutils literal"><span class="pre">ete2</span></tt></a>. You will only need to pass a text string containing
the newick structure and the format that should be used to parse it (0
by default). Alternatively, you can pass the path to a text file
containing the newick string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree structure from a newick string. The returned variable ’t’ is the root node for the tree.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1):0.5):0.5);&quot;</span> <span class="p">)</span>

<span class="c"># Load a tree structure from a newick file.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;genes_tree.nh&quot;</span><span class="p">)</span>

<span class="c"># You can also specify the newick format. For instance, for named internal nodes we will use format 1.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1)Internal_1:0.5)Internal_2:0.5)Root;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-newick-trees">
<h3><a class="toc-backref" href="#id5">Writing newick trees</a><a class="headerlink" href="#writing-newick-trees" title="Permalink to this headline">¶</a></h3>
<p>Any ETE tree instance can be exported using newick notation using the
<tt class="xref py py-func docutils literal"><span class="pre">Tree.write()</span></tt> method, which is available in any tree node
instance. It also allows for format selection
(<a class="reference internal" href="#sec-newick-formats"><em>Reading and Writing Newick Trees</em></a>), so you can use the same function to
convert between newick formats.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree with internal node names</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1)Internal_1:0.5)Internal_2:0.5)Root;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># And prints its newick using the default format</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">()</span> <span class="c"># (A:1.000000,(B:1.000000,(E:1.000000,D:1.000000)1.000000:0.500000)1.000000:0.500000);</span>

<span class="c"># To print the internal node names you need to change the format:</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># (A:1.000000,(B:1.000000,(E:1.000000,D:1.000000)Internal_1:0.500000)Internal_2:0.500000);</span>

<span class="c"># We can also write into a file</span>
<span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s">&quot;new_tree.nw&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="understanding-ete-trees">
<h2><a class="toc-backref" href="#id6">Understanding ETE Trees</a><a class="headerlink" href="#understanding-ete-trees" title="Permalink to this headline">¶</a></h2>
<p>Any tree topology can be represented as a succession of <strong>nodes</strong>
connected in a hierarchical way. Thus, for practical reasons, ETE
makes no distinction between tree and node concepts, as any tree can
be represented by its root node. This allows to use any internal node
within a tree as another sub-tree instance.</p>
<p>Once trees are loaded, they can be manipulated as normal python
objects. Given that a tree is actually a collection of nodes connected
in a hierarchical way, what you usually see as a tree will be the root
node instance from which the tree structure is hanging. However, every
node within a ETE&#8217;s tree structure can be also considered a
subtree. This means, for example, that all the operational methods
that we will review in the following sections are available at any
possible level within a tree. Moreover, this feature will allow you to
separate large trees into smaller partitions, or concatenate several
trees into a single structure. For this reason, you will find that the
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode" title="ete2.TreeNode"><tt class="xref py py-class docutils literal"><span class="pre">TreeNode</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.Tree" title="ete2.Tree"><tt class="xref py py-class docutils literal"><span class="pre">Tree</span></tt></a> classes are synonymous.</p>
</div>
<div class="section" id="basic-tree-attributes">
<h2><a class="toc-backref" href="#id7">Basic tree attributes</a><a class="headerlink" href="#basic-tree-attributes" title="Permalink to this headline">¶</a></h2>
<p>Each tree node has two basic attributes used to establish its position
in the tree: <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.up" title="ete2.TreeNode.up"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.up</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.children" title="ete2.TreeNode.children"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.children</span></tt></a>.  The first is
a pointer to parent&#8217;s node, while the later is a list of children
nodes.  Although it is possible to modify the structure of a tree by
changing these attributes, it is strongly recommend not to do
it. Several methods are provided to manipulate each node&#8217;s connections
in a safe way (see <a class="reference internal" href="#sec-modifying-tree-topology"><em>Modifying Tree Topology</em></a>).</p>
<p>In addition, three other basic attributes are always present in any
tree node instance:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="69%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
<th class="head">Default value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.dist" title="ete2.TreeNode.dist"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></tt></a></td>
<td>stores the distance from the node to its parent (branch length). Default value = 1.0</td>
<td>1.0</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.support" title="ete2.TreeNode.support"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.support</span></tt></a></td>
<td>informs about the reliability of the partition defined by the node (i.e. bootstrap support)</td>
<td>1.0</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.name</span></tt></td>
<td>Custom node&#8217;s name.</td>
<td>NoName</td>
</tr>
</tbody>
</table>
<p>In addition, several methods are provided to perform basic operations
on tree node instances:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.is_leaf" title="ete2.TreeNode.is_leaf"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.is_leaf()</span></tt></a></td>
<td>returns True if <em>node</em> has no children</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.is_root" title="ete2.TreeNode.is_root"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.is_root()</span></tt></a></td>
<td>returns True if <em>node</em> has no parent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_tree_root" title="ete2.TreeNode.get_tree_root"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_tree_root()</span></tt></a></td>
<td>returns the top-most node within the same tree structure as <em>node</em></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-attr docutils literal"><span class="pre">len(TreeNode)</span></tt></td>
<td>returns the number of leaves under <em>node</em></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">print</span> <span class="pre">node</span></tt></td>
<td>prints a text-based representation of the tree topology under <em>node</em></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-attr docutils literal"><span class="pre">if</span> <span class="pre">node</span> <span class="pre">in</span> <span class="pre">tree</span></tt></td>
<td>returns true if <em>node</em> is a leaf under <em>tree</em></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">for</span> <span class="pre">leaf</span> <span class="pre">in</span> <span class="pre">node</span></tt></td>
<td>iterates over all leaves under <em>node</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.show" title="ete2.TreeNode.show"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.show()</span></tt></a></td>
<td>Explore node graphically using a GUI.</td>
</tr>
</tbody>
</table>
<p>This is an example on how to access such attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="c"># We create a random tree topology</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">up</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">dist</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="c"># You can also iterate over tree leaves using a simple syntax</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
  <span class="k">print</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<div class="section" id="root-node-on-unrooted-trees">
<h3><a class="toc-backref" href="#id8">Root node on unrooted trees?</a><a class="headerlink" href="#root-node-on-unrooted-trees" title="Permalink to this headline">¶</a></h3>
<p>When a tree is loaded from external sources, a pointer to the top-most
node is returned. This is called the tree root, and <strong>it will exist
even if the tree is conceptually considered as unrooted</strong>. This is,
the root node can be considered as the master node, since it
represents the whole tree structure. Unrooted trees can be identified
as trees in which master root node has more than two children.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">unrooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;(A,B,(C,D));&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">unrooted_tree</span>
<span class="c">#</span>
<span class="c">#     /-A</span>
<span class="c">#    |</span>
<span class="c">#----|--B</span>
<span class="c">#    |</span>
<span class="c">#    |     /-C</span>
<span class="c">#     \---|</span>
<span class="c">#          \-D</span>

<span class="n">rooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;((A,B).(C,D));&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">rooted_tree</span>
<span class="c">#</span>
<span class="c">#          /-A</span>
<span class="c">#     /---|</span>
<span class="c">#    |     \-B</span>
<span class="c">#----|</span>
<span class="c">#    |     /-C</span>
<span class="c">#     \---|</span>
<span class="c">#          \-D</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="browsing-trees">
<h2><a class="toc-backref" href="#id9">Browsing trees</a><a class="headerlink" href="#browsing-trees" title="Permalink to this headline">¶</a></h2>
<p>One of the most basic operations for tree analysis is <em>tree
browsing</em>. This is, essentially, visiting nodes within a tree. ETE
provides a number of methods to search for specific nodes or to
navigate over the hierarchical structure of a tree.</p>
<div class="section" id="getting-leaves-descendants-and-node-s-relatives">
<h3><a class="toc-backref" href="#id10">Getting Leaves, Descendants and Node&#8217;s Relatives</a><a class="headerlink" href="#getting-leaves-descendants-and-node-s-relatives" title="Permalink to this headline">¶</a></h3>
<p>TreeNode instances contain several functions to access their
descendants. Available methods are self explanatory:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_descendants" title="ete2.TreeNode.get_descendants"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.get_descendants</span></tt></a>([strategy,&nbsp;is_leaf_fn])</td>
<td>Returns a list of all (leaves and internal) descendant nodes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_leaves" title="ete2.TreeNode.get_leaves"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.get_leaves</span></tt></a>([is_leaf_fn])</td>
<td>Returns the list of terminal nodes (leaves) under this node.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_leaf_names" title="ete2.TreeNode.get_leaf_names"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.get_leaf_names</span></tt></a>([is_leaf_fn])</td>
<td>Returns the list of terminal node names under the current node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_children" title="ete2.TreeNode.get_children"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.get_children</span></tt></a>()</td>
<td>Returns an independent list of node&#8217;s children.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_sisters" title="ete2.TreeNode.get_sisters"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.get_sisters</span></tt></a>()</td>
<td>Returns an indepent list of sister nodes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="traversing-browsing-trees">
<h3><a class="toc-backref" href="#id11">Traversing (browsing) trees</a><a class="headerlink" href="#traversing-browsing-trees" title="Permalink to this headline">¶</a></h3>
<p>Often, when processing trees, all nodes need to be visited. This is
called tree traversing. There are different ways to traverse a tree
structure depending on the order in which children nodes are
visited. ETE implements the three most common strategies:
<strong>preorder</strong>, <strong>levelorder</strong> and <strong>postorder</strong>. The following scheme
shows the differences in the strategy for visiting nodes (note that in
both cases the whole tree is browsed):</p>
<ul class="simple">
<li>preorder: 1)Visit the root, 2) Traverse the left subtree , 3) Traverse the right subtree.</li>
<li>postorder: 1) Traverse the left subtree , 2) Traverse the right subtree, 3) Visit the root</li>
<li>levelorder (default): every node on a level before is visited going to a lower level</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Preorder traversal sequence: F, B, A, D, C, E, G, I, H (root, left, right)</li>
<li>Inorder traversal sequence: A, B, C, D, E, F, G, H, I (left, root, right); note how this produces a sorted sequence</li>
<li>Postorder traversal sequence: A, C, E, D, B, H, I, G, F (left, right, root)</li>
<li>Level-order traversal sequence: F, B, G, A, D, I, C, E, H</li>
</ul>
</div>
<p>Every node in a tree includes a <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.traverse" title="ete2.TreeNode.traverse"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.traverse()</span></tt></a> method, which can be
used to visit, one by one, every node node under the current
partition. In addition, the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_descendants" title="ete2.TreeNode.iter_descendants"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></tt></a> method can be set
to use either a post- or a preorder strategy.  The only different
between <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.traverse" title="ete2.TreeNode.traverse"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.traverse()</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_descendants" title="ete2.TreeNode.iter_descendants"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></tt></a> is that the
first will include the root node in the iteration.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.traverse" title="ete2.TreeNode.traverse"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.traverse</span></tt></a>([strategy,&nbsp;is_leaf_fn])</td>
<td>Returns an iterator to traverse the tree structure under this node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_descendants" title="ete2.TreeNode.iter_descendants"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.iter_descendants</span></tt></a>([strategy,&nbsp;is_leaf_fn])</td>
<td>Returns an iterator over all descendant nodes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_leaves" title="ete2.TreeNode.iter_leaves"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.iter_leaves</span></tt></a>([is_leaf_fn])</td>
<td>Returns an iterator over the leaves under this node.</td>
</tr>
</tbody>
</table>
<p><strong>strategy</strong> can take one of the following values: <tt class="docutils literal"><span class="pre">&quot;postorder&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;preorder&quot;</span></tt> or  <tt class="docutils literal"><span class="pre">&quot;levelorder&quot;</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># we load a tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s">&quot;postorder&quot;</span><span class="p">):</span>
  <span class="c"># Do some analysis on node</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

<span class="c"># If we want to iterate over a tree excluding the root node, we can</span>
<span class="c"># use the iter_descendant method</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">(</span><span class="s">&quot;postorder&quot;</span><span class="p">):</span>
  <span class="c"># Do some analysis on node</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>Additionally, you can implement your own traversing function using the
structural attributes of nodes. In the following example, only nodes
between a given leaf and the tree root are visited.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;(A:1,(B:1,(C:1,D:1):0.5):0.5);&quot;</span> <span class="p">)</span>

<span class="c"># Browse the tree from a specific leaf to the root</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">while</span> <span class="n">node</span><span class="p">:</span>
   <span class="k">print</span> <span class="n">node</span>
   <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
</pre></div>
</div>
</div>
<div class="section" id="iterating-instead-of-getting">
<h3><a class="toc-backref" href="#id12">Iterating instead of Getting</a><a class="headerlink" href="#iterating-instead-of-getting" title="Permalink to this headline">¶</a></h3>
<p>As commented previously, methods starting with <strong>get_</strong> are all
prepared to return results as a closed list of items. This means, for
instance, that if you want to process all tree leaves and you ask for
them using the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_leaves" title="ete2.TreeNode.get_leaves"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_leaves()</span></tt></a> method, the whole tree
structure will be browsed before returning the final list of terminal
nodes.  This is not a problem in most of the cases, but in large
trees, you can speed up the browsing process by using iterators.</p>
<p>Most <strong>get_</strong> methods have their homologous iterator functions. Thus,
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_leaves" title="ete2.TreeNode.get_leaves"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_leaves()</span></tt></a> could be substituted by <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_leaves" title="ete2.TreeNode.iter_leaves"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_leaves()</span></tt></a>. The same
occurs with <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_descendants" title="ete2.TreeNode.iter_descendants"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_search_nodes" title="ete2.TreeNode.iter_search_nodes"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_search_nodes()</span></tt></a>.</p>
<p>When iterators are used (note that is only applicable for looping),
only one step is processed at a time. For instance,
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.iter_search_nodes" title="ete2.TreeNode.iter_search_nodes"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_search_nodes()</span></tt></a> will return one match in each iteration. In
practice, this makes no differences in the final result, but it may
increase the performance of loop functions (i.e. in case of finding a
match which interrupts the loop).</p>
</div>
<div class="section" id="finding-nodes-by-their-attributes">
<h3><a class="toc-backref" href="#id13">Finding nodes by their attributes</a><a class="headerlink" href="#finding-nodes-by-their-attributes" title="Permalink to this headline">¶</a></h3>
<p>Both terminal and internal nodes can be located by searching along the
tree structure. Several methods are available:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>t.search_nodes(attr=value)</td>
<td>Returns a list of nodes in which attr is equal to value, i.e. name=A</td>
</tr>
<tr class="row-odd"><td>t.iter_search_nodes(attr=value)</td>
<td>Iterates over all matching nodes matching attr=value. Faster when you only need to get the first occurrence</td>
</tr>
<tr class="row-even"><td>t.get_leaves_by_name(name)</td>
<td>Returns a list of leaf nodes matching a given name. Only leaves are browsed.</td>
</tr>
<tr class="row-odd"><td>t.get_common_ancestor([node1, node2, node3])</td>
<td>Return the first internal node grouping node1, node2 and node3</td>
</tr>
<tr class="row-even"><td>t&amp;&#8221;A&#8221;</td>
<td>Shortcut for t.search_nodes(name=&#8221;A&#8221;)[0]</td>
</tr>
</tbody>
</table>
<div class="section" id="search-all-nodes-matching-a-given-criteria">
<h4><a class="toc-backref" href="#id14">Search_all nodes matching a given criteria</a><a class="headerlink" href="#search-all-nodes-matching-a-given-criteria" title="Permalink to this headline">¶</a></h4>
<p>A custom list of nodes matching a given name can be easily obtain
through the <tt class="xref py py-func docutils literal"><span class="pre">TreeNode.search_node()</span></tt> function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&#39;((H:1,I:1):0.5, A:1, (B:1,(C:1,D:1):0.5):0.5);&#39;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                    /-H</span>
<span class="c">#          /--------|</span>
<span class="c">#         |          \-I</span>
<span class="c">#         |</span>
<span class="c">#---------|--A</span>
<span class="c">#         |</span>
<span class="c">#         |          /-B</span>
<span class="c">#          \--------|</span>
<span class="c">#                   |          /-C</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>

<span class="c"># I get D</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c"># I get all nodes with distance=0.5</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="s">&quot;nodes have distance=0.5&quot;</span>

<span class="c"># We can limit the search to leaves and node names (faster method).</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_leaves_by_name</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">D</span>
</pre></div>
</div>
</div>
<div class="section" id="search-nodes-matching-a-given-criteria-iteration">
<h4><a class="toc-backref" href="#id15">Search nodes matching a given criteria (iteration)</a><a class="headerlink" href="#search-nodes-matching-a-given-criteria-iteration" title="Permalink to this headline">¶</a></h4>
<p>A limitation of the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.search_nodes" title="ete2.TreeNode.search_nodes"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.search_nodes()</span></tt></a> method is that you cannot use
complex conditional statements to find specific nodes.  When search
criteria is too complex, you may need to create your own search
function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="k">def</span> <span class="nf">search_by_size</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="s">&quot;Finds nodes with a given number of leaves&quot;</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
          <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="c"># returns nodes containing 6 leaves</span>
<span class="n">search_by_size</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="find-the-first-common-ancestor">
<h4><a class="toc-backref" href="#id16">Find the first common ancestor</a><a class="headerlink" href="#find-the-first-common-ancestor" title="Permalink to this headline">¶</a></h4>
<p>Searching for the first common ancestor of a given set of nodes it is
a handy way of finding internal nodes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:0.5,(J:1.3, (F:1.2, D:0.1):0.5):0.5):0.5):0.5);&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-searching-functions">
<h4><a class="toc-backref" href="#id17">Custom searching functions</a><a class="headerlink" href="#custom-searching-functions" title="Permalink to this headline">¶</a></h4>
<p>A limitation of the previous methods is that you cannot use complex
conditional statements to find specific nodes. However you can user
traversing methods to meet your custom filters. A possible general
strategy would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:1,D:1):0.5):0.5);&quot;</span><span class="p">)</span>
<span class="c"># Create a small function to filter your nodes</span>
<span class="k">def</span> <span class="nf">conditional_function</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c"># Use previous function to find matches. Note that we use the traverse</span>
<span class="c"># method in the filter function. This will iterate over all nodes to</span>
<span class="c"># assess if they meet our custom conditions and will return a list of</span>
<span class="c"># matches.</span>
<span class="n">matches</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">conditional_function</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">())</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span> <span class="s">&quot;nodes have ditance &gt;0.3&quot;</span>

<span class="c"># depending on the complexity of your conditions you can do the same</span>
<span class="c"># in just one line with the help of lambda functions:</span>
<span class="n">matches</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">0.3</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="p">)</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span> <span class="s">&quot;nodes have ditance &gt;0.3 and are leaves&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="shortcuts">
<h4><a class="toc-backref" href="#id18">Shortcuts</a><a class="headerlink" href="#shortcuts" title="Permalink to this headline">¶</a></h4>
<p>Finally, ETE implements a built-in method to find the first node
matching a given name, which is one of the most common tasks needed
for tree analysis. This can be done through the operator &amp;
(AND). Thus, TreeNode&amp;”A” will always return the first node whose name
is “A” and that is under the tree “MyTree”. The syntaxis may seem
confusing, but it can be very useful in some situations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:1,(J:1, (F:1, D:1):0.5):0.5):0.5):0.5);&quot;</span><span class="p">)</span>
<span class="c"># Get the node D in a very simple way</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;D&quot;</span>
<span class="c"># Get the path from B to the root</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">D</span>
<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
  <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
  <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c"># I substract D node from the total number of visited nodes</span>
<span class="k">print</span> <span class="s">&quot;There are&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;nodes between D and the root&quot;</span>
<span class="c"># Using parentheses you can use by-operand search syntax as a node</span>
<span class="c"># instance itself</span>
<span class="n">Dsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="n">Bsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;B&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="n">Jsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;J&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="c"># I check if nodes belong to certain partitions</span>
<span class="k">print</span> <span class="s">&quot;It is&quot;</span><span class="p">,</span> <span class="n">Dsparent</span> <span class="ow">in</span> <span class="n">Bsparent</span><span class="p">,</span> <span class="s">&quot;that C&#39;s parent is under B&#39;s ancestor&quot;</span>
<span class="k">print</span> <span class="s">&quot;It is&quot;</span><span class="p">,</span> <span class="n">Dsparent</span> <span class="ow">in</span> <span class="n">Jsparent</span><span class="p">,</span> <span class="s">&quot;that C&#39;s parent is under J&#39;s ancestor&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="node-annotation">
<h2><a class="toc-backref" href="#id19">Node annotation</a><a class="headerlink" href="#node-annotation" title="Permalink to this headline">¶</a></h2>
<p>Every node contains three basic attributes: name
(<tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.name</span></tt>), branch length (<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.dist" title="ete2.TreeNode.dist"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></tt></a>) and
branch support (<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.support" title="ete2.TreeNode.support"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.support</span></tt></a>). These three values are
encoded in the newick format.  However, any extra data could be linked
to trees. This is called tree annotation.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_feature" title="ete2.TreeNode.add_feature"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.add_feature()</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_features" title="ete2.TreeNode.add_features"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.add_features()</span></tt></a>
methods allow to add extra attributes (features) to any node.  The
first allows to add one one feature at a time, while the second can be
used to add many features with the same call.</p>
<p>Once extra features are added, you can access their values at any time
during the analysis of a tree. To do so, you only need to access to
the <tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.feature_name</span></tt> attributes.</p>
<p>Similarly, <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.del_feature" title="ete2.TreeNode.del_feature"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.del_feature()</span></tt></a> can be used to delete an
attribute.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Creates a tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&#39;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:0.5,(J:1.3, (F:1.2, D:0.1):0.5):0.5):0.5):0.5);&#39;</span> <span class="p">)</span>

<span class="c"># Let&#39;s locate some nodes using the get common ancestor method</span>
<span class="n">ancestor</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># the search_nodes method (I take only the first match )</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># and using the shorcut to finding nodes by name</span>
<span class="n">C</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span>
<span class="n">H</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;H&quot;</span>
<span class="n">I</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;I&quot;</span>

<span class="c"># Let&#39;s now add some custom features to our nodes. add_features can be</span>
<span class="c"># used to add many features at the same time.</span>
<span class="n">C</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">nodetype</span><span class="o">=</span><span class="s">&quot;internal&quot;</span><span class="p">)</span>

<span class="c"># Or, using the oneliner notation</span>
<span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;H&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c"># But we can automatize this. (note that i will overwrite the previous</span>
<span class="c"># values)</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
   <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s">&quot;AEIOU&quot;</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="c"># Now we use these information to analyze the tree.</span>
<span class="k">print</span> <span class="s">&quot;This tree has&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> <span class="s">&quot;vowel nodes&quot;</span>
<span class="k">print</span> <span class="s">&quot;Which are&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">vowel</span><span class="o">==</span><span class="bp">True</span><span class="p">]</span>

<span class="c"># But features may refer to any kind of data, not only simple</span>
<span class="c"># values. For example, we can calculate some values and store them</span>
<span class="c"># within nodes.</span>
<span class="c">#</span>
<span class="c"># Let&#39;s detect leaf nodes under &quot;ancestor&quot; with distance higher thatn</span>
<span class="c"># 1. Note that I&#39;m traversing a subtree which starts from &quot;ancestor&quot;</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="p">]</span>

<span class="c"># And save this pre-computed information into the ancestor node</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">&quot;long_branch_nodes&quot;</span><span class="p">,</span> <span class="n">matches</span><span class="p">)</span>

<span class="c"># Prints the precomputed nodes</span>
<span class="k">print</span> <span class="s">&quot;These are nodes under ancestor with long branches&quot;</span><span class="p">,</span> \
   <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">long_branch_nodes</span><span class="p">]</span>

<span class="c"># We can also use the add_feature() method to dynamically add new features.</span>
<span class="n">label</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;custom label:&quot;</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;custom label value:&quot;</span><span class="p">)</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Ancestor has now the [&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="s">&quot;] attribute with value [&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">&quot;]&quot;</span>
</pre></div>
</div>
<p>Unfortunately, newick format does not support adding extra features to
a tree.  Because of this drawback, several improved formats haven been
(or are being) developed to read and write tree based
information. Some of these new formats are based in a completely new
standard (<a class="reference internal" href="tutorial_xml.html"><em>Phylogenetic XML standards</em></a>), while others are extensions of the
original newick formar (NHX
<a class="reference external" href="http://phylosoft.org/NHX/http://phylosoft.org/NHX/">http://phylosoft.org/NHX/http://phylosoft.org/NHX/</a>).</p>
<p>Currently, ETE
includes support for the New Hampshire eXtended format (NHX), which
uses the original newick standard and adds the possibility of saving
additional date related to each tree node. Here is an example of a
extended newick representation in which extra information is added to
an internal node:</p>
<div class="highlight-python"><pre>(A:0.35,(B:0.72,(D:0.60,G:0.12):0.64[&amp;&amp;NHX:conf=0.01:name=INTERNAL]):0.56);</pre>
</div>
<p>As you can notice, extra node features in the NHX format are enclosed
between brackets. ETE is able to read and write features using such
format, however, the encoded information is expected to be exportable
as plain text.</p>
<p>The NHX format is automatically detected when reading a newick file,
and the detected node features are added using the
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_feature" title="ete2.TreeNode.add_feature"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.add_feature()</span></tt></a> method.  Consequently, you can access the
information by using the normal ETE&#8217;s feature notation:
<tt class="docutils literal"><span class="pre">node.feature_name</span></tt>. Similarly, features added to a tree can
be included within the normal newick representation using the NHX
notation. For this, you can call the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.write" title="ete2.TreeNode.write"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.write()</span></tt></a> method
using the <tt class="xref py py-attr docutils literal"><span class="pre">features</span></tt> argument, which is expected to be a list
with the features names that you want to include in the newick
string. Note that all nodes containing the suplied features will be
exposed into the newick string. Use an empty features list
(<tt class="xref py py-attr docutils literal"><span class="pre">features=[]</span></tt>) to include all node&#8217;s data into the newick
string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Creates a normal tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((H:0.3,I:0.1):0.5, A:1,(B:0.4,(C:0.5,(J:1.3,(F:1.2, D:0.1):0.5):0.5):0.5):0.5);&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c"># Let&#39;s locate some nodes using the get common ancestor method</span>
<span class="n">ancestor</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Let&#39;s label leaf nodes</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s">&quot;AEIOU&quot;</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="c"># Let&#39;s detect leaf nodes under &quot;ancestor&quot; with distance higher thatn</span>
<span class="c"># 1. Note that I&#39;m traversing a subtree which starts from &quot;ancestor&quot;</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="p">]</span>

<span class="c"># And save this pre-computed information into the ancestor node</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">&quot;long_branch_nodes&quot;</span><span class="p">,</span> <span class="n">matches</span><span class="p">)</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;NHX notation including vowel and confidence attributes&quot;</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;vowel&quot;</span><span class="p">,</span> <span class="s">&quot;confidence&quot;</span><span class="p">])</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;NHX notation including all node&#39;s data&quot;</span>
<span class="k">print</span>

<span class="c"># Note that when all features are requested, only those with values</span>
<span class="c"># equal to text-strings or numbers are considered. &quot;long_branch_nodes&quot;</span>
<span class="c"># is not included into the newick string.</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[])</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;basic newick formats are still available&quot;</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;vowel&quot;</span><span class="p">])</span>
<span class="c"># You don&#39;t need to do anything speciall to read NHX notation. Just</span>
<span class="c"># specify the newick format and the NHX tags will be automatically</span>
<span class="c"># detected.</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">(((ADH2:0.1[&amp;&amp;NHX:S=human:E=1.1.1.1], ADH1:0.11[&amp;&amp;NHX:S=human:E=1.1.1.1])</span>
<span class="s">:0.05[&amp;&amp;NHX:S=Primates:E=1.1.1.1:D=Y:B=100], ADHY:0.1[&amp;&amp;NHX:S=nematode:</span>
<span class="s">E=1.1.1.1],ADHX:0.12[&amp;&amp;NHX:S=insect:E=1.1.1.1]):0.1[&amp;&amp;NHX:S=Metazoa:</span>
<span class="s">E=1.1.1.1:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH3:0.13[&amp;&amp;NHX:S=yeast:</span>
<span class="s">E=1.1.1.1], ADH2:0.12[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH1:0.11[&amp;&amp;NHX:S=yeast:E=1.1.1.1]):0.1</span>
<span class="s">[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:E=1.1.1.1:D=N];</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># Loads the NHX example found at http://www.phylosoft.org/NHX/</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
<span class="c"># And access node&#39;s attributes.</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s">&quot;S&quot;</span><span class="p">):</span>
       <span class="k">print</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">S</span>
</pre></div>
</div>
</div>
<div class="section" id="modifying-tree-topology">
<span id="sec-modifying-tree-topology"></span><h2><a class="toc-backref" href="#id20">Modifying Tree Topology</a><a class="headerlink" href="#modifying-tree-topology" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creating-trees-from-scratch">
<h3><a class="toc-backref" href="#id21">Creating Trees from Scratch</a><a class="headerlink" href="#creating-trees-from-scratch" title="Permalink to this headline">¶</a></h3>
<p>If no arguments are passed to the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode" title="ete2.TreeNode"><tt class="xref py py-class docutils literal"><span class="pre">TreeNode</span></tt></a> class constructor,
an empty tree node will be returned. Such an orphan node can be used
to populate a tree from scratch. For this, the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.up" title="ete2.TreeNode.up"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.up</span></tt></a>,
and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.children" title="ete2.TreeNode.children"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.children</span></tt></a> attributes should never be used (unless
it is strictly necessary). Instead, several methods exist to
manipulate the topology of a tree:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.populate" title="ete2.TreeNode.populate"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.populate</span></tt></a>(size[,&nbsp;names_library,&nbsp;...])</td>
<td>Generates a random topology by populating current node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_child" title="ete2.TreeNode.add_child"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.add_child</span></tt></a>([child,&nbsp;name,&nbsp;dist,&nbsp;support])</td>
<td>Adds a new child to this node.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_child" title="ete2.TreeNode.add_child"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.add_child</span></tt></a>([child,&nbsp;name,&nbsp;dist,&nbsp;support])</td>
<td>Adds a new child to this node.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.delete" title="ete2.TreeNode.delete"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.delete</span></tt></a>([prevent_nondicotomic])</td>
<td>Deletes node from the tree structure.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.detach" title="ete2.TreeNode.detach"><tt class="xref py py-obj docutils literal"><span class="pre">TreeNode.detach</span></tt></a>()</td>
<td>Detachs this node (and all its descendants) from its parent and returns the referent to itself.</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span> <span class="c"># Creates an empty tree</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="c"># Adds a new child to the current tree root</span>
                           <span class="c"># and returns it</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;B&quot;</span><span class="p">)</span> <span class="c"># Adds a second child to the current tree</span>
                           <span class="c"># root and returns it</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)</span> <span class="c"># Adds a new child to one of the branches</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">add_sister</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)</span> <span class="c"># Adds a second child to same branch as</span>
                             <span class="c"># before, but using a sister as the starting</span>
                             <span class="c"># point</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;R&quot;</span><span class="p">)</span> <span class="c"># Adds a third child to the</span>
                           <span class="c"># branch. Multifurcations are supported</span>
<span class="c"># Next, I add 6 random leaves to the R branch names_library is an</span>
<span class="c"># optional argument. If no names are provided, they will be generated</span>
<span class="c"># randomly.</span>
<span class="n">R</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">names_library</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;r1&quot;</span><span class="p">,</span><span class="s">&quot;r2&quot;</span><span class="p">,</span><span class="s">&quot;r3&quot;</span><span class="p">,</span><span class="s">&quot;r4&quot;</span><span class="p">,</span><span class="s">&quot;r5&quot;</span><span class="p">,</span><span class="s">&quot;r6&quot;</span><span class="p">])</span>
<span class="c"># Prints the tree topology</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                     /-C</span>
<span class="c">#                    |</span>
<span class="c">#                    |--D</span>
<span class="c">#                    |</span>
<span class="c">#           /--------|                              /-r4</span>
<span class="c">#          |         |                    /--------|</span>
<span class="c">#          |         |          /--------|          \-r3</span>
<span class="c">#          |         |         |         |</span>
<span class="c">#          |         |         |          \-r5</span>
<span class="c">#          |          \--------|</span>
<span class="c"># ---------|                   |                    /-r6</span>
<span class="c">#          |                   |          /--------|</span>
<span class="c">#          |                    \--------|          \-r2</span>
<span class="c">#          |                             |</span>
<span class="c">#          |                              \-r1</span>
<span class="c">#          |</span>
<span class="c">#           \-B</span>
<span class="c"># a common use of the populate method is to quickly create example</span>
<span class="c"># trees from scratch. Here we create a random tree with 100 leaves.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="deleting-eliminating-and-removing-detaching-nodes">
<h3><a class="toc-backref" href="#id22">Deleting (eliminating) and Removing (detaching) nodes</a><a class="headerlink" href="#deleting-eliminating-and-removing-detaching-nodes" title="Permalink to this headline">¶</a></h3>
<p>As currently implemented, there is a difference between detaching and
deleting a node. The former disconnects a complete partition from the
tree structure, so all its descendants are also disconnected from the
tree. There are two methods to perform this action:
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.remove_child" title="ete2.TreeNode.remove_child"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.remove_child()</span></tt></a> and <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.detach" title="ete2.TreeNode.detach"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.detach()</span></tt></a>. In
contrast, deleting a node means eliminating such node without
affecting its descendants. Children from the deleted node are
automatically connected to the next possible parent. This is better
understood with the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Loads a tree. Note that we use format 1 to read internal node names</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;original tree looks like this:&quot;</span>
<span class="c"># This is an alternative way of using &quot;print t&quot;. Thus we have a bit</span>
<span class="c"># more of control on how tree is printed. Here i print the tree</span>
<span class="c"># showing internal node names</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /A-------|          \G-------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-E</span>
<span class="c">#-NoName--|</span>
<span class="c">#         |                    /-L</span>
<span class="c">#         |          /J-------|</span>
<span class="c">#         |         |         |          /-N</span>
<span class="c">#         |         |          \O-------|</span>
<span class="c">#          \C-------|                    \-Q</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-P</span>
<span class="c">#                    \M-------|</span>
<span class="c">#                              \-S</span>
<span class="c"># Get pointers to specific nodes</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;G&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;J&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># If we remove J from the tree, the whole partition under J node will</span>
<span class="c"># be detached from the tree and it will be considered an independent</span>
<span class="c"># tree. We can do the same thing using two approaches: J.detach() or</span>
<span class="c"># C.remove_child(J)</span>
<span class="n">removed_node</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="c"># = C.remove_child(J)</span>
<span class="c"># if we know print the original tree, we will see how J partition is</span>
<span class="c"># no longer there.</span>
<span class="k">print</span> <span class="s">&quot;Tree after REMOVING the node J&quot;</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /A-------|          \G-------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#-NoName--|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-P</span>
<span class="c">#          \C------- /M-------|</span>
<span class="c">#                              \-S</span>
<span class="c"># however, if we DELETE the node G, only G will be eliminated from the</span>
<span class="c"># tree, and all its descendants will then hang from the next upper</span>
<span class="c"># node.</span>
<span class="n">G</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;Tree after DELETING the node G&quot;</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |--F</span>
<span class="c">#          /A-------|         |</span>
<span class="c">#         |         |          \-I</span>
<span class="c">#         |         |</span>
<span class="c">#-NoName--|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-P</span>
<span class="c">#          \C------- /M-------|</span>
<span class="c">#                              \-S</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pruning-trees">
<h2><a class="toc-backref" href="#id23">Pruning trees</a><a class="headerlink" href="#pruning-trees" title="Permalink to this headline">¶</a></h2>
<p>Pruning a tree means to obtain the topology that connects a certain
group of items by removing the unnecessary edges. To facilitate this
task, ETE implements the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.prune" title="ete2.TreeNode.prune"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.prune()</span></tt></a> method, which can be
used by providing the list of terminal and/or internal nodes that must
be kept in the tree.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Let&#39;s create simple tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K),(F,I)G),E),((L,(N,Q)O),(P,S)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Original tree looks like this:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /--------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /--------|          \--------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-E</span>
<span class="c">#---------|</span>
<span class="c">#         |                    /-L</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-N</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                    \-Q</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-P</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-S</span>
<span class="c"># Prune the tree in order to keep only some leaf nodes.</span>
<span class="n">t</span><span class="o">.</span><span class="n">prune</span><span class="p">([</span><span class="s">&quot;H&quot;</span><span class="p">,</span><span class="s">&quot;F&quot;</span><span class="p">,</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="s">&quot;Q&quot;</span><span class="p">,</span> <span class="s">&quot;P&quot;</span><span class="p">])</span>
<span class="k">print</span> <span class="s">&quot;Pruned tree&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                              /-F</span>
<span class="c">#                    /--------|</span>
<span class="c">#          /--------|          \-H</span>
<span class="c">#         |         |</span>
<span class="c">#---------|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |          /-Q</span>
<span class="c">#          \--------|</span>
<span class="c">#                    \-P</span>
<span class="c"># Let&#39;s re-create the same tree again</span>
</pre></div>
</div>
</div>
<div class="section" id="concatenating-trees">
<h2><a class="toc-backref" href="#id24">Concatenating trees</a><a class="headerlink" href="#concatenating-trees" title="Permalink to this headline">¶</a></h2>
<p>Given that all tree nodes share the same basic properties, they can be
connected freely. In fact, any node can add a whole subtree as a
child, so we can actually <em>cut &amp; paste</em> partitions. To do so, you only
need to call the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.add_child" title="ete2.TreeNode.add_child"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.add_child()</span></tt></a> method using another tree
node as a first argument. If such a node is the root node of a
different tree, you will concatenate two structures. But caution!!,
this kind of operations may result into circular tree structures if
add an node&#8217;s ancestor as a new node&#8217;s child. Some basic checks are
internally performed by the ETE topology related methods, however, a
fully qualified check of this issue would affect seriously the
performance of the method. For this reason, users themselves should
take care about not creating circular structures by mistake.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Loads 3 independent trees</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(A,(B,C));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((D,E), (F,G));&#39;</span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(H, ((I,J), (K,L)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree1:&quot;</span><span class="p">,</span> <span class="n">t1</span>
<span class="c">#            /-A</span>
<span class="c">#  ---------|</span>
<span class="c">#           |          /-B</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-C</span>
<span class="k">print</span> <span class="s">&quot;Tree2:&quot;</span><span class="p">,</span> <span class="n">t2</span>
<span class="c">#                      /-D</span>
<span class="c">#            /--------|</span>
<span class="c">#           |          \-E</span>
<span class="c">#  ---------|</span>
<span class="c">#           |          /-F</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-G</span>
<span class="k">print</span> <span class="s">&quot;Tree3:&quot;</span><span class="p">,</span> <span class="n">t3</span>
<span class="c">#            /-H</span>
<span class="c">#           |</span>
<span class="c">#  ---------|                    /-I</span>
<span class="c">#           |          /--------|</span>
<span class="c">#           |         |          \-J</span>
<span class="c">#            \--------|</span>
<span class="c">#                     |          /-K</span>
<span class="c">#                      \--------|</span>
<span class="c">#                                \-L</span>
<span class="c"># Locates a terminal node in the first tree</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># and adds the two other trees as children.</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Resulting concatenated tree:&quot;</span><span class="p">,</span> <span class="n">t1</span>
<span class="c">#                                          /-D</span>
<span class="c">#                                /--------|</span>
<span class="c">#                               |          \-E</span>
<span class="c">#                      /--------|</span>
<span class="c">#                     |         |          /-F</span>
<span class="c">#                     |          \--------|</span>
<span class="c">#            /--------|                    \-G</span>
<span class="c">#           |         |</span>
<span class="c">#           |         |          /-H</span>
<span class="c">#           |         |         |</span>
<span class="c">#           |          \--------|                    /-I</span>
<span class="c">#           |                   |          /--------|</span>
<span class="c">#  ---------|                   |         |          \-J</span>
<span class="c">#           |                    \--------|</span>
<span class="c">#           |                             |          /-K</span>
<span class="c">#           |                              \--------|</span>
<span class="c">#           |                                        \-L</span>
<span class="c">#           |</span>
<span class="c">#           |          /-B</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-C</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-rooting">
<span id="sec-tree-rooting"></span><h2><a class="toc-backref" href="#id25">Tree Rooting</a><a class="headerlink" href="#tree-rooting" title="Permalink to this headline">¶</a></h2>
<p>Tree rooting is understood as the technique by with a given tree is
conceptually polarized from more basal to more terminal nodes. In
phylogenetics, for instance, this a crucial step prior to the
interpretation of trees, since it will determine the evolutionary
relationships among the species involved. The concept of rooted trees
is different than just having a root node, which is always necessary
to handle a tree data structure. Usually, the way in which a tree is
differentiated between rooted and unrooted, is by counting the number
of branches of the current root node. Thus, if the root node has more
than two child branches, the tree is considered unrooted. By contrast,
when only two main branches exist under the root node, the tree is
considered rooted.</p>
<p>Having an unrooted tree means that any internal branch within the tree
could be regarded as the root node, and there is no conceptual reason
to place the root node where it is placed at the moment. Therefore, in
an unrooted tree, there is no information about which internal nodes
are more basal than others. By setting the root node between a given
edge/branch of the tree structure the tree is polarized, meaning that
the two branches under the root node are the most basal nodes. In
practice, this is usually done by setting an <strong>outgroup</strong> <strong>node</strong>,
which would represent one of these main root branches. The second one
will be, obviously, the brother node. When you set an outgroup on
unrooted trees, the multifurcations at the current root node are
solved.</p>
<p>In order to root an unrooted tree or re-root a tree structure, ETE
implements the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.set_outgroup" title="ete2.TreeNode.set_outgroup"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.set_outgroup()</span></tt></a> method, which is present
in any tree node instance.  Similarly, the <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.unroot" title="ete2.TreeNode.unroot"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.unroot()</span></tt></a>
method can be used to perform the opposite action.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Load an unrooted tree. Note that three branches hang from the root</span>
<span class="c"># node. This usually means that no information is available about</span>
<span class="c"># which of nodes is more basal.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(A,(H,F)(B,(E,D)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Unrooted tree&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#          /-A</span>
<span class="c">#         |</span>
<span class="c">#         |          /-H</span>
<span class="c">#---------|---------|</span>
<span class="c">#         |          \-F</span>
<span class="c">#         |</span>
<span class="c">#         |          /-B</span>
<span class="c">#          \--------|</span>
<span class="c">#                   |          /-E</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>
<span class="c">#</span>
<span class="c"># Let&#39;s define that the ancestor of E and D as the tree outgroup.  Of</span>
<span class="c"># course, the definition of an outgroup will depend on user criteria.</span>
<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">ancestor</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree rooteda at E and D&#39;s ancestor is more basal that the others.&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                    /-B</span>
<span class="c">#          /--------|</span>
<span class="c">#         |         |          /-A</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-H</span>
<span class="c">#---------|                    \--------|</span>
<span class="c">#         |                              \-F</span>
<span class="c">#         |</span>
<span class="c">#         |          /-E</span>
<span class="c">#          \--------|</span>
<span class="c">#                    \-D</span>
<span class="c">#</span>
<span class="c"># Note that setting a different outgroup, a different interpretation</span>
<span class="c"># of the tree is possible</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;A&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree rooted at a terminal node&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-H</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |          \-F</span>
<span class="c">#          /--------|</span>
<span class="c">#         |         |          /-B</span>
<span class="c">#         |          \--------|</span>
<span class="c">#---------|                   |          /-E</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#         |                              \-D</span>
<span class="c">#         |</span>
<span class="c">#          \-A</span>
</pre></div>
</div>
<p>Note that although <strong>rooting</strong> is usually regarded as a whole-tree
operation, ETE allows to root subparts of the tree without affecting
to its parent tree structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((A,C),((H,F),(L,M))),((B,(J,K))(E,D)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Original tree:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-A</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |          \-C</span>
<span class="c">#                   |</span>
<span class="c">#          /--------|                    /-H</span>
<span class="c">#         |         |          /--------|</span>
<span class="c">#         |         |         |          \-F</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-L</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#---------|                              \-M</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-B</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-J</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                    \-K</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-E</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>
<span class="c">#</span>
<span class="c"># Each main branch of the tree is independently rooted.</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;H&quot;</span><span class="p">)</span>
<span class="n">node2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="n">node1</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s">&quot;H&quot;</span><span class="p">)</span>
<span class="n">node2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree after rooting each node independently:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                              /-F</span>
<span class="c">#                             |</span>
<span class="c">#                    /--------|                    /-L</span>
<span class="c">#                   |         |          /--------|</span>
<span class="c">#                   |         |         |          \-M</span>
<span class="c">#                   |          \--------|</span>
<span class="c">#          /--------|                   |          /-A</span>
<span class="c">#         |         |                    \--------|</span>
<span class="c">#         |         |                              \-C</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-H</span>
<span class="c">#---------|</span>
<span class="c">#         |                    /-D</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-B</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                   |          /-J</span>
<span class="c">#                   |                    \--------|</span>
<span class="c">#                   |                              \-K</span>
<span class="c">#                   |</span>
<span class="c">#                    \-E</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-branch-distances">
<h2><a class="toc-backref" href="#id26">Working with branch distances</a><a class="headerlink" href="#working-with-branch-distances" title="Permalink to this headline">¶</a></h2>
<p>The branch length between one node an its parent is encoded as the
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.dist" title="ete2.TreeNode.dist"><tt class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></tt></a> attribute. Together with tree topology, branch
lengths define the relationships among nodes.</p>
<div class="section" id="getting-distances-between-nodes">
<h3><a class="toc-backref" href="#id27">Getting distances between nodes</a><a class="headerlink" href="#getting-distances-between-nodes" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_distance" title="ete2.TreeNode.get_distance"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_distance()</span></tt></a> method can be used to calculate the
distance between two connected nodes. There are two ways of using this
method: a) by querying the distance between two descendant nodes (two
nodes are passed as arguments) b) by querying the distance between the
current node and any other relative node (parental or descendant).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree with branch lenght information. Note that if no</span>
<span class="c"># distance info is provided in the newick, it will be initialized with</span>
<span class="c"># the default dist value = 1.0</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;(((A:0.1, B:0.01):0.001, C:0.0001):1.0,</span>
<span class="s">(((((D:0.00001:0,I:0):0,F:0):0,G:0):0,H:0):0,</span>
<span class="s">E:0.000001):0.0000001):2.0;&quot;&quot;&quot;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-A</span>
<span class="c">#                    /--------|</span>
<span class="c">#          /--------|          \-B</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-C</span>
<span class="c">#         |</span>
<span class="c">#         |                                                  /-D</span>
<span class="c">#         |                                        /--------|</span>
<span class="c">#---------|                              /--------|          \-I</span>
<span class="c">#         |                             |         |</span>
<span class="c">#         |                    /--------|          \-F</span>
<span class="c">#         |                   |         |</span>
<span class="c">#         |          /--------|          \-G</span>
<span class="c">#         |         |         |</span>
<span class="c">#          \--------|          \-H</span>
<span class="c">#                   |</span>
<span class="c">#                    \-E</span>
<span class="c">#</span>
<span class="c"># Locate some nodes</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;A&quot;</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span>
<span class="c"># Calculate distance from current node</span>
<span class="k">print</span> <span class="s">&quot;The distance between A and C is&quot;</span><span class="p">,</span>  <span class="n">A</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Calculate distance between two descendants of current node</span>
<span class="k">print</span> <span class="s">&quot;The distance between A and C is&quot;</span><span class="p">,</span>  <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Calculate the toplogical distance (number of nodes in between)</span>
<span class="k">print</span> <span class="s">&quot;The number of nodes between A and D is &quot;</span><span class="p">,</span>  \
    <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Additionally to this, ETE incorporates two more methods to calculate
the most distant node from a given point in a tree. You can use the
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_farthest_node" title="ete2.TreeNode.get_farthest_node"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_farthest_node()</span></tt></a> method to retrieve the most distant
point from a node within the whole tree structure. Alternatively,
<a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_farthest_leaf" title="ete2.TreeNode.get_farthest_leaf"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_farthest_leaf()</span></tt></a> will return the most distant
descendant (always a leaf). If more than one node matches the farthest
distance, the first occurrence is returned.</p>
<p>Distance between nodes can also be computed as the number of nodes
between them (considering all branch lengths equal to 1.0). To do so,
the <strong>topology_only</strong> argument must be set to <strong>True</strong> for all the
above mentioned methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Calculate the farthest node from E within the whole structure</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;E&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;The farthest node from E is&quot;</span><span class="p">,</span> <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with dist=&quot;</span><span class="p">,</span> <span class="n">dist</span>
<span class="c"># Calculate the farthest node from E within the whole structure,</span>
<span class="c"># regarding the number of nodes in between as distance value</span>
<span class="c"># Note that the result is differnt.</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;E&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">(</span><span class="n">topology_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;The farthest (topologically) node from E is&quot;</span><span class="p">,</span> \
    <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="s">&quot;nodes in between&quot;</span>
<span class="c"># Calculate farthest node from an internal node</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;The farthest node from root is is&quot;</span><span class="p">,</span> <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with dist=&quot;</span><span class="p">,</span> <span class="n">dist</span>
<span class="c">#</span>
<span class="c"># The program results in the following information:</span>
<span class="c">#</span>
<span class="c"># The distance between A and C is 0.1011</span>
<span class="c"># The distance between A and C is 0.1011</span>
<span class="c"># The number of nodes between A and D is  8.0</span>
<span class="c"># The farthest node from E is A with dist= 1.1010011</span>
<span class="c"># The farthest (topologically) node from E is I with 5.0 nodes in between</span>
<span class="c"># The farthest node from root is is A with dist= 1.101</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-midpoint-outgroup">
<span id="sub-getting-midpoint-outgroup"></span><h3><a class="toc-backref" href="#id28">getting midpoint outgroup</a><a class="headerlink" href="#getting-midpoint-outgroup" title="Permalink to this headline">¶</a></h3>
<p>In order to obtain a balanced rooting of the tree, you can set as the tree
outgroup that partition which splits the tree in two equally distant clusters
(using branch lengths). This is called the midpoint outgroup.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete2.TreeNode.get_midpoint_outgroup" title="ete2.TreeNode.get_midpoint_outgroup"><tt class="xref py py-func docutils literal"><span class="pre">TreeNode.get_midpoint_outgroup()</span></tt></a> method will return the
outgroup partition that splits current node into two balanced branches
in terms of node distances.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete2</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># generates a random tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">();</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#                    /-qogjl</span>
<span class="c">#          /--------|</span>
<span class="c">#         |          \-vxbgp</span>
<span class="c">#         |</span>
<span class="c">#         |          /-xyewk</span>
<span class="c">#---------|         |</span>
<span class="c">#         |         |                    /-opben</span>
<span class="c">#         |         |                   |</span>
<span class="c">#         |         |          /--------|                    /-xoryn</span>
<span class="c">#          \--------|         |         |          /--------|</span>
<span class="c">#                   |         |         |         |         |          /-wdima</span>
<span class="c">#                   |         |          \--------|          \--------|</span>
<span class="c">#                   |         |                   |                    \-qxovz</span>
<span class="c">#                   |         |                   |</span>
<span class="c">#                   |         |                    \-isngq</span>
<span class="c">#                    \--------|</span>
<span class="c">#                             |                    /-neqsc</span>
<span class="c">#                             |                   |</span>
<span class="c">#                             |                   |                              /-waxkv</span>
<span class="c">#                             |          /--------|                    /--------|</span>
<span class="c">#                             |         |         |          /--------|          \-djeoh</span>
<span class="c">#                             |         |         |         |         |</span>
<span class="c">#                             |         |          \--------|          \-exmsn</span>
<span class="c">#                              \--------|                   |</span>
<span class="c">#                                       |                   |          /-udspq</span>
<span class="c">#                                       |                    \--------|</span>
<span class="c">#                                       |                              \-buxpw</span>
<span class="c">#                                       |</span>
<span class="c">#                                        \-rkzwd</span>
<span class="c"># Calculate the midpoint node</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">()</span>
<span class="c"># and set it as tree outgroup</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-opben</span>
<span class="c">#                             |</span>
<span class="c">#                    /--------|                    /-xoryn</span>
<span class="c">#                   |         |          /--------|</span>
<span class="c">#                   |         |         |         |          /-wdima</span>
<span class="c">#                   |          \--------|          \--------|</span>
<span class="c">#          /--------|                   |                    \-qxovz</span>
<span class="c">#         |         |                   |</span>
<span class="c">#         |         |                    \-isngq</span>
<span class="c">#         |         |</span>
<span class="c">#         |         |          /-xyewk</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-qogjl</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#---------|                              \-vxbgp</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-neqsc</span>
<span class="c">#         |                   |</span>
<span class="c">#         |                   |                              /-waxkv</span>
<span class="c">#         |          /--------|                    /--------|</span>
<span class="c">#         |         |         |          /--------|          \-djeoh</span>
<span class="c">#         |         |         |         |         |</span>
<span class="c">#         |         |          \--------|          \-exmsn</span>
<span class="c">#          \--------|                   |</span>
<span class="c">#                   |                   |          /-udspq</span>
<span class="c">#                   |                    \--------|</span>
<span class="c">#                   |                              \-buxpw</span>
<span class="c">#                   |</span>
<span class="c">#                    \-rkzwd</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ete_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Working With Tree Data Structures</a><ul>
<li><a class="reference internal" href="#trees">Trees</a></li>
<li><a class="reference internal" href="#reading-and-writing-newick-trees">Reading and Writing Newick Trees</a><ul>
<li><a class="reference internal" href="#reading-newick-trees">Reading newick trees</a></li>
<li><a class="reference internal" href="#writing-newick-trees">Writing newick trees</a></li>
</ul>
</li>
<li><a class="reference internal" href="#understanding-ete-trees">Understanding ETE Trees</a></li>
<li><a class="reference internal" href="#basic-tree-attributes">Basic tree attributes</a><ul>
<li><a class="reference internal" href="#root-node-on-unrooted-trees">Root node on unrooted trees?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#browsing-trees">Browsing trees</a><ul>
<li><a class="reference internal" href="#getting-leaves-descendants-and-node-s-relatives">Getting Leaves, Descendants and Node&#8217;s Relatives</a></li>
<li><a class="reference internal" href="#traversing-browsing-trees">Traversing (browsing) trees</a></li>
<li><a class="reference internal" href="#iterating-instead-of-getting">Iterating instead of Getting</a></li>
<li><a class="reference internal" href="#finding-nodes-by-their-attributes">Finding nodes by their attributes</a><ul>
<li><a class="reference internal" href="#search-all-nodes-matching-a-given-criteria">Search_all nodes matching a given criteria</a></li>
<li><a class="reference internal" href="#search-nodes-matching-a-given-criteria-iteration">Search nodes matching a given criteria (iteration)</a></li>
<li><a class="reference internal" href="#find-the-first-common-ancestor">Find the first common ancestor</a></li>
<li><a class="reference internal" href="#custom-searching-functions">Custom searching functions</a></li>
<li><a class="reference internal" href="#shortcuts">Shortcuts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#node-annotation">Node annotation</a></li>
<li><a class="reference internal" href="#modifying-tree-topology">Modifying Tree Topology</a><ul>
<li><a class="reference internal" href="#creating-trees-from-scratch">Creating Trees from Scratch</a></li>
<li><a class="reference internal" href="#deleting-eliminating-and-removing-detaching-nodes">Deleting (eliminating) and Removing (detaching) nodes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pruning-trees">Pruning trees</a></li>
<li><a class="reference internal" href="#concatenating-trees">Concatenating trees</a></li>
<li><a class="reference internal" href="#tree-rooting">Tree Rooting</a></li>
<li><a class="reference internal" href="#working-with-branch-distances">Working with branch distances</a><ul>
<li><a class="reference internal" href="#getting-distances-between-nodes">Getting distances between nodes</a></li>
<li><a class="reference internal" href="#getting-midpoint-outgroup">getting midpoint outgroup</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">The ETE tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tutorial_drawing.html"
                        title="next chapter">The Programmable Tree Drawing Engine</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/tutorial/tutorial_trees.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial_drawing.html" title="The Programmable Tree Drawing Engine"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="The ETE tutorial"
             >previous</a> |</li>
        <li><a href="../index.html">ETE documentation</a> &raquo;</li>
          <li><a href="index.html" >The ETE tutorial</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Jaime Huerta-Cepas &amp; Toni Gabaldón.
      Last updated on Dec 19, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>