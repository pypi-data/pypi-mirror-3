

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>m4us.core.interfaces &mdash; Message For You Sir! 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Message For You Sir! 0.3.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Message For You Sir! 0.3.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for m4us.core.interfaces</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="c">#---Header---------------------------------------------------------------------</span>

<span class="c"># This file is part of Message For You Sir (m4us).</span>
<span class="c"># Copyright Â© 2009-2012 Krys Lawrence</span>
<span class="c">#</span>
<span class="c"># Message For You Sir is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU Affero General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or (at your</span>
<span class="c"># option) any later version.</span>
<span class="c">#</span>
<span class="c"># Message For You Sir is distributed in the hope that it will be useful, but</span>
<span class="c"># WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c"># FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License</span>
<span class="c"># for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU Affero General Public License</span>
<span class="c"># along with Message For You Sir.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>


<span class="sd">&quot;&quot;&quot;Provides the `interface` definitions for all important core objects.&quot;&quot;&quot;</span>

<span class="c">## pylint: disable=E0211,R0903,E0213,W0232</span>


<span class="c">#---Imports--------------------------------------------------------------------</span>

<span class="c">#---  Standard library imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="c">## pylint: disable=W0622, W0611</span>
<span class="kn">from</span> <span class="nn">future_builtins</span> <span class="kn">import</span> <span class="n">ascii</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="nb">zip</span>  <span class="c">## NOQA</span>
<span class="c">## pylint: enable=W0622, W0611</span>

<span class="c">#---  Third-party imports</span>
<span class="c">## pylint: disable=F0401</span>
<span class="kn">from</span> <span class="nn">zope</span> <span class="kn">import</span> <span class="n">interface</span>
<span class="c">## pylint: enable=F0401</span>

<span class="c">#---  Project imports</span>


<span class="c">#---Globals--------------------------------------------------------------------</span>


<span class="c">#---Functions------------------------------------------------------------------</span>


<span class="c">#---Classes--------------------------------------------------------------------</span>

<span class="c">#---  Messages interfaces</span>

<div class="viewcode-block" id="IMessageFactory"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IMessageFactory">[docs]</a><span class="k">class</span> <span class="nc">IMessageFactory</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `callables` that return :class:`IMessage` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IMessageFactory.__call__"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IMessageFactory.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Return the desired `message`.</span>

<span class="sd">        The `callable` should only be called with keyword arguments.</span>

<span class="sd">        :param collections.Mapping kwargs: Keywords arguments to pass to the</span>
<span class="sd">          `factory` `callable`.</span>

<span class="sd">        :returns: The desired `message` object.</span>
<span class="sd">        :rtype: :class:`IMessage`</span>

<span class="sd">        .. note::</span>

<span class="sd">          All unrecognized keyword arguments should be set as attributes on the</span>
<span class="sd">          :class:`IMessage` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="IMessage"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IMessage">[docs]</a><span class="k">class</span> <span class="nc">IMessage</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for special `messages` passed between `coroutines`.&quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="IShutdown"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IShutdown">[docs]</a><span class="k">class</span> <span class="nc">IShutdown</span><span class="p">(</span><span class="n">IMessage</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `messages` that tell `coroutines` to shutdown.</span>

<span class="sd">    Upon receipt of an :class:`IShutdown` `message`, `coroutines` should clean</span>
<span class="sd">    up any loose ends, forward on the :class:`IShutdown` `message` on it&#39;s</span>
<span class="sd">    ``signal`` `outbox` and then shutdown.</span>

<span class="sd">    &quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="IProducerFinished"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IProducerFinished">[docs]</a><span class="k">class</span> <span class="nc">IProducerFinished</span><span class="p">(</span><span class="n">IShutdown</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `messages` signalling that a `producer` is done.&quot;&quot;&quot;</span>


<span class="c">#---  Coroutines interfaces</span>
</div>
<div class="viewcode-block" id="ICoroutineFactory"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutineFactory">[docs]</a><span class="k">class</span> <span class="nc">ICoroutineFactory</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `callables` that return :class:`ICoroutine` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ICoroutineFactory.__call__"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutineFactory.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Return the desired `coroutine`.</span>

<span class="sd">        :param collections.Sequence args: Any arguments to pass to the</span>
<span class="sd">          `factory` `callable`.</span>
<span class="sd">        :param collections.Mapping kwargs: Keywords arguments to pass to the</span>
<span class="sd">          `factory` `callable`.</span>

<span class="sd">        :returns: The desired `coroutine`.</span>
<span class="sd">        :rtype: :class:`ICoroutine`</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="ICoroutine"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutine">[docs]</a><span class="k">class</span> <span class="nc">ICoroutine</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` that defines a Python_ `coroutine`.</span>

<span class="sd">    Python_ `coroutines` are defined in :PEP:`342`.</span>

<span class="sd">    .. note::</span>

<span class="sd">      While Python_ `coroutines` are an extension of `generators`, and as such</span>
<span class="sd">      define a ``next()`` method, this `interface` does not include the</span>
<span class="sd">      ``next()`` method as it really only makes sense in the context of actual</span>
<span class="sd">      `generators` rather than for `coroutines`.</span>

<span class="sd">    .. note::</span>

<span class="sd">      By default, all Python_ `coroutines` (i.e. :data:`types.GeneratorType`)</span>
<span class="sd">      have been automatically configured to provide :class:`ICoroutine`.  This</span>
<span class="sd">      makes working with Python_ `coroutines` more natural.</span>

<span class="sd">    .. _Python: http://python.org/</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ICoroutine.send"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutine.send">[docs]</a>    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Send the `message` to the `coroutine`.</span>

<span class="sd">        :param message: The `message` object to send into the `coroutine`.  For</span>
<span class="sd">          this project it will normally be a 2-:obj:`tuple` of the `inbox`</span>
<span class="sd">          and the `message`.</span>

<span class="sd">        :returns: Any `message` :keyword:`yield`\ed by the `coroutine`.  For</span>
<span class="sd">          this project it will normally be a 2-:obj:`tuple` of the `outbox`</span>
<span class="sd">          and the `message`.</span>

<span class="sd">        :raises exceptions.StopIteration: If the `coroutine` has terminated,</span>
<span class="sd">          either by :keyword:`return`\ing (as opposed to :keyword:`yield`\ing)</span>
<span class="sd">          or because the :meth:`close` method was called.</span>

<span class="sd">        .. note::</span>

<span class="sd">          The first call to this method must pass :obj:`None` as the sole</span>
<span class="sd">          argument. This activates the `coroutine`.  The response from the</span>
<span class="sd">          first call is undefined.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="ICoroutine.throw"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutine.throw">[docs]</a>    <span class="k">def</span> <span class="nf">throw</span><span class="p">(</span><span class="n">exception</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Send the exception to the `coroutine`.</span>

<span class="sd">        The `coroutine` is expected to raise the exception in it&#39;s context at</span>
<span class="sd">        the reception point.  It may then catch it and handle it or not.</span>

<span class="sd">        :param exceptions.Exception exception: The exception to send to the</span>
<span class="sd">          `coroutine`.</span>

<span class="sd">        :returns: If the exception is caught, then any `message`</span>
<span class="sd">          :keyword:`yield`\ed by the `coroutine`.</span>

<span class="sd">        :raises exceptions.Exception: Any uncaught exception passed in via this</span>
<span class="sd">          method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="ICoroutine.close"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ICoroutine.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">():</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Terminate the `coroutine`.</span>

<span class="sd">        This method sends the :exc:`~exceptions.GeneratorExit` exception into</span>
<span class="sd">        the `coroutine`, which is expected to perform any necessary clean up</span>
<span class="sd">        and shutdown work and then terminate.</span>

<span class="sd">        .. note::</span>

<span class="sd">          After this method is called, all subsequent calls to :meth:`send`</span>
<span class="sd">          **must** result in a :exc:`~exceptions.StopIteration` exception being</span>
<span class="sd">          raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="INotLazy"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.INotLazy">[docs]</a><span class="k">class</span> <span class="nc">INotLazy</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Marker `interface` signalling that a `coroutine` is not `lazy`.</span>

<span class="sd">    A `coroutine` is called `lazy`, if it should only be executed when there</span>
<span class="sd">    are new incoming `messages` for it.  It is *not* `lazy` if the `coroutine`</span>
<span class="sd">    should be executed even when there are no incoming `messages` (i.e. for</span>
<span class="sd">    polling, etc.)</span>

<span class="sd">    :class:`INotLazy` `coroutines` will receive :obj:`None` objects as messages</span>
<span class="sd">    on their ``control`` `inbox` when there are no other `messages` to for</span>
<span class="sd">    them.</span>

<span class="sd">    .. note::</span>

<span class="sd">      By default, all objects providing :class:`ICoroutine` are presumptively</span>
<span class="sd">      `lazy`.  They need to provide this `interface` to indicate otherwise.</span>
<span class="sd">      This is more efficient and more natural for `coroutines`.  It also more</span>
<span class="sd">      accurately distinguishes them from regular `generators`.</span>

<span class="sd">    &quot;&quot;&quot;</span>


<span class="c">#---  Postoffices interfaces</span>
</div>
<div class="viewcode-block" id="IPostOfficeFactory"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOfficeFactory">[docs]</a><span class="k">class</span> <span class="nc">IPostOfficeFactory</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `callables` that return :class:`IPostOffice` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IPostOfficeFactory.__call__"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOfficeFactory.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">link_ignores_duplicates</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>  <span class="c"># pragma: no branch</span>
      <span class="n">unlink_ignores_missing</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the desired `post office`.</span>

<span class="sd">        :param bool link_ignores_duplicates: If :obj:`True`, the</span>
<span class="sd">          :meth:`IPostOffice.register` method becomes `idempotent` and will not</span>
<span class="sd">          raise an exception when adding an already added `link`.</span>
<span class="sd">        :param bool unlink_ignores_missing: If :obj:`True`, the</span>
<span class="sd">          :meth:`IPostOffice.unregister` method becomes `idempotent` and will</span>
<span class="sd">          not raise an exception when removing a `link` that was not already</span>
<span class="sd">          added.</span>

<span class="sd">        :returns: The desired `post office`.</span>
<span class="sd">        :rtype: :class:`IPostOffice`</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="IPostOffice"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOffice">[docs]</a><span class="k">class</span> <span class="nc">IPostOffice</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` that defines a `post office`.</span>

<span class="sd">    `Post offices` are objects that are responsible for delivering posted</span>
<span class="sd">    `messages` from `inboxes` to `outboxes`.  They are also responsible for</span>
<span class="sd">    keeping track of the `links` between `mailboxes`.</span>

<span class="sd">    That said, `message` posting and retrieval (and subsequent delivery to</span>
<span class="sd">    `coroutines`) is someone else&#39;s responsibility.  Usually it is the job of</span>
<span class="sd">    the `scheduler`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IPostOffice.register"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOffice.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">first_link</span><span class="p">,</span> <span class="o">*</span><span class="n">other_links</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Register `links` between `coroutines`.</span>

<span class="sd">        When a `source` `coroutine`&#39;s `outbox` is linked to a `sink`</span>
<span class="sd">        `coroutine`&#39;s `inbox`, any `messages` posted from the `source`&#39;s</span>
<span class="sd">        `outbox` will automatically be delivered to the message queue for the</span>
<span class="sd">        `sink`&#39;s `inbox`, where it can be later retrieved for delivery to the</span>
<span class="sd">        `sink` `coroutine`.</span>

<span class="sd">        :param tuple first_link: The first `link` to register.</span>
<span class="sd">        :param collections.Sequence other_links: Any other `links` to register.</span>

<span class="sd">        Each link should be a 4-:obj:`tuple` in the form of :samp:`({source},</span>
<span class="sd">        {outbox}, {sink}, {inbox})`, where:</span>

<span class="sd">        :param m4us.core.interfaces.ICoroutine source: The `source` `coroutine`</span>
<span class="sd">          to link.</span>
<span class="sd">        :param unicode outbox: The `source`&#39;s `outbox` to link.</span>
<span class="sd">        :param m4us.core.interfaces.ICoroutine sink: The `sink` `coroutine` to</span>
<span class="sd">          link.</span>
<span class="sd">        :param unicode inbox: The `sink`&#39;s `inbox` to link.</span>

<span class="sd">        :raises m4us.core.exceptions.LinkExistsError: If a `source`&#39;s `outbox`</span>
<span class="sd">          is already linked to a `sink`&#39;s `inbox`, unless the `post office` was</span>
<span class="sd">          created with ``link_ignores_duplicates=True``.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :class:`IPostOfficeFactory` `interface` for details on the</span>
<span class="sd">          ``link_ignores_duplicates`` parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IPostOffice.unregister"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOffice.unregister">[docs]</a>    <span class="k">def</span> <span class="nf">unregister</span><span class="p">(</span><span class="n">first_link</span><span class="p">,</span> <span class="o">*</span><span class="n">other_links</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Unregister previously registered `links`.</span>

<span class="sd">        This is the opposite of the :meth:`unregister` method.</span>

<span class="sd">        :param tuple first_link: The first `link` to unregister.</span>
<span class="sd">        :param collections.Sequence other_links: Any other `links` to</span>
<span class="sd">          unregister.</span>

<span class="sd">        Each link should be a 4-:obj:`tuple` in the same format as defined in</span>
<span class="sd">        the :meth:`register` method documentation.</span>

<span class="sd">        :raises m4us.core.exceptions.NoLinkError: If a `link` was not</span>
<span class="sd">          previously registered, unless the `post office` was created with</span>
<span class="sd">          ``unlink_ignores_missing=True``.</span>

<span class="sd">        .. note::</span>

<span class="sd">          Unregistering one `link` should not affect any other links involving</span>
<span class="sd">          the `source` `outbox` or the `sink` `inbox`.</span>

<span class="sd">        .. note::</span>

<span class="sd">          Any outstanding messages in the `sink`&#39;s `inbox` message queue should</span>
<span class="sd">          still be kept for delivery.  The message queue should only be removed</span>
<span class="sd">          after all outstanding `messages` have been retrieved.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :meth:`register` method for details on the format of a link.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :class:`IPostOfficeFactory` `interface` for details on the</span>
<span class="sd">          ``unlink_ignores_missing`` parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IPostOffice.post"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOffice.post">[docs]</a>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">outbox</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Post a `message` from the `source` `outbox`.</span>

<span class="sd">        When a `message` is posted, it is automatically sent to the message</span>
<span class="sd">        queues of all linked `sink` `inboxes` for later retrieval and delivery.</span>

<span class="sd">        :param m4us.core.interfaces.ICoroutine source: The `source` `coroutine`</span>
<span class="sd">          that produced the `message`.</span>
<span class="sd">        :param unicode outbox: The `outbox` on which the `source` sent the</span>
<span class="sd">          `message`.</span>
<span class="sd">        :param message: The `message` that the `source` sent.</span>

<span class="sd">        :raises m4us.core.exceptions.NoLinkError: If the `source` `outbox` has</span>
<span class="sd">          not already been registered as a `source` in a `link`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IPostOffice.retrieve"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IPostOffice.retrieve">[docs]</a>    <span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">sink</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all outstanding `messages` for a `sink` `coroutine`.</span>

<span class="sd">        As `messages` are posted, they are accumulated in message queues based</span>
<span class="sd">        on the registered `links`.  When this method is called, all the</span>
<span class="sd">        accumulated `messages` for the given `sink` `coroutine` are returned</span>
<span class="sd">        and the message queue for that `sink` is emptied.</span>

<span class="sd">        If there are no outstanding `messages` waiting in the message queue,</span>
<span class="sd">        then an empty iterable is returned.</span>

<span class="sd">        :param m4us.core.interfaces.ICoroutine sink: The `sink` `coroutine` for</span>
<span class="sd">          which to retrieve `messages`.</span>

<span class="sd">        :returns: All outstanding `messages` in the form of :samp:`({inbox},</span>
<span class="sd">          {message})`.</span>
<span class="sd">        :rtype: :class:`collections.Iterable`</span>

<span class="sd">        :raises m4us.core.exceptions.NotASinkError: If the given `coroutine` is</span>
<span class="sd">          not registered as a `sink` in any of the registered `links`.</span>

<span class="sd">        .. note::</span>

<span class="sd">          It is the responsibility of the caller to make sure all the retrieved</span>
<span class="sd">          `messages` are delivered to the `sink` `coroutine`.</span>

<span class="sd">        &quot;&quot;&quot;</span>


<span class="c">#---  Schedulers interfaces</span>
</div></div>
<div class="viewcode-block" id="ISchedulerFactory"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ISchedulerFactory">[docs]</a><span class="k">class</span> <span class="nc">ISchedulerFactory</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `callables` that return :class:`IScheduler` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ISchedulerFactory.__call__"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.ISchedulerFactory.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">post_office</span><span class="p">,</span>  <span class="c"># pragma: no branch</span>
      <span class="n">add_ignores_duplicates</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">remove_ignores_missing</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the desired `scheduler`.</span>

<span class="sd">        :param m4us.core.interfaces.IPostOffice post_office: The `post office`</span>
<span class="sd">          through which to post and retrieve `messages`.</span>
<span class="sd">        :param bool add_ignores_duplicates: If :obj:`True`, the</span>
<span class="sd">          :meth:`IScheduler.register` method becomes `idempotent` and will not</span>
<span class="sd">          raise an exception when adding an already added `coroutine`.</span>
<span class="sd">        :param bool remove_ignores_missing: If :obj:`True`, the</span>
<span class="sd">          :meth:`IScheduler.unregister` method becomes `idempotent` and will</span>
<span class="sd">          not raise an exception when removing a `coroutine` that was not</span>
<span class="sd">          already added.</span>

<span class="sd">        :returns: The desired `scheduler`.</span>
<span class="sd">        :rtype: :class:`IScheduler`</span>

<span class="sd">        :raises exceptions.TypeError: If the given `post office` does not</span>
<span class="sd">          provide the :class:`IPostOffice` `interface`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="IScheduler"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler">[docs]</a><span class="k">class</span> <span class="nc">IScheduler</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` that defines a `scheduler`.</span>

<span class="sd">    `Scheduler` objects are responsible for being the main program loop.  Their</span>
<span class="sd">    job is to run `coroutines`.  They are also responsible for retrieving and</span>
<span class="sd">    delivering `messages` from a `post office` to the `coroutines`, as well as</span>
<span class="sd">    posting back to the `post office` any `messages` emitted by the</span>
<span class="sd">    `coroutines`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IScheduler.register"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">first_coroutine</span><span class="p">,</span> <span class="o">*</span><span class="n">other_coroutines</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Register one or more `coroutines` with the `scheduler`.</span>

<span class="sd">        In order for a `scheduler` to run a `coroutine`, it must first be added</span>
<span class="sd">        to (i.e. registered with) the `scheduler`.</span>

<span class="sd">        :param m4us.core.interfaces.ICoroutine first_coroutine: The first</span>
<span class="sd">          `coroutine` to add.</span>
<span class="sd">        :param collections.Sequence other_coroutines: Any other `coroutines` to</span>
<span class="sd">          add.</span>

<span class="sd">        :raises exceptions.TypeError: If any given argument does not provide or</span>
<span class="sd">          cannot be adapted to :class:`ICoroutine`.</span>
<span class="sd">        :raises m4us.core.exceptions.DuplicateError: If any given `coroutine`</span>
<span class="sd">          has already been added, unless the `scheduler` was created with</span>
<span class="sd">          ``add_ignores_duplicates=True``.</span>

<span class="sd">        .. note::</span>

<span class="sd">          `Schedulers` are not *required* to preserve or guarantee any</span>
<span class="sd">          particular order in which the `coroutines` will be run.  They may,</span>
<span class="sd">          however, *choose* to do so, if desired.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :class:`ISchedulerFactory` `interface` for details on the</span>
<span class="sd">          ``add_ignores_duplicates`` parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IScheduler.unregister"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler.unregister">[docs]</a>    <span class="k">def</span> <span class="nf">unregister</span><span class="p">(</span><span class="n">first_coroutine</span><span class="p">,</span> <span class="o">*</span><span class="n">other_coroutines</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Unregister one or more `coroutines` from the `scheduler`.</span>

<span class="sd">        This is the opposite of the :meth:`register` method.</span>

<span class="sd">        :param m4us.core.interfaces.ICoroutine first_coroutine: The first</span>
<span class="sd">          `coroutine` to remove.</span>
<span class="sd">        :param collections.Sequence other_coroutines: Any other `coroutines` to</span>
<span class="sd">          remove.</span>

<span class="sd">        :raises m4us.core.exceptions.NotAddedError: If any given `coroutine` is</span>
<span class="sd">          not registered with the `scheduler`, unless the `scheduler` was</span>
<span class="sd">          created with ``remove_ignores_missing=True``.</span>

<span class="sd">        .. note::</span>

<span class="sd">          This method should also call each `coroutine`&#39;s :meth:`!close`</span>
<span class="sd">          method.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :class:`ISchedulerFactory` `interface` for details on the</span>
<span class="sd">          ``remove_ignores_missing`` parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IScheduler.step"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">():</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Run one `coroutine`.</span>

<span class="sd">        This is the smallest unit of execution.  A single registered</span>
<span class="sd">        `coroutine` is run once for each `message` currently accumulated in</span>
<span class="sd">        its `post office` message queue.  Any resulting `messages` are also</span>
<span class="sd">        posted back to the `post office`.  This means that one call to this</span>
<span class="sd">        method can trigger repeated calls to the current `coroutine`, but only</span>
<span class="sd">        one `coroutine` should ever be executed.</span>

<span class="sd">        If a `coroutine` is `lazy`, it should only be executed when there are</span>
<span class="sd">        `messages` waiting to be delivered to it (or it is in the &quot;shutting</span>
<span class="sd">        down&quot; state, see below).  If it is *not* `lazy` (i.e. it provides the</span>
<span class="sd">        :class:`INotLazy` marker `interface`) and there are no `messages`</span>
<span class="sd">        waiting (as is the case with `producers`, for example), then a</span>
<span class="sd">        :obj:`None` object should be sent as the `message` to the `coroutine`</span>
<span class="sd">        on its ``control`` `inbox`.</span>

<span class="sd">        If a `coroutine` :keyword:`yield`\s only a :obj:`None` object (without</span>
<span class="sd">        even an `outbox`), the :obj:`None` should just be discarded.  This lets</span>
<span class="sd">        the `coroutine` indicate it has no `message` to send.</span>

<span class="sd">        If a `coroutine` :keyword:`yield`\s an :class:`IShutdown` `message`,</span>
<span class="sd">        that `message` should be posted to the `post office`, like a normal</span>
<span class="sd">        `message`, to allow the the `message` to cascade to other `coroutines`.</span>
<span class="sd">        Additionally, if the `coroutine` :keyword:`yield`\s an</span>
<span class="sd">        :class:`IShutdown` `message` on it&#39;s ``signal`` `outbox`, it should</span>
<span class="sd">        then be considered in a &quot;shutting down&quot; state.  Finally, if the</span>
<span class="sd">        :keyword:`yield`\ed :class:`IShutdown` cannot be posted to the `post</span>
<span class="sd">        office` (i.e. the `post office` raises an</span>
<span class="sd">        :class:`~m4us.core.exceptions.NoLinkError`), the the message should</span>
<span class="sd">        just be discarded.  This is so that `consumer`/`sink` `coroutines` can</span>
<span class="sd">        also emit :class:`IShutdown` messages to signal that they are shutting</span>
<span class="sd">        down.</span>

<span class="sd">        When in the &quot;shutting down&quot; state, no futher `post office` `messages`</span>
<span class="sd">        should be sent to the `coroutine`.  Instead, an :class:`IShutdown`</span>
<span class="sd">        `message` should be sent to it&#39;s ``control`` `inbox` every time this</span>
<span class="sd">        method is called, until the `coroutine` exits (i.e. raises</span>
<span class="sd">        :exc:`~exceptions.StopIteration`).  This allows `coroutines` to emit</span>
<span class="sd">        additional `messages` before shutting down and ensures that `lazy`</span>
<span class="sd">        `coroutines` always get enough `messages` to be able to shutdown</span>
<span class="sd">        properly.</span>

<span class="sd">        Finally, any `coroutine` that exits (i.e. raises</span>
<span class="sd">        :exc:`~exceptions.StopIteration`) should be removed from any run queues</span>
<span class="sd">        and have its :meth:`~m4us.core.interfaces.ICoroutine.close` method</span>
<span class="sd">        called.  After that no `messages` should ever be sent to it again.</span>

<span class="sd">        :raises m4us.core.exceptions.NeverRunError: If a `coroutine` is `lazy`</span>
<span class="sd">          but the `post office` says it is not configured to receive any</span>
<span class="sd">          `messages` (i.e. raises :exc:`~m4us.core.exceptions.NotASinkError`).</span>
<span class="sd">        :raises m4us.core.exceptions.NoLinkError: If the `post office` raises</span>
<span class="sd">          the exception and the message is not an :class:`IShutdown` `message`.</span>
<span class="sd">          :class:`IShutdown` `messages` are expected to be cascaded (even from</span>
<span class="sd">          `consumers`), so they do not cause the exception to be re-raised.</span>

<span class="sd">        .. note::</span>

<span class="sd">          At least one `coroutine` is expected to be added before calling this</span>
<span class="sd">          method.  It is an error to do otherwise.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :class:`INotLazy` for details about the non-`lazy` `coroutines`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :meth:`IPostOffice.post` for details on the</span>
<span class="sd">          :class:`~m4us.core.exceptions.NoLinkError` exception.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IScheduler.cycle"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler.cycle">[docs]</a>    <span class="k">def</span> <span class="nf">cycle</span><span class="p">():</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Cycle once through the main loop, running all eligible `coroutines`.</span>

<span class="sd">        `Schedulers` represent the main execution loop.  This method triggers</span>
<span class="sd">        a single cycle through that execution loop, calling the :meth:`step`</span>
<span class="sd">        method as many times as is appropriate.  Ideally all registered</span>
<span class="sd">        `coroutines` should have a chance to run.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :meth:`step` method for details on how `coroutines` are run and</span>
<span class="sd">          on the exceptions that this method can raise as a result.</span>

<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="IScheduler.run"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IScheduler.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">cycles</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Start the `scheduler`, running all registered `coroutines`.</span>

<span class="sd">        This is the main execution loop.</span>

<span class="sd">        :param cycles: The number of cycles of the main loop to run through.</span>
<span class="sd">          One cycle is defined as a one call to the :meth:`cycle` method.  If</span>
<span class="sd">          :obj:`None` or not specified, then this method should run until all</span>
<span class="sd">          registered `coroutines` have shutdown (i.e. raised</span>
<span class="sd">          :exc:`~exceptions.StopIteration`).</span>
<span class="sd">        :type cycles: :obj:`int` or :obj:`None`</span>

<span class="sd">        .. note::</span>

<span class="sd">          If *cycles* is specified, it is expected that subsequent calls to</span>
<span class="sd">          this method should continue from where the last call left off.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          The :meth:`cycle` method for details on what a single cycle entails</span>
<span class="sd">          and what exceptions may be raised as a result.</span>

<span class="sd">        &quot;&quot;&quot;</span>


<span class="c">#---  Containers interfaces</span>
</div></div>
<div class="viewcode-block" id="IContainerFactory"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IContainerFactory">[docs]</a><span class="k">class</span> <span class="nc">IContainerFactory</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` for `callables` that return :class:`IContainer` objects.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IContainerFactory.__call__"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IContainerFactory.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c"># pragma: no branch</span>
        <span class="sd">&quot;&quot;&quot;Return the desired container.</span>

<span class="sd">        :param collections.Sequence args: Any positional arguments that the</span>
<span class="sd">          `factory` may accept.</span>
<span class="sd">        :param collections.Mapping kwargs: Any keyword arguments that the</span>
<span class="sd">          `factory` may accept.</span>

<span class="sd">        :returns: The desired container.</span>
<span class="sd">        :rtype: :class:`IContainer`</span>

<span class="sd">        :raises m4us.core.exceptions.InvalidLinkError: If any of the given or</span>
<span class="sd">          calculated `links` are invalid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

</div></div>
<div class="viewcode-block" id="IContainer"><a class="viewcode-back" href="../../../api/core/m4us.core.interfaces.html#m4us.core.interfaces.IContainer">[docs]</a><span class="k">class</span> <span class="nc">IContainer</span><span class="p">(</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;`Interface` that defines a container.</span>

<span class="sd">    Containers are responsible for containing :class:`ICoroutine` objects and</span>
<span class="sd">    the `links` that connect them both to each other and to the container</span>
<span class="sd">    itself, if appropriate.</span>

<span class="sd">    All containers should calculate and provide :attr:`IContainer.coroutines`</span>
<span class="sd">    and :attr:`IContainer.links` attributes before they are used. The contents</span>
<span class="sd">    of :attr:`IContainer.coroutines` should be able to be passed to the</span>
<span class="sd">    appropriate :meth:`IScheduler.register` method and the contents of</span>
<span class="sd">    :attr:`IContainer.links` should be able to be passed to the appropriate</span>
<span class="sd">    :meth:`IPostOffice.register` method.</span>

<span class="sd">    Additionally, containers can contain other :class:`IContainer` objects, in</span>
<span class="sd">    other words other containers.  In such a case,</span>
<span class="sd">    :attr:`IContainer.coroutines` and :attr:`IContainer.links` should include</span>
<span class="sd">    the `coroutines` and `links` from the sub-containers, excluding any</span>
<span class="sd">    duplicates from the other `coroutines` and `links` in the parent container.</span>

<span class="sd">    .. note::</span>

<span class="sd">      Containers will usually provide :class:`ICoroutine` as well, but that is</span>
<span class="sd">      not strictly required by this interface.  The calculation and use of the</span>
<span class="sd">      above-mentioned two attributes makes it not a strict requirement.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coroutines</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;All the contained `coroutines` to be added to the `scheduler`.</span>

<span class="sd">        The `coroutines` of any sub-containers should also be included for</span>
<span class="sd">        convenience.</span>

<span class="sd">        The contained `coroutines` can be added to the `scheduler` with code</span>
<span class="sd">        similar to :samp:`{scheduler}.add(*{container}.coroutines)`.</span>

<span class="sd">        :type: :class:`collections.Sequence`</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :meth:`IScheduler.register` for details about adding `coroutines` to</span>
<span class="sd">          `schedulers`.</span>

<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">links</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;All the `post office` `links` to be added to the `post office`.</span>

<span class="sd">        The `links` of any sub-containers should also be included for</span>
<span class="sd">        convenience.</span>

<span class="sd">        The `links` between the contained `coroutines` can be added to the</span>
<span class="sd">        `post office` with code similar to</span>
<span class="sd">        :samp:`{post_office}.register(*{container}.links)`.</span>

<span class="sd">        :type: :class:`collections.Sequence`</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :meth:`IPostOffice.register` for details about adding `links` to</span>
<span class="sd">          `post offices`.</span>

<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>


<span class="c">#---Module initialization------------------------------------------------------</span>


<span class="c">#---Late Imports---------------------------------------------------------------</span>


<span class="c">#---Late Globals---------------------------------------------------------------</span>


<span class="c">#---Late Functions-------------------------------------------------------------</span>


<span class="c">#---Late Classes---------------------------------------------------------------</span>


<span class="c">#---Late Module initialization-------------------------------------------------</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Message For You Sir! 0.3.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2012, Krys Lawrence.
      Last updated on 2012-02-22.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>