#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, sys
import argparse
import logging

__author__ = "Johannes KÃ¶ster"

# If running from within source directory,
# add '../snakemake' to sys.path.
_libdir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../')
if os.path.isfile(os.path.join(_libdir, 'snakemake', '__init__.py')):
	sys.path.insert(0, _libdir)

import snakemake

def main():
	parser = argparse.ArgumentParser(description="Execute workflow defined in the given snakefile.")
	parser.add_argument("targets", nargs="*", default=None, help="Targets to build. May be rules or files.")
	parser.add_argument("--snakefile", "-s", default="Snakefile", help="The workflow definition in a pythonic DSL.")
	parser.add_argument("--jobs", "-j", action="store", default=1, metavar="N", dest="jobs", type=int, help="Execute at most N jobs in parallel (default: 1).")
	parser.add_argument("--list", "-l", action="store_true", help="Show availiable rules in given snakefile.")
	parser.add_argument("--directory", "-d", action="store", help="Specify working directory (relative paths in the snakefile will use this as their origin).")
	parser.add_argument("--dryrun", "-n", action="store_true", help="Do not execute anything.")
	parser.add_argument("--touch", "-t", action="store_true", help="Touch output files (mark them up to date without really changing them) instead of running their commands. This is used to pretend that the rules were executed, in order to fool future invocations of snakemake. Fails if a file does not yet exist.")
	parser.add_argument("--force", "-f", action="store_true", help="Force the execution of the selected (or the first) rule regardless of already created output.")
	parser.add_argument("--forceall", "-F", action="store_true", help="Force the execution of the selected (or the first) rule and all rules it is dependent on regardless of already created output.")
	parser.add_argument("--cluster", "-c", help="Execute snakemake rules with the given submit command, e.g. qsub. Snakemake compiles jobs into scripts that are submitted to the cluster with the given command, once all input files for a particular job are present.")
	parser.add_argument("--reason", "-r", action = "store_true", help="Print the reason for each executed rule.")
	parser.add_argument("--stats", help="Write stats about Snakefile execution to the given file.")
	parser.add_argument("--nocolor", action = "store_true", help="Do not use a colored output.")
	parser.add_argument("--quiet", action = "store_true", help="Do not output any progress or rule information.")
	parser.add_argument("--version", "-v", action="version", version='0.1')
    
	args = parser.parse_args()

	if not os.path.exists(args.snakefile):
		logging.error("Error: Snakefile \"{}\" not present.".format(args.snakefile))
		exit(1)
    
	exit(
		snakemake.snakemake(
			args.snakefile, 
			list = args.list,
			jobs = args.jobs, 
			directory = args.directory, 
			targets = args.targets, 
			dryrun = args.dryrun, 
			touch = args.touch, 
			forcethis = args.force,
			forceall = args.forceall,
			stats = args.stats,
			give_reason = args.reason,
			nocolor = args.nocolor,
			quiet = args.quiet,
			cluster = args.cluster,
			standalone = True)
	)

if __name__ == "__main__":
	main()
