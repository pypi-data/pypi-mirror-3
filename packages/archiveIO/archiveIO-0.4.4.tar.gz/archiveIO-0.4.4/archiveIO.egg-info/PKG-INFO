Metadata-Version: 1.1
Name: archiveIO
Version: 0.4.4
Summary: Convenience decorators for reading and writing to compressed archives
Home-page: https://github.com/invisibleroads/archiveIO
Author: Roy Hyunjin Han
Author-email: starsareblueandfaraway@gmail.com
License: MIT
Description: archiveIO
        =========
        Here are some decorators for reading and writing to compressed archives.
        
        
        Installation
        ------------
        ::
        
            easy_install -U archiveIO
        
        
        Usage
        -----
        ::
        
            import archiveIO
            import os
            from cStringIO import StringIO
        
            # Define a function that generates archive contents
            @archiveIO.save
            def save(targetPath):
                open(targetPath, 'wt').write('xxx')
            # Define a function that processes archive contents
            @archiveIO.load
            def load(sourcePath):
                return open(sourcePath, 'rt').read()
        
            # Save archives
            save('sample.txt')
            save('sample.txt.zip')
            save('sample.txt.tar.gz')
            save('sample.txt.tar.bz2')
            save('sample.txt.tar')
            # Load archives
            assert 'xxx' == load('sample.txt')
            assert 'xxx' == load('sample.txt.zip')
            assert 'xxx' == load('sample.txt.tar.gz')
            assert 'xxx' == load('sample.txt.tar.bz2')
            assert 'xxx' == load('sample.txt.tar')
        
            # Create an archive containing two files
            @archiveIO.save
            def save(targetPath):
                open(targetPath + '.txt', 'wt')
                open(targetPath + '.csv', 'wt')
            targetPath = 'sample.zip'
            save(targetPath)
            # Target CSV files before TXT files
            @archiveIO.load(extensions=['.csv', '.txt'])
            def load(sourcePath):
                return os.path.basename(sourcePath)
            assert 'sample.csv' == load(targetPath)
        
            # Use MyException instead of IOError
            class MyException(Exception):
                pass
            @archiveIO.load(CustomException=MyException)
            def load(sourcePath):
                return sourcePath
            try:
                load('xxx.tar.gz')
            except MyException, error:
                print error
        
            # Compress directly into a string buffer
            archive = archiveIO.Archive(StringIO(), '.tar.gz')
            archive.save([
                'sample.txt',
                'sample.txt.zip',
            ])
            # Uncompress into a temporary folder
            with archiveIO.TemporaryFolder() as temporaryFolder:
                for filePath in archive.load(temporaryFolder):
                    print filePath
        
        
        0.4.4
        -----
        - Added option to target file extensions for uncompressed files
        
        0.4.3
        -----
        - Added CustomException coverage if opening archive fails
        
        0.4.2
        -----
        - Added CustomException option to load() decorator
        
        0.4.1
        -----
        - Excluded extraneous '.' when saving zip archives
        
        0.4.0
        -----
        - Added support for file-like objects when saving or loading archives
        - Added support for folderPaths when saving archives
        - Increased test coverage to 100%
        
        0.3.0
        -----
        - Added Archive class
        
        0.2.0
        -----
        - Ported code from zip_store
        - Added support for .tar.gz .tar.bz2 .tar
        
Keywords: zip tar.gz tar.bz2 tar
Platform: UNKNOWN
Classifier: Intended Audience :: Developers
Classifier: Programming Language :: Python
Classifier: License :: OSI Approved :: MIT License
