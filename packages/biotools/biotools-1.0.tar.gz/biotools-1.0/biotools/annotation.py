#!/usr/bin/python

def _parseAttrs(attr,token='='):
  '''_parseAttrs(attributestring, keyvalueseparator) /internal/
Creates a dictionary from the atrributes (9th column) of a gff file.
keyvalueseparator defaults to '=', which is the separator used in gff
version 3. This sometimes might need to be changed, for example, when
using the gff files generated by CLC, which use a space as the 
separator instead (gff version 2, maybe).

In other words, attributestring "a=b;c=d;" and keyvalueseparator '='
will yield the dictionary {'a':'b','c':'d'}. The other separator (';')
cannot be changed.

This function is not to be called on its own.'''

  attributes = {}
  attrs = [a.strip() for a in attr.strip().split(';')]
  for attribute in attrs:
    pos = attribute.find(token)
    if pos > -1:
      var,val = attribute[:pos],attribute[pos+1:]
      attributes[var] = attributes.get(var,[]) + [val]
	
  for key in attributes:
    attributes[key] = ','.join(attributes[key])
  return attributes

def _nat(v):
  '''_nat( variable ) /internal/
Used for pretty-printing numbers and strings as JSON.

This function is not to be called on its own.'''

  try:
    return str(int(v))
  except:
    return "'" + v + "'"

class Annotation(object):
  '''class Annotation
An object to help with making GFF and JSON files (for if you ever 
wanted to make a website to serve up the data or something).'''
  unknowns = 0
	
  def __init__(self,ref,src,type,start,end,score,strand,phase,attr,name_token='ID',gff_token='='):
    '''Annotation(reference, source, type, start, end, score,
    strand, phase, attributes, identifier, keyvalueseparator)
Constructs an Annotation object with the necessary values. The parameters
are passed in the same order as the columns from a GFF (version 3) file
and the identifier and keyvalueseparator parameters are the defaults for
a gff version 3 file from phytozome. Just write (e.g.)
Annotation(*line.split('\\t')) #(splitting on tabs),
and the rest of the work will be done for you. If you are using a gff file
generated by CLC, you will want to change the identifier (to what, I don't 
know) and keyvalueseparator to space.

Instantiating an Annotation will generate for it an id of the form
SEQNAME_TYPE[START:END], where SEQNAME is the name of the sequence
(column 1) from the GFF file, and type is like 'gene' or 'CDS'. If
no SEQNAME is provided, then 'X' be used in its place, and if no
identifier can be found in the attributes, the Annotation will 
generate a unique identifier for itself in the form of
unknown #.'''

    start,end = int(start),int(end)
    self.strand = strand
    self.type   = type
    self.source = src
    self.seq    = ref
    self.start  = min(start,end)
    self.end    = max(end,start)
    self.attr   = _parseAttrs(attr,gff_token)
    self.phase  = phase
    self.score  = score
    self.ntoken = name_token
    self.id     = ((self.seq or 'X') + '_' + self.type + "[%d:%d]" % (self.start,self.end))
    try:
      self.name   = self.attr[name_token]
    except:
      Annotation.unknowns += 1
      self.name = "unknown %d" % Annotation.unknowns
    self.parent = None
    self.children = []

  '''Some things that you can do to Annotation objects:
* len(annotation)  => gets the length of the annotation (end-start+1)
* dictionary[annotation] => store annotations as keys of a dictionary or as 
                            elements in a set
* annA == annB     => compare two Annotations, they are the same if they have 
                      the same id.
* print annotation => prints the annotation as a line of a GFF version 3 file.
* annotation.export( file, type = None ) => export the annotation and its
                                            children as a file of the given type.
                                            The function will do its best to
                                            guess what type you mean from the
                                            filename (or supply it yourself,
                                            choose from gff, gff3, or json).
* annotation.rename( newname ) => change the identifier for this annotation to
                                  newname.
'''
		
  def __len__(self):
		return max(self.start,self.end)-min(self.end,self.start)+1
    
  def __hash__(self):
    return self.id.__hash__()
    
  def __eq__(self,other):
    try:
      return self.id == other.id
    except:
      return False

  def __str__(self):
    return '\t'.join((self.seq,self.source, \
      self.type,str(self.start),str(self.end),self.score, \
      self.strand,str(self.phase), \
      ';'.join(k+'='+self.attr[k] for k in self.attr)))
		
  def export(self,file,type=None,**kwargs):
		printfile = ''
		if file != 'string':
			if type != None:
				if file[-len(type)-1:] == '.' + type:
					printfile = file
				else:
					printfile = file + '.' + type
			else:
				pos = file.rfind('.')
				if pos > -1:
					if file[pos:] in ['.gff','.gff3','.json']:
						printfile = file
						type = file[pos+1:]
					else:
						raise TypeError, 'Unable to write file of unknown type (try gff, gff3, or json)'
				else:
					raise TypeError, 'Unable to write file of unknown type (try gff, gff3, or json)'
		
		strg = ''
		if type in ['gff','gff3']:
			if self.name != 'GrandFather':
				strg += '\t'.join((self.seq,self.source, \
					self.type,str(self.start),str(self.end),self.score, \
					self.strand,str(self.phase), \
					';'.join(k+'='+self.attr[k] for k in self.attr)))+'\n'
			for child in self.children:
				strg += child.export('string',type)
				
			if file == 'string':
				return strg
			else:
				fh = open(file,'w')
				fh.write('##gff-version 3\n' + strg)
				fh.close()
		elif type == 'json':
			if self.name != 'GrandFather':
				strg += "id:'" + self.name +            "',type:'" + self.type + \
				        "',start:" + _nat(self.start) + ",end:" + _nat(self.end)
				if self.seq != self.parent.seq:
					strg += ",ref:'" + self.seq + "'"
				if self.source != self.parent.source:
					strg += ",src:'" + self.source + "'"
				if self.strand != self.parent.strand:
					strg += ",strand:'" + self.strand + "'"
				if self.phase != '.':
					strg += ",phase:" + _nat(self.phase)
				if self.score != '.':
					strg += ",score:" + _nat(self.score)
				if self.children:
					strg += ','
					#,
				 	#"'attributes':{" + (',').join("'"+k+"':'" + 
					#self.attr[k] + "'" for k in self.attr ) + "}")) + ','
			if self.children:
				strg += "children:[" + ','.join(child.export('string',type) for child in self.children if child) + "]"
			
			if file == 'string':
				return '{' + strg + '}'
			else:
				fh = open(file,'w')
				fh.write('{' + strg + '}')
				fh.close()
				
  def rename(self,name):
		self.name = name
		self.attr[self.ntoken] = name
		for child in self.children:
			child.attr['Parent'] = name

def AnnotationGenerator(input,name_token='ID',gff_token='='):
  '''AnnotationGenerator( input, identifier, keyvalueseparator )
Builds a heirarchy from the input file, and recursively yields each of the children
from the heirarchy Grandfather.'''

  try:
    for child in input.children:
      for childgen in AnnotationGenerator(child):
        yield childgen
    yield input
  except AttributeError:
    for child in AnnotationGenerator(AnnotationHeirarchy(input,name_token,gff_token),name_token,gff_token):
      yield child

  raise StopIteration

def AnnotationHeirarchy(file,name_token='ID',gff_token='='):
  '''AnnotaitonHeirarchy( file, identifier, keyvalueseparator )
Builds Annotation object for each entry in a gff file, and will build
the parent-child relationship between all Annotations. If an 
Annotation does not have a parent, or the parent cannot be found, it
automatically becomes a child of the GrandFather (root node).

This function returns a single Annotation -- the GrandFather.'''

  fh = open(file,'r')
  sort_key = lambda x: x.start if x.strand == "+" else x.end
	
  GrandFather = Annotation(None,file,'gff',-1,-1,'.','',0,name_token + gff_token + 'GrandFather',name_token,gff_token)
  anns = {}
  for line in fh:
    if line[0] != '#':
      ann = Annotation(*line.strip().split('\t'),name_token=name_token,gff_token=gff_token)
      anns[ann.name] = ann
						
  for ann in anns.values():
    ann.children.sort(key=sort_key)
    if not ann.parent:
      if ann.attr.get('Parent'):
        ann.parent = anns.get(ann.attr['Parent'],GrandFather)
      else:
        ann.parent = GrandFather
      ann.parent.children.append(ann)
	
  GrandFather.children.sort(key=sort_key)
  return GrandFather
	
def AnnotationRename(old,new,heirarchy):
  '''AnnotationRename( old, new, heirarchy )
A wrapper for annotation.rename that will find the node by identifier,
and rename it by searching within the given heirarchy. On success, this
function returns True, otherwise it returns False.'''

  if heirarchy.name == old:
    heirarchy.name = new
    return True
  else:
    for child in AnnotationGenerator(heirarchy):
      if AnnotationRename(old,new,child):
        return True
    return False
			
if __name__ == "__main__":
	import sys
	for child in AnnotationGenerator(sys.argv[1]):
		print child.name
