# configuration file
# note that some words are protected: values, keys
# so dont use them
# other than that, you can set any level of hierarchy in the
# representation
# this next part serves no purpose other than
# to show how different options can be set

# It is a requirement that parameter.names be defined
[parameter]
names=gamma,xlai, xhc,  rpl,  xkab, scen, xkw, xkm,   xleafn, xs1,xs2,xs3,xs4,lad
help_names = "Model parameter names: (%d here) as array " % len($parameter.names)

[general]
# all items in general are available as cmd line options
# and are explicitly put through to the help function if
# there is helper text
# Note that by a strange quirk of the parser
# if you put a comma after the # the subsequent fields are still
# interpreted
# so:
passer = False #,helper "Pass over optimisation (i.e. report and plot the initial values)"
# is interpreted as ['False','helper "Pass over optimisation (i.e. report and plot the initial values)"']
#xx = 22,23
passer = False
help_passer = "Pass over optimisation (i.e. report and plot the initial values)"
datadir = .,~/.eoldas 
help_datadir ="Specify where the data and or conf files are"
log=False
help_log = "switch on logging"

disaster=True
panic.level = True
rule = True
unrule = not $general.rule
x = np.random.rand(len($parameter.names))
npp = import somethingThatDoesntExist
here = os.getcwdu()
nice = os.nice(19)
pid=os.getpid()
grid_limits = [None,None,1]
help_grid_limits = "Set the grid limits (list of the same dimensions as the required solution, specifying min/max/step). If None is used the limits come from the data"
grid = True
help_grid = "Solver for regular samples between limits set by grid_limits"


[general.alert]
# note can use expressions
level=2 * 3
# note can also use variables that have been defined reference by $
something = not $general.panic.level
# but this one is an error becase it refers to something not defined
else = $xxx
# note that we can use e.g lists
other = 1,2,3.
names = eeny,meeny,miney
onames = np.array([$general.alert.names,['moe','joe','rising']]).flatten()
# end of example


[operator]
# declare the operators to be used
# they will be called in this order 
obs.name=EOLDASObservationOperator
model.name=EOLDASModelOperator
prior.name=EOLDASPrior
# you can include information to be passed to the log by setting a .log term
obs.helper="The observation operator"
model.helper="The model operator"
prior.helper="The prior operator"
# the last one defined is used
obs.helper="This is the observation operator"


[operator.obs]
# you can add parts to a value but not under the same section name
helper= $operator.obs.helper + " and this"
brf = []
help_brf = "Specify the name of a BRF data file"

[parameter.assoc_bounds]
gamma = 0.01,None
xlai = 0.01,0.99
xhc = 0.01,10.0
rpl = 0.001,0.10
xkab = 0.1,0.99
scen = 0.0,1.0
xkw = 0.01,0.99
xkm = 0.3,0.9
xleafn = 0.9,2.5
xs1 = 0.0, 4.
xs2 = 0.0, 5.
xs3 = None, None
xs4 = None, None
lad = None, None


[operator.prior]
assoc_names=$parameter.names
#assoc_names=xlai, xhc,  rpl,  xkab, scen, xkw, xkm,   xleafn, xs1,xs2,xs3,xs4,lad

[operator.model]
# parameters specific to the model operator
order=1
assoc_names=$parameter.names
wraparound=periodic
help_wraparound = "Conditions for model: periodic, reflexive or None"
model_sd = 1.0
help_model_sd = "Scalar by which model.sd terms are multiplied"

[operator.obs]
rt_model=rtmodel_ad_trans2
use_median=True
help_use_median = "Flag to state whether full bandpass function should be used or not.\nIf True, then the median wavelength of the bandpass function is used"
assoc_names=xlai, xhc,  rpl,  xkab, scen, xkw, xkm,   xleafn, xs1,xs2,xs3,xs4,lad
spectral_interval = 1
help_spectral_interval = "The spectral inverval of the model operator (nm). Default %f" % $operator.obs.spectral_interval
angle_transform = False
help_angle_transform = "Transform the relative azimuth of the input data by adding 180 degrees. Useful if model and data are not consistently defined."


[operator.obs.brf]
#brf1=brdf_WW_1_A_2.kernelFiltered.dat

[operator.obs.brf_init]
#brfinit=MODIS_WW_1_A_1.params

[general.optimisation]
absTol=0.04
scaleCost=False
iprint=1

#gnc_steps=1

[operator.prior.assoc_mean]
gamma = 1
xlai = 0.989
xhc = 5
rpl = 0.01
xkab = 0.989
scen = 0.001
xkw = 0.989
xkm = 0.989
xleafn = 1.5
xs1 = 1.0
xs2 = 0.001
xs3 = 0
xs4 = 0
lad = 5

[operator.prior.assoc_sd]
gamma = 1e20
xlai = 8
xhc = 8
rpl = 8
xkab = 8
scen = 8
xkw = 8.
xkm = 8
xleafn = 8
xs1 = 8
xs2 = 8.
xs3 = 0
xs4 = 0
lad = 0

[operator.model.assoc_sd]
gamma = 1.0
xlai =   1.0
xkab =   1.0
scen =   1.0
xkw =    1.0
xkm =    1.0
xs1 =    1.0
xs2 =    1.0
xleafn = 1.0
xhc =    1.0
rpl =    1.0


[optimisation.assoc_solve]
gamma = 2
xlai = 1
xkab = 1
scen = 1
xkw = 1
xkm = 1
xleafn = 1
xs1 = 1
xs2 = 1

[optimisation]
help_solve = "Codes associated with solver options for the model parameters.\nAn integer array of the same length as parameter.names"

# now we set up the array information that we will need

#[optimisation]
#solve = assoc_to_flat($parameter.names,$optimisation.solve_for)

#[parameter]
#bounds  = assoc_to_flat($parameter.names,$parameter.pbounds)

#[operator.obs]
#param_exists = assoc_to_flat($parameter.names,$operator.obs.names)

#[operator.prior]
#mean = assoc_to_flat($parameter.names,$operator.prior.data)
#sd = assoc_to_flat($parameter.names,$operator.prior.uncertainty)
#param_exists = assoc_to_flat($parameter.names,$operator.prior.names)

#[operator.model]
#sd = assoc_to_flat($parameter.names,$operator.model.uncertainty)
#param_exists = assoc_to_flat($parameter.names,$operator.model.names)




