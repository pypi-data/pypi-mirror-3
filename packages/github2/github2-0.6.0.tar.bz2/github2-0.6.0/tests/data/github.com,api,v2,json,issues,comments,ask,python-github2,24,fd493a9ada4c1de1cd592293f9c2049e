status: 200
x-ratelimit-remaining: 58
content-location: https://github.com/api/v2/json/issues/comments/ask/python-github2/24
-content-encoding: gzip
connection: keep-alive
content-length: 9146
server: nginx/1.0.4
x-runtime: 29ms
x-ratelimit-limit: 60
etag: "e72eb1f693f00e16b71da10917f2893b"
cache-control: private, max-age=0, must-revalidate
date: Thu, 25 Aug 2011 06:54:09 GMT
content-type: application/json; charset=utf-8

{"comments":[{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/09 22:37:26 -0800","body":"Great addition! Could you please implement the paging stuff for all API routes that support paging? Having paging for route A, but not for route B might be confusing and nobody exactly knows which API routes have been covered already.\r\n\r\nThanks in advance,\r\nVincent\r\n","updated_at":"2010/12/09 22:37:26 -0800","id":601871,"user":"nvie"},{"gravatar_id":"5b3558b0fd5ca9c08d9061a6e51b555a","created_at":"2010/12/09 23:48:23 -0800","body":"Sure, but I have another idea.\r\n\r\nList methods could return not a list but an iterable object just like Django ORM's QuerySet, which supports slicing. And this iterable object will hide internal github's paging implementation from the end user of the python-github2.\r\n\r\nFor example, they could iterate over all commits using:\r\n\r\n    for commit in gh.commits.list('django/django'):\r\n        process(commit)\r\n\r\nAnd github2 will make as many requests to the GitHub as required.\r\n\r\nOr user coul only fetch first 100 commits:\r\n\r\n    for commit in gh.commits.list('django/django')[:100]:\r\n        process(commit)\r\n\r\nAnd github2 will do no more than 3 requests to the GitHub behind the scene?\r\n\r\nI see only one con against this approach. It is backward incompartible with the previous code and to convert old code which uses github2 to work with new library, you have to use limits and perhaps lists:\r\n\r\nIf previously you wrote `commits = hg.commits.list('django/django')` and receive no more than 30 items in the list, then now you will have to write `commits = gh.commits.list('django/django')[:LIMIT]` or, if you really need a list here: `commits = list(gh.commits.list('django/django')[:LIMIT])`.\r\n\r\nI suggest this implementation because without that, many developers who using github2, will have to implement same logic in their own code. For example, here is my curren implementation of the generator:\r\n\r\n    def get_commits(*params):\r\n        \"\"\" Generator which fetches commits from\r\n            given repository until LIMIT\r\n            will be reached.\r\n        \"\"\"\r\n        page = 1 \r\n        limit = config.LIMIT\r\n\r\n        commits = gh.commits.list(page = page, *params)\r\n        while commits:\r\n            for commit in commits:\r\n                yield commit\r\n                limit -= 1\r\n                if limit == 0:\r\n                    raise StopIteration\r\n            page += 1\r\n            commits = gh.commits.list(page = page, *params)\r\n\r\nBy the way, such generator could be generalized to use with any listable github's object if it will support the page argument in it's list method. And this will allow us to keep backward compatibility. But this approach is a compromise :( ","updated_at":"2010/12/09 23:48:23 -0800","id":601937,"user":"svetlyak40wt"},{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/13 01:15:05 -0800","body":"I think the addition of an iterator hiding the details of paging is a great fit for this library. The backward incompatibility is a bit tricky, so I'm not too fond of changing the list method. Instead, we could solve this by providing an `iter()` method instead of `list()`? Then `list()` can keep its current semantics and people can use an iterator in the case they prefer that.\r\n\r\nBy the way: in your code sample you call `gh.commits.list('django/django')[:LIMIT]`, but AFAIK iterators aren't subscriptable. (Subscript semantics on iterators is really hard, since they involve state.) Using islice could do the trick like this, however:\r\n\r\n    islice(gh.commits.list('django/django'), None, LIMIT)\r\n","updated_at":"2010/12/13 01:15:05 -0800","id":607643,"user":"nvie"},{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/13 01:28:05 -0800","body":"We could even let the `iter()` method return the islice'd iterator:\r\n\r\n    def iter(self, start=None, stop=None):\r\n        ...\r\n        return islice(commits, start, stop)\r\n\r\nThat way, you can simply call:\r\n\r\n    # iter over all commits\r\n    for c in gh.commits.iter():\r\n        ...\r\n    \r\n    # iter over a subset\r\n    for c in gh.commits.iter(25, 100):\r\n        ...\r\n","updated_at":"2010/12/13 01:28:05 -0800","id":607666,"user":"nvie"},{"gravatar_id":"5b3558b0fd5ca9c08d9061a6e51b555a","created_at":"2010/12/13 03:37:50 -0800","body":"Of cause, you can't apply [:LIMIT] to an iterator, but you can do this with any _iterable_ object. This will look like this for end user:\r\n\r\n    for c in gh.commits.iter('django/django')[:50]:\r\n        ...\r\n\r\nI'll try to write the implementation within few days, and will send you another pull request.","updated_at":"2010/12/13 03:37:50 -0800","id":607829,"user":"svetlyak40wt"},{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/13 07:27:50 -0800","body":"Yeah, what I meant is that (lazy) iterables are not subscriptable (at least not up until Python 2.6), so the above code yields a syntax error. See this:\r\n\r\n    >>> def count():                                     \r\n    ...     i = 0                                        \r\n    ...     while True:                                  \r\n    ...         yield i                                  \r\n    ...         i += 1                                   \r\n    ...                                                  \r\n    >>> for i in count()[:50]:                           \r\n    ...     print i                                      \r\n    ...                                                  \r\n    Traceback (most recent call last):                   \r\n      File \"<stdin>\", line 1, in <module>                \r\n    TypeError: 'generator' object is unsubscriptable     \r\n    >>>\r\n\r\nHowever, if you wrap it in an islice wrapper, you can subscript these kinds of infinite lists:\r\n\r\n    >>> from itertools import islice\r\n    >>> for i in islice(count(), None, 7):\r\n    ...     print i\r\n    ...\r\n    0\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n\r\nAn alternative is to resolve the iterator's elements, which looses the laziness (and therefore doesn't work with infinite lists).\r\n\r\n    for c in list(gh.commits.iter())[:50]:\r\n        ....\r\n\r\nThis would effectively fetch *ALL* commit objects in GitHub in one big list and then slice the first 50 out of that result.","updated_at":"2010/12/13 07:27:50 -0800","id":608217,"user":"nvie"},{"gravatar_id":"5b3558b0fd5ca9c08d9061a6e51b555a","created_at":"2010/12/13 08:19:17 -0800","body":"Generators like this one are not subscribtable, but this does not mean, that I can't return in immediate object from `iter` method which will support slicing and iteration. Wait for the patch, ok? :)","updated_at":"2010/12/13 08:19:17 -0800","id":608365,"user":"svetlyak40wt"},{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/21 14:21:14 -0800","body":"Hey Alexander, how's your patch progressing?","updated_at":"2010/12/21 14:21:14 -0800","id":628461,"user":"nvie"},{"gravatar_id":"5b3558b0fd5ca9c08d9061a6e51b555a","created_at":"2010/12/21 14:30:26 -0800","body":"Hi. Sorry for delay. It is hard to do this in stable manner, because there is no any documentation from the GitHub and I found no way to tell GitHub the page size.\r\n\r\nBy default, page size is 35 items. I need to know that this value will never changed or (better) to specify it myself. Without this, I can't to implement a reliable slicing.\r\n\r\nIf you want, I could try to implement it and hardcode that page's size is 35 items, but it could be broken someday.","updated_at":"2010/12/21 14:30:26 -0800","id":628486,"user":"svetlyak40wt"},{"gravatar_id":"c5a7f21b46df698f3db31c37ed0cf55a","created_at":"2010/12/22 12:40:18 -0800","body":"You can safely use the static page size, [technoweenie](https://github.com/technoweenie) himself [promised  me](http://twitter.com/technoweenie/status/17676244548059136) it won't change for the v2 API.","updated_at":"2010/12/22 12:40:18 -0800","id":630757,"user":"nvie"},{"gravatar_id":"5b3558b0fd5ca9c08d9061a6e51b555a","created_at":"2011/01/04 16:26:06 -0800","body":"Ok, I wrote this helper, to solve this task: https://github.com/svetlyak40wt/pagerator\r\nIt is generalized and could be used anywhere else, to iterate over any paged results.\r\n\r\nFor our case, gh.commits.iter() method should return be:\r\n\r\n    def iter(self, project, branch=\"master\", file=None):\r\n        return pagerator.IterableQuery(\r\n            lambda page: self.get_values(\r\n                \"list\", project, branch, file,\r\n                filter=\"commits\", datatype=Commit,\r\n                post_data=dict(page=page+1)\r\n            ),  \r\n            35 # page_size hardcoded in the GitHub\r\n        )\r\n\r\nBut I can't test it right now, because I receive \"api route not recognized\" error from the GitHub, even for list method which worked previously. Do you know how to fix it?","updated_at":"2011/01/04 16:26:06 -0800","id":653676,"user":"svetlyak40wt"}]}