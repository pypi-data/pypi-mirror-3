\documentclass[11pt]{paper}
\usepackage{amssymb,latexsym}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{graphicx}
%\textwidth=6.5in
%\textheight=9.5in
\usepackage{color,fancyvrb}
\usepackage{soul,color}
\definecolor{NavyBlue}      {cmyk}{0.94,0.54,0,0}
\setulcolor{NavyBlue}

   
\begin{document}


\setcounter{page}{1}

\title{qmath Quick Card}
\author{Marco Abrate} 
\maketitle
\vskip-0.6cm
\noindent \small{abrate.m@gmail.com}




\tableofcontents

\section{Classes}

\noindent $\textcolor{blue}{\texttt{class quaternion}}(attitude)$

Quaternion class. 

$attitude$ can be:

- Number (of any type, complex are included);

- list or numpy array of the components with respect to \texttt{1,i,j} and \texttt{k}; 

- string of the form \texttt{'a+bi+cj+dk'};

- a rotation about an axis using pairs (rotation angle, axis of rotation);

- list whose components are Euler angles;

- a 3X3 rotation matrix.

\bigskip

\section{Methods}
\noindent $\textcolor{blue}{\texttt{\_\_repr\_\_}}(self)$ 

Quaternions are represented in the algebraic way: $q = a+bi+cj+dk$, and $a,b,c,d$ are floats.

\medskip
 
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{getitem}\_\_}}(self,key)$

Returns one of the four float components of the quaternion. This method allows to get the components by \texttt{quaternion[key]}.

\medskip

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{setitem}\_\_}}(self,key, number)$

Set one of the four float components of the quaternion. This method allows to set the components by \texttt{quaternion[key] = number}.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{delitem}\_\_}}(self,key)$

Delete (set to zero) one of the four float components of the quaternion. This method allows to write \texttt{del quaternion[key]}.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{delslice}\_\_}}(self,key_1,key_2)$

Delete (set to zero) the components of the quaternion from the $key_1-th$ to the $key_2-th$. This method allows to write \texttt{del quaternion[1:3]}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{contains}\_\_}}(self,key)$

Returns $0$ if the component of the quaternion with respect to $key$ is zero, $1$ otherwise. This method allows to write \texttt{del 'k' in quaternion}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{eq}\_\_}}(self,other)$

Returns \texttt{True} if two quaternion are equal, \texttt{False} otherwise. This method allows to write \texttt{quaternion1 == quaternion2}.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{ne}\_\_}}(self,other)$

The opposite of $\_\_$eq$\_\_$. This method allows to write \texttt{quaternion1 != quaternion2}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{iadd}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{isub}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{imul}\_\_}}(self,other)$ 

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{idiv}\_\_}}(self,other)$

These methods are called to implement the augmented arithmetic assignments. These methods should attempt to do the operation in-place (modifying self) and return the result.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{add}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{sub}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{mul}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{div}\_\_}}(self,other)$

These methods are called to implement the binary arithmetic operations. For instance, to evaluate the expression \texttt{x + y}, where \texttt{x} is a quaternion, \texttt{x.\_\_\mbox{add}\_\_(y)} is called. \texttt{y} can either be a quaternion or something that can be converted to quaternion.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{rmul}\_\_}}(self,other)$ 

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{rdiv}\_\_}}(self,other)$

These methods are called to implement the binary arithmetic operations with reflected operands.


\medskip        
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{neg}\_\_}}(self)$

Return the opposite of a quaternion. You can write \texttt{- quaternion}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{pow}\_\_}}(self,exponent)$

Implements the operator \texttt{**}. The power of a quaternion can be computed for integer power (both positive or negative) and also if the exponent is half or third a number: for example square or cube roots are evaluated.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{abs}\_\_}}(self)$ 

Returns the modulus of the quaternion.

\pagebreak

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{equal}\_\_}}(self,other[,tolerance])$ 

Returns quaternion equality with arbitrary tolerance. If no tolerance is admitted it is the same as $\texttt{\_\_\mbox{eq}\_\_}(self,other)$. If $\texttt{tol}$ is the tolerance, this method lets you to write \texttt{quaternion1 == quaternion2|tol}.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{real}}}(self)$ 

Returns the real part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{imag}}}(self)$ 

Returns the imaginary part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{trace}}}(self)$ 

Returns the trace of the quaternion (the double of its real part).

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{conj}}}(self)$ 

Returns the conjugate of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{norm}}}(self)$ 

Returns the norm of the quaternion (the square of the modulus).

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{delta}}}(self)$ 

Returns the $\delta$ of the quaternion, that is the opposite of the norm of the imaginary part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{inverse}}}(self)$ 

Quaternionic inverse, if it exists. It is the same as \texttt{quaternion ** (-1)}.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{unitary}}}(self)$ 

Returns the normalized quaternion, if different from zero.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{sqrt}}}(self)$ 

Computes the square root of the quaternion. If the quaternion has only two roots, the one with positive trace is given: if this method returns r, also -r is a root.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{croot}}}(self)$ 

Computes the cube root (unique) of a quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{QuaternonToRotation}}}(self)$ 

Converts the quaternion, if unitary, into a rotation matrix.

\bigskip

\section{Additional Functions}

\noindent $\textcolor{blue}{\texttt{\mbox{real}}}(object)$ 

The same as $\texttt{\mbox{object.real}}()$.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{imag}}}(object)$ 

The same as $\texttt{\mbox{object.imag}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{trace}}}(object)$ 

The same as $\texttt{\mbox{object.trace}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{conj}}}(object)$ 

The same as $\texttt{\mbox{object.conj}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{norm}}}(object)$ 

The same as $\texttt{\mbox{object.norm}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{delta}}}(object)$ 

The same as $\texttt{\mbox{object.delta}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{inverse}}}(object)$ 

The same as $\texttt{\mbox{object.inverse}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{unitary}}}(object)$ 

The same as $\texttt{\mbox{object.unitary}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{sqrt}}}(object)$ 

The same as $\texttt{\mbox{object.sqrt}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{croot}}}(object)$ 

The same as $\texttt{\mbox{object.croot}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{QuaternonToRotation}}}(object)$ 

The same as $\texttt{\mbox{object.QuaternioinToRotation}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{RotationToQuaternion}}}(angle,vector)$ 

Converts a pair angle-vector into a quaternion.


\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{StringToQuaternion}}}(string)$ 

Converts a string into a quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{MatrixToEuler}}}(matrix)$ 

Converts a 3X3 matrix into a vector having Euler angles as components.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{EulerToQuaternion}}}(list)$ 

Converts a vector whose components are Euler angles into a quaternion.
    

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{identity}}}()$ 

Returns 1 as a quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{identity}}}()$ 

Returns 0 as a quaternion.


\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{dot}}}(object_1,object_2)$ 

Returns the dot product of two quaternions.


\medskip


\noindent $\textcolor{blue}{\texttt{\mbox{CrossRatio}}}(a,b,c,d)$ 

Returns the cross ratio of four quaternions defined by:
$$
{\texttt{\mbox{CrossRatio}}}(a,b,c,d) = (a-c)\cdot(a-d)^{-1}\cdot(b-d)\cdot(b-c)^{-1}.
$$ 
If $a = d$ or $b = c$ returns the string \texttt{\mbox{'Infinity'}}.

\medskip

\pagebreak

\noindent $\textcolor{blue}{\texttt{\mbox{Moebius}}}(z,a,b,c,d)$ 

Returns the Moebius transformation with parameters a,b,c and d:
$$
f(z)=(a\cdot z+b)\cdot(c\cdot z+d)^{-1}. 
$$
If $c \cdot z + d = 0$ returns the string \texttt{\mbox{'Infinity'}}. 

\bigskip



\end{document}