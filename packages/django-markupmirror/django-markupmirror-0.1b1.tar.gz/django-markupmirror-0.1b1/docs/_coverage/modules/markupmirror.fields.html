<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: markupmirror.fields</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="markupmirror.feincms.models.html">markupmirror.feincms.models</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="markupmirror.markup.base.html">markupmirror.markup.base</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">markupmirror.fields</span>:
    100 total statements,
    <span class="warning">51.7% covered</span>
  </h1>
  <p>Generated: Wed 2012-04-11 05:19 CDT</p>
  <p>Source file: /home/buechler/Sites/django-markupmirror/markupmirror/fields.py</p>
  <p>
    Stats:
    <span class="executed">45 executed</span>,
    <span class="missed">42 missed</span>,
    <span class="excluded">13 excluded</span>,
    <span class="ignored">132 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from django.core.exceptions import ImproperlyConfigured</code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.utils.html import escape</code></li>
<li class="excluded"><code>from django.utils.safestring import mark_safe</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from markupmirror import widgets</code></li>
<li class="excluded"><code>from markupmirror.markup.base import markup_pool</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># suffixes for rendered and markup_type fields</code></li>
<li class="executed"><code>_rendered_field_name = lambda name: '%s_rendered' % name</code></li>
<li class="executed"><code>_markup_type_field_name = lambda name: '%s_markup_type' % name</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Markup(object):</code></li>
<li class="ignored"><code>    """Wrapper class for markup content output.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    Stores the names of the associated field, the rendered field and the</code></li>
<li class="ignored"><code>    markup_type field to make assignment possible.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    def __init__(self, instance, field_name,</code></li>
<li class="ignored"><code>                 rendered_field_name, markup_type_field_name):</code></li>
<li class="missed"><code>        self.instance = instance</code></li>
<li class="missed"><code>        self.field_name = field_name</code></li>
<li class="missed"><code>        self.rendered_field_name = rendered_field_name</code></li>
<li class="missed"><code>        self.markup_type_field_name = markup_type_field_name</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def raw(self):</code></li>
<li class="missed"><code>        return self.instance.__dict__[self.field_name]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @raw.setter</code></li>
<li class="ignored"><code>    def raw(self, value):</code></li>
<li class="missed"><code>        return setattr(self.instance, self.field_name, value)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def markup_type(self):</code></li>
<li class="missed"><code>        return self.instance.__dict__[self.markup_type_field_name]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @markup_type.setter</code></li>
<li class="ignored"><code>    def markup_type(self, value):</code></li>
<li class="missed"><code>        return setattr(self.instance, self.markup_type_field_name, value)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @property</code></li>
<li class="ignored"><code>    def rendered(self):</code></li>
<li class="missed"><code>        return getattr(self.instance, self.rendered_field_name)</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        """Allows display via templates to work without safe filter."""</code></li>
<li class="excluded"><code>        return mark_safe(self.rendered)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class MarkupMirrorFieldDescriptor(object):</code></li>
<li class="ignored"><code>    """Descriptor class for field functionality."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def __init__(self, field):</code></li>
<li class="executed"><code>        self.field = field</code></li>
<li class="executed"><code>        self.rendered_field_name = _rendered_field_name(self.field.name)</code></li>
<li class="executed"><code>        self.markup_type_field_name = _markup_type_field_name(self.field.name)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def __get__(self, instance, owner):</code></li>
<li class="missed"><code>        if instance is None:</code></li>
<li class="missed"><code>            raise AttributeError("Can only be accessed via an instance.")</code></li>
<li class="missed"><code>        markup = instance.__dict__[self.field.name]</code></li>
<li class="missed"><code>        if markup is None:</code></li>
<li class="missed"><code>            return None</code></li>
<li class="missed"><code>        return Markup(instance, self.field.name,</code></li>
<li class="ignored"><code>                      self.rendered_field_name, self.markup_type_field_name)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def __set__(self, obj, value):</code></li>
<li class="executed"><code>        if isinstance(value, Markup):</code></li>
<li class="missed"><code>            obj.__dict__[self.field.name] = value.raw</code></li>
<li class="missed"><code>            setattr(obj, self.rendered_field_name, value.rendered)</code></li>
<li class="missed"><code>            setattr(obj, self.markup_type_field_name, value.markup_type)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            obj.__dict__[self.field.name] = value</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class MarkupMirrorField(models.TextField):</code></li>
<li class="ignored"><code>    """Field to store markup content.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    MarkupMirrorField adds three fields to the model it is used in.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    * One field for the raw markup content.</code></li>
<li class="ignored"><code>    * One field for the rendered HTML content.</code></li>
<li class="ignored"><code>    * One field that specifies the markup type.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    def __init__(self, verbose_name=None, name=None,</code></li>
<li class="ignored"><code>                 markup_type=None, default_markup_type=None,</code></li>
<li class="ignored"><code>                 escape_html=False, **kwargs):</code></li>
<li class="executed"><code>        if markup_type and default_markup_type:</code></li>
<li class="missed"><code>            raise ImproperlyConfigured(</code></li>
<li class="ignored"><code>                "Cannot specify both markup_type and default_markup_type")</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self.default_markup_type = markup_type or default_markup_type</code></li>
<li class="executed"><code>        self.markup_type_editable = markup_type is None</code></li>
<li class="executed"><code>        self.escape_html = escape_html</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if (self.default_markup_type and</code></li>
<li class="ignored"><code>            self.default_markup_type not in markup_pool):</code></li>
<li class="missed"><code>            raise ImproperlyConfigured(</code></li>
<li class="ignored"><code>                "Invalid default_markup_type for field '%r', "</code></li>
<li class="ignored"><code>                "available types: %s" % (</code></li>
<li class="ignored"><code>                    name or verbose_name,</code></li>
<li class="ignored"><code>                    ', '.join(sorted(markup_pool.markups.keys()))))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # for South FakeORM compatibility: the frozen version of a</code></li>
<li class="ignored"><code>        # MarkupMirrorField can't try to add a _rendered field, because the</code></li>
<li class="ignored"><code>        # _rendered field itself is frozen as well. See introspection</code></li>
<li class="ignored"><code>        # rules below.</code></li>
<li class="executed"><code>        self.rendered_field = not kwargs.pop('rendered_field', False)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        super(MarkupMirrorField, self).__init__(verbose_name, name, **kwargs)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def contribute_to_class(self, cls, name):</code></li>
<li class="ignored"><code>        """Adds two additional fields for rendered HTML content and markup type</code></li>
<li class="ignored"><code>        to the model.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if not cls._meta.abstract:</code></li>
<li class="ignored"><code>            # markup_type</code></li>
<li class="executed"><code>            choices = [(markup_type, markup.title)</code></li>
<li class="ignored"><code>                for markup_type, markup in markup_pool.markups.items()]</code></li>
<li class="executed"><code>            markup_type_field = models.CharField(</code></li>
<li class="ignored"><code>                choices=choices, max_length=30,</code></li>
<li class="ignored"><code>                default=self.default_markup_type, blank=self.blank,</code></li>
<li class="ignored"><code>                editable=self.markup_type_editable)</code></li>
<li class="executed"><code>            markup_type_field.creation_counter = self.creation_counter + 1</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # rendered</code></li>
<li class="executed"><code>            rendered_field = models.TextField(</code></li>
<li class="ignored"><code>                editable=False, blank=True, null=True)</code></li>
<li class="executed"><code>            rendered_field.creation_counter = self.creation_counter + 2</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # add fields to class</code></li>
<li class="executed"><code>            cls.add_to_class(_markup_type_field_name(name), markup_type_field)</code></li>
<li class="executed"><code>            cls.add_to_class(_rendered_field_name(name), rendered_field)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        super(MarkupMirrorField, self).contribute_to_class(cls, name)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # use MarkupMirrorFieldDescriptor to access this field</code></li>
<li class="executed"><code>        setattr(cls, self.name, MarkupMirrorFieldDescriptor(self))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def pre_save(self, model_instance, add):</code></li>
<li class="missed"><code>        value = super(MarkupMirrorField, self).pre_save(model_instance, add)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # check for valid markup type</code></li>
<li class="missed"><code>        if value.markup_type not in markup_pool:</code></li>
<li class="missed"><code>            raise ValueError(</code></li>
<li class="ignored"><code>                'Invalid markup type (%s), available types: %s' % (</code></li>
<li class="ignored"><code>                    value.markup_type,</code></li>
<li class="ignored"><code>                    ', '.join(sorted(markup_pool.markups.keys()))))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # escape HTML</code></li>
<li class="missed"><code>        if self.escape_html:</code></li>
<li class="missed"><code>            raw = escape(value.raw)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            raw = value.raw</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        rendered = markup_pool[value.markup_type](raw)</code></li>
<li class="missed"><code>        setattr(model_instance, _rendered_field_name(self.attname), rendered)</code></li>
<li class="missed"><code>        return value.raw</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_prep_value(self, value):</code></li>
<li class="missed"><code>        if isinstance(value, Markup):</code></li>
<li class="missed"><code>            return value.raw</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return value</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def value_to_string(self, obj):</code></li>
<li class="missed"><code>        value = self._get_val_from_obj(obj)</code></li>
<li class="missed"><code>        return value.raw</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def formfield(self, **kwargs):</code></li>
<li class="ignored"><code>        """Adds attributes necessary for CodeMirror initialization to the</code></li>
<li class="ignored"><code>        field's widget.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        The class "item-markupmirror" is used to identify textareas that should</code></li>
<li class="ignored"><code>        be enhanced with the editor.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        The ``data-mode`` and ``data-markuptype`` attributes depend on a</code></li>
<li class="ignored"><code>        selected ``default_markup_type``. If a field does not have a default</code></li>
<li class="ignored"><code>        markup type selected, the attributes will be added in the widgets'</code></li>
<li class="ignored"><code>        ``render`` method by accessing the ``markup_type`` property of the</code></li>
<li class="ignored"><code>        markup content wrapper ``markupmirror.fields.Markup``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        widget_attrs = {</code></li>
<li class="ignored"><code>            'class': 'item-markupmirror',</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        if (self.default_markup_type and</code></li>
<li class="ignored"><code>            self.default_markup_type in markup_pool):</code></li>
<li class="missed"><code>            widget_attrs['data-mode'] = markup_pool[</code></li>
<li class="ignored"><code>                self.default_markup_type].codemirror_mode</code></li>
<li class="missed"><code>            widget_attrs['data-markuptype'] = self.default_markup_type</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        defaults = {</code></li>
<li class="ignored"><code>            'widget': widgets.MarkupMirrorTextarea(attrs=widget_attrs),</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        defaults.update(kwargs)</code></li>
<li class="missed"><code>        return super(MarkupMirrorField, self).formfield(**defaults)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>__all__ = ('Markup', 'MarkupMirrorFieldDescriptor', 'MarkupMirrorField')</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># register MarkupMirrorField to use the custom widget in the Admin</code></li>
<li class="excluded"><code>from django.contrib.admin.options import FORMFIELD_FOR_DBFIELD_DEFAULTS</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>FORMFIELD_FOR_DBFIELD_DEFAULTS[MarkupMirrorField] = {</code></li>
<li class="ignored"><code>    'widget': widgets.AdminMarkupMirrorTextareaWidget,</code></li>
<li class="ignored"><code>}</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># allow South to handle MarkupMirrorField smoothly</code></li>
<li class="executed"><code>try:</code></li>
<li class="excluded"><code>    from south.modelsinspector import add_introspection_rules</code></li>
<li class="ignored"><code>    # For a normal MarkupMirrorField, the add_rendered_field attribute is</code></li>
<li class="ignored"><code>    # always True, which means no_rendered_field arg will always be</code></li>
<li class="ignored"><code>    # True in a frozen MarkupMirrorField, which is what we want.</code></li>
<li class="missed"><code>    add_introspection_rules(</code></li>
<li class="ignored"><code>        rules=[</code></li>
<li class="ignored"><code>            ((MarkupMirrorField,), [], {</code></li>
<li class="ignored"><code>                'rendered_field': ['rendered_field', {}],</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code>        ],</code></li>
<li class="ignored"><code>        patterns=['markupmirror\.fields\.MarkupMirrorField'])</code></li>
<li class="excluded"><code>except ImportError:</code></li>
<li class="excluded"><code>    pass</code></li>
  </ol>
</div>

<div class="nav">
  <a href="markupmirror.feincms.models.html">markupmirror.feincms.models</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="markupmirror.markup.base.html">markupmirror.markup.base</a>
</div>

  </body>
</html>

