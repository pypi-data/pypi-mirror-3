#!/usr/bin/python
from biotools.iomanager import IOManager
import __builtin__

def _parseAttrs(attr,token='='):
  '''_parseAttrs(attributestring, keyvalueseparator) /internal/
Creates a dictionary from the atrributes (9th column) of a gff file.
keyvalueseparator defaults to '=', which is the separator used in gff
version 3. This sometimes might need to be changed, for example, when
using the gff files generated by CLC, which use a space as the 
separator instead (gff version 2, maybe).

In other words, attributestring "a=b;c=d;" and keyvalueseparator '='
will yield the dictionary {'a':'b','c':'d'}. The other separator (';')
cannot be changed.

This function is not to be called on its own.'''

  attributes = {}
  attrs = [a.strip() for a in attr.strip().split(';')]
  for attribute in attrs:
    pos = attribute.find(token)
    if pos > -1:
      var,val = attribute[:pos],attribute[pos+1:]
      attributes[var] = attributes.get(var,[]) + [val]
	
  for key in attributes:
    attributes[key] = ','.join(attributes[key])
  return attributes

class Annotation(object):
  '''class Annotation
An object to help with making GFF and JSON files (for if you ever 
wanted to make a website to serve up the data or something).'''
  unknowns = 0
	
  def __init__(self,ref,src,type,start,end,score,strand,phase,attr,name_token='ID',gff_token='='):
    '''Annotation(reference, source, type, start, end, score,
    strand, phase, attributes, identifier, keyvalueseparator)
Constructs an Annotation object with the necessary values. The parameters
are passed in the same order as the columns from a GFF (version 3) file
and the identifier and keyvalueseparator parameters are the defaults for
a gff version 3 file from phytozome. Just write (e.g.)
Annotation(*line.split('\\t')) #(splitting on tabs),
and the rest of the work will be done for you. If you are using a gff file
generated by CLC, you will want to change the identifier (to what, I don't 
know) and keyvalueseparator to space.

Instantiating an Annotation will generate for it an id of the form
SEQNAME_TYPE[START:END], where SEQNAME is the name of the sequence
(column 1) from the GFF file, and type is like 'gene' or 'CDS'. If
no SEQNAME is provided, then 'X' be used in its place, and if no
identifier can be found in the attributes, the Annotation will 
generate a unique identifier for itself in the form of
unknown #.'''

    start,end = int(start),int(end)
    self.strand = strand
    self.type   = type
    self.source = src
    self.seq    = ref
    self.start  = min(start,end)
    self.end    = max(end,start)
    self.attr   = _parseAttrs(attr,gff_token)
    self.phase  = phase
    self.score  = score
    self.ntoken = name_token
    self.id     = ((self.seq or 'X') + '_' + self.type + "[%d:%d]" % (self.start,self.end))
    try:
      self.name   = self.attr[name_token]
    except:
      Annotation.unknowns += 1
      self.name = "unknown %d" % Annotation.unknowns
    self.parent = None
    self.children = []

  '''Some things that you can do to Annotation objects:
* len(annotation)  => gets the length of the annotation (end-start+1)
* dictionary[annotation] => store annotations as keys of a dictionary or as 
                            elements in a set
* annA == annB     => compare two Annotations, they are the same if they have 
                      the same id.
* print annotation => prints the annotation as a line of a GFF version 3 file.
'''
		
  def __len__(self):
		return max(self.start,self.end)-min(self.end,self.start)+1
    
  def __hash__(self):
    return self.id.__hash__()
    
  def __eq__(self,other):
    try:
      return self.id == other.id
    except:
      return False

  def __str__(self):
    return '\t'.join((self.seq,self.source, \
      self.type,str(self.start),str(self.end),self.score, \
      self.strand,str(self.phase), \
      ';'.join(k+'='+self.attr[k] for k in self.attr)))

def _io_methods():
	def read_gff(fh):
		for line in fh:
			if line[0] != '#':
				yield Annotation(*line.split('\t'))
		raise StopIteration

	def write_gff(fh, a):
		fh.write(str(a) + '\n')

	def probe_gff(fh):
		for line in fh:
			line = line.strip()
			if line:
				bits = line.split()
				if bits[0] == '##gff-version':
					return {'anntype': 'gff', 
									'version': float(bits[1])}
				return False
		return False

	nil = lambda x: None

	def whook_gff(fh):
		fh.write('##gff-version 3\n')

	return {
		'gff': {'rhook': nil,       'read': read_gff,
	          'whook': whook_gff, 'write': write_gff,
	                              'probe': probe_gff}
	}

class IOBase(object):
	methods = IOManager(_io_methods())
		
	def __init__(self, name, mode):
		self.handle = __builtin__.open(name, mode)
		self.method = self.methods.default
		self.anntype = None
		self.haswritten = False

		suffixes = {'gff': 'gff', 'gff3':  'gff'}

		p = name.rfind('.')
		if p > -1:
			ext = name[p+1:]
			if ext in suffixes:
				self.seqtype = suffixes[ext]
				self.format(self.seqtype)
				return
		try:
			for method in methods:
				ret = method['probe'](__builtin__.open(name, 'r'))
				if ret:
					for key in ret:
						object.__setitem__(self, key, ret[key])
					break
		except IOError:
			return

	def format(self, fmt):
		if fmt in self.methods:
			self.method = self.methods[fmt]
			self.seqtype = fmt
			return self
		self.method = self.methods.default
		return self

	def write(self, sequence):
		if not self.haswritten:
			self.method['whook'](self.handle)
			self.haswritten = True
		self.method['write'](self.handle, sequence)

	def read(self, count = None):
		if count is None: return [s for s in self]
		return [s for s, i in zip(iter(self), xrange(int(count)))]

	def __iter__(self):
		self.method['rhook'](self.handle)
		return self.method['read'](self.handle)

	def next(self):
		try: return self.read(1)[0]
		except ValueError: raise StopIteration

	def close(self):
		self.handle.close()

class Reader(IOBase):
	def __init__(self, filename, mode='r'):
		IOBase.__init__(self, filename, mode)

	def write(self, *args):
		raise AttributeError, "Annotation reader cannot write."

class Writer(IOBase):
	def __init__(self, filename, mode='w'):
		IOBase.__init__(self, filename, mode)
			
	def read(self, *args):
		raise AttributeError, "Annotation writer cannot read."

def open(name, mode='r'):
	if mode == 'r': return Reader(name, mode)
	if mode == 'w': return Writer(name, mode)
	if mode == 'a': return Writer(name, mode)
