import sys, logging
logging.basicConfig(stream=sys.stdout)
logger = logging.getLogger('pydap')
logger.setLevel(logging.INFO)

import os
from urlparse import urljoin
import time

from webob import Request
from paste.proxy import Proxy
import h5py
from httplib2 import Http

from pydap.client import open_url
from pydap.handlers.lib import SimpleHandler
from pydap.lib import walk, combine_slices, fix_slice, hyperslab
from pydap.model import *
from pydap.proxy import ArrayProxy

# TODO:
# save bounding box in file
# concurrent access
# check Last-modified and expire cache if stale
# check if cache has exceeded its size?
# improve CachingArrayProxy.__getitem__


class DapCache(object):
    def __init__(self, url, responses, cachedir):
        self.url = url
        self.responses = responses
        if not os.path.exists(cachedir):
            os.mkdir(cachedir)
        self.cachedir = cachedir

    def __call__(self, environ, start_response):
        req = Request(environ)
        if '.' in req.path_info:
            basename, response = req.path_info.rsplit('.', 1)
        else:
            basename, response = req.path_info, None

        # cache a local copy
        if response in self.responses:
            url = urljoin(self.url, basename)
            dataset = open_url(url)
            cachepath = os.path.join(self.cachedir, basename.replace('/', '_'))

            # Check Last-modified and compare with file mtime.
            headers, body = Http().request(url, 'HEAD')
            last_modified = time.mktime(time.strptime(headers['last-modified'], '%a, %d %b %Y %H:%M:%S %Z'))
            mtime = os.path.getmtime(cachepath)
            if last_modified > mtime:
                os.unlink(cachepath)

            for var in walk(dataset, BaseType):
                var.data = CachingArrayProxy(
                        cachepath, var.type.typecode,
                        var.id, var.data.url, var.data.shape, var.data._slice)
            app = SimpleHandler(dataset)
        # pass this upstream
        else:
            app = Proxy(self.url)

        return app(environ, start_response)


class CachingArrayProxy(ArrayProxy):
    def __init__(self, cachepath, typecode, id, url, shape, slice_=None):
        super(CachingArrayProxy, self).__init__(id, url, shape, slice_)

        # open cache and create array if necessary
        fp = h5py.File(cachepath, 'a')
        if id not in fp:
            self.cache = fp.create_dataset(id, shape, typecode)
        else:
            self.cache = fp[id]

        self.bbox = [(dim, 0) for dim in shape]

    def __getitem__(self, index):
        slice_ = combine_slices(self._slice, fix_slice(index, self.shape))

        hit = True
        for i in range(len(self.bbox)):
            s = slice_[i]
            if s.start < self.bbox[i][0] or s.stop > self.bbox[i][1]:
                hit = False
                self.bbox[i] = ( min(self.bbox[i][0], s.start), max(self.bbox[i][1], s.stop) )

        if not hit:
            new_cache = tuple(slice(bounds[0], bounds[1], 1) for bounds in self.bbox)
            self.cache[new_cache] = super(CachingArrayProxy, self).__getitem__(new_cache)

        return self.cache[slice_]


        if 0:
            if self.bbox[i] == (None, None):
                start = s.start
                stop = s.stop
                self.bbox[i] = [start, stop]
                self.cache[start:stop] = super(CachingArrayProxy, self).__getitem__( (slice(start, stop, 1),) )
            if s.start < self.bbox[i][0]:
                start = s.start
                stop = self.bbox[i][0]
                self.bbox[i] = [start, self.bbox[i][1]]
                self.cache[start:stop] = super(CachingArrayProxy, self).__getitem__( (slice(start, stop, 1),) )
            if s.stop > self.bbox[i][1]:
                start = self.bbox[i][1]
                stop = s.stop
                self.bbox[i] = [self.bbox[i][0], stop]
                self.cache[start:stop] = super(CachingArrayProxy, self).__getitem__( (slice(start, stop, 1),) )

        return self.cache[slice_]


def make_cache(global_conf, url, responses, **kwargs):
    from paste.deploy.converters import aslist
    responses = aslist(responses)
    return DapCache(url, responses, **kwargs)


if __name__ == '__main__':
    app = DapCache('http://opendap.ccst.inpe.br/', ['dods', 'asc', 'ascii'], '.cache')
    from paste import httpserver
    httpserver.serve(app, '127.0.0.1', port=8003)
