% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{pybdf Documentation}
\date{July 16, 2012}
\release{alpha3}
\author{Samuele Carcagno}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro:welcome-to-pybdf-s-documentation}\label{intro::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Samuele Carcagno

\end{description}\end{quote}

pybdf is a pure python library to read BIOSEMI 24-bit BDF files.
While being slower than alternative C-based libraries like
\emph{BioSig \textless{}http://biosig.sourceforge.net/\textgreater{}}, it is very easy to install
and use.


\chapter{Download and Installation}
\label{intro:download-and-installation}

\section{Download}
\label{intro:download}
The latest release of pybdf can be downloaded from the python package index:

\href{http://pypi.python.org/pypi/pybdf/}{http://pypi.python.org/pypi/pybdf/}

For developers: the source code of pybdf is hosted on
launchpad:

\href{https://launchpad.net/pybdf}{https://launchpad.net/pybdf}


\section{Installation}
\label{intro:installation}

\subsection{Requirements}
\label{intro:requirements}\begin{description}
\item[{To install pybdf you will need:}] \leavevmode\begin{itemize}
\item {} 
python \textgreater{}= 3.2

\item {} 
numpy

\end{itemize}

\end{description}

On all platforms, after having unpacked the archive
you can install pybdf by running:

\begin{Verbatim}[commandchars=\\\{\}]
python setup.py install
\end{Verbatim}

On Windows, you can alternatively use the binary installer, if provided.
Note that pybdf has not been extensively tested on Windows.


\chapter{Usage}
\label{intro:usage}
To open a bdf file you need to create a bdfRecording
object as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{bdf\PYGZus{}rec} \PYG{o}{=} \PYG{n}{bdfRecording}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{res1.bdf}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

you can then query the properties of therecording stored in the BDF header using the
appropriate functions, which are fully described {\hyperref[intro:module-label]{\emph{here}}}.
Some examples are shown below.

Get the duration of the recording:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{recordDuration}
\end{Verbatim}

Get the sampling rate of each channel:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{sampRate}
\end{Verbatim}

Get the channel labels:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{chanLabels}
\end{Verbatim}

There are two functions to read in the data. The first function reads
each channel sequentially:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rec} \PYG{o}{=} \PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

the second function reads the channels in parallel, and is thus faster
on multicore machines:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rec} \PYG{o}{=} \PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{get\PYGZus{}data\PYGZus{}parallel}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

either function returns the same result, that is a python dictionary
with the following fields:
- data : an array of floats with dimenions nChannels X nDataPoints
- trigChan : an array of integers with the triggers in decimal format
- statusChan : an array of integers with the status codes in decimal format
For example, to get the value of the first sample of the recording,
in the first channel, you can type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{data}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

the same sample value, but for the second channel, is stored in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rec}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{data}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

trigChan contains the triggers for the experimental conditions, in decimal
format. The statusChan, on the other hand, contains system codes, like
cm in/out-of range, battery low/OK.

Other usage examples are provided in the `examples' directory inside
the pybdf source archive.

Beware that pybdf does not check that you have sufficeint RAM to
read all the data in a bdf file. If you try to read a file that is
too big for your hardware, you system may become slow or unresponsive.
Initially try reading only a small amount of data, and check how much
RAM that uses. You can read only a portion of the data by passing the
beginning and end arguments to the get\_data() or get\_data\_parallel()
functions. For example, to read the first 10 seconds of the recording, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rec} \PYG{o}{=} \PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{get\PYGZus{}data\PYGZus{}parallel}\PYG{p}{(}\PYG{n}{beginning}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}


\chapter{Bugs}
\label{intro:bugs}
Please, report any bugs on Launchpad \href{https://launchpad.net/pybdf}{https://launchpad.net/pybdf}

Currently there are problems with the get\_data\_parallel() function
on Windows. Please, use the get\_data() function instead, or use Linux.


\chapter{Benchmarks}
\label{intro:benchmarks}
To give you an idea of the speed of pybdf, here are some rough
benchmarks.

Using the get\_data\_parallel() function:

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textbf{
Channels
} & \textbf{
Duration (s)
} & \textbf{
Samp. Rate
} & \textbf{
File (MB)
} & \textbf{
CPU
} & \textbf{
Time (s)
}\\\hline

9
 & 
931
 & 
2048
 & 
49.1
 & 
Intel Core i7-870
 & 
10
\\\hline

9
 & 
1457
 & 
2048
 & 
76.8
 & 
Intel Core i7-870
 & 
15
\\\hline

41
 & 
651
 & 
2048
 & 
156.4
 & 
Intel Core i7-870
 & 
21
\\\hline

9
 & 
931
 & 
2048
 & 
49.1
 & 
Intel Core2 Quad Q6600
 & 
16
\\\hline

9
 & 
1457
 & 
2048
 & 
76.8
 & 
Intel Core2 Quad Q6600
 & 
24
\\\hline

41
 & 
651
 & 
2048
 & 
156.4
 & 
Intel Core2 Quad Q6600
 & 
31
\\\hline
\end{tabulary}



\chapter{\texttt{pybdf} -- Class to read BIOSEMI BDF files}
\label{intro:module-pybdf}\label{intro:module-label}\label{intro:pybdf-class-to-read-biosemi-bdf-files}\index{pybdf (module)}
This module can be used to read the header and data from
24-bit BIOSEMI BDF files recorded with the ActiveTwo system.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{bdf\PYGZus{}rec} \PYG{o}{=} \PYG{n}{bdfRecording}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{res1.bdf}\PYG{l+s}{'}\PYG{p}{)} \PYG{c}{\PYGZsh{}create bdfRecording object}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{recordDuration} \PYG{c}{\PYGZsh{}how many seconds the recording lasts}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{sampRate} \PYG{c}{\PYGZsh{}sampling rate for each channel}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\PYGZsh{}read 10 seconds of data from the first two channels}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rec} \PYG{o}{=} \PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{n}{channels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{beginning}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rec} \PYG{o}{=} \PYG{n}{bdf\PYGZus{}rec}\PYG{o}{.}\PYG{n}{get\PYGZus{}data\PYGZus{}parallel}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{}read all data using multiprocess}
\end{Verbatim}
\end{quote}
\index{bdfRecording (class in pybdf)}

\begin{fulllineitems}
\phantomsection\label{intro:pybdf.bdfRecording}\pysiglinewithargsret{\strong{class }\code{pybdf.}\bfcode{bdfRecording}}{\emph{fileName}}{}
Class for dealing with BIOSEMI 24-bit BDF files.
A bdfRecording object is created with the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{bdf\PYGZus{}rec} \PYG{o}{=} \PYG{n}{bdfRecording}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{bdf\PYGZus{}file.bdf}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

This reads the BDF header, but not the data. You need to use
the get\_data() or get\_data\_parallel() methods to read the data.
The full documentation of the BDF file format can be found here:
\href{http://www.biosemi.com/faq/file\_format.htm}{http://www.biosemi.com/faq/file\_format.htm}
\begin{description}
\item[{idCode}] \leavevmode{[}str{]}
Identification code

\item[{subjId}] \leavevmode{[}str{]}
Local subject identification

\item[{recId}] \leavevmode{[}str{]}
Local recording identification

\item[{startDate}] \leavevmode{[}str{]}
Recording start date

\item[{startTime}] \leavevmode{[}str{]}
Recording start time

\item[{nBytes}] \leavevmode{[}int{]}
Number of bytes occupied by the bdf header

\item[{versionDataFormat}] \leavevmode{[}str{]}
Version of data format

\item[{nDataRecords}] \leavevmode{[}int{]}
Number of data records ``-1'' if unknown

\item[{recordDuration}] \leavevmode{[}float{]}
Duration of a data record, in seconds

\item[{nChannels}] \leavevmode{[}int{]}
Number of channels in data record

\item[{chanLabels}] \leavevmode{[}list of str{]}
Channel labels

\item[{transducer}] \leavevmode{[}list of str{]}
Transducer type

\item[{physDim}] \leavevmode{[}str{]}
Physical dimension of channels

\item[{physMin}] \leavevmode{[}list of int{]}
Physical minimum in units of physical dimension

\item[{physMax}] \leavevmode{[}list of int{]}
Physical maximum in units of physical dimension

\item[{digMin}] \leavevmode{[}list of int{]}
Digital minimum

\item[{digMax}] \leavevmode{[}list of int{]}
Digital maximum

\item[{prefilt}] \leavevmode{[}list of str{]}
Prefiltering

\item[{nSampRec}] \leavevmode{[}list of int{]}
Number of samples in each data record

\item[{reserved}] \leavevmode{[}list of str{]}
Reserved

\item[{scaleFactor}] \leavevmode{[}list of floats{]}
Scaling factor for digital to physical dimension

\item[{sampRate}] \leavevmode{[}list of int{]}
Recording sampling rate

\item[{statusChanIdx}] \leavevmode{[}int{]}
Index of the status channel

\item[{nDataChannels}] \leavevmode{[}int{]}
Number of data channels containing data (rather than trigger codes)

\item[{dataChanLabels}] \leavevmode{[}list of str{]}
Labels of the channels containing data (rather than trigger codes)

\end{description}
\index{get\_data() (pybdf.bdfRecording method)}

\begin{fulllineitems}
\phantomsection\label{intro:pybdf.bdfRecording.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{\emph{beginning=0}, \emph{end=None}, \emph{channels=None}, \emph{trig=True}, \emph{status=True}, \emph{norm\_trig=True}, \emph{norm\_status=True}}{}
Read the data from a bdfRecording object
\begin{description}
\item[{beginning}] \leavevmode{[}int{]}
Start time of data chunk to read (seconds).

\item[{end}] \leavevmode{[}int{]}
End time of data chunk to read (seconds).

\item[{channels}] \leavevmode{[}list of integers or strings{]}
Channels to read. Both channel numbers, or channel names are accepted. Note that channel numbers are indexed starting from \emph{zero}.

\item[{trig}] \leavevmode{[}boolean{]}
If True, return the channel containing the triggers

\item[{status}] \leavevmode{[}boolean{]}
If True, return the channel containing the status codes

\item[{norm\_trig}] \leavevmode{[}boolean{]}
If True, the trigger channel will only signal \emph{changes} between one trigger status to the next. A trigger value that is equal to the previous one will be set to zero

\item[{norm\_status}] \leavevmode{[}boolean{]}
If True, the status channel will only signal \emph{changes} between one status code to the next. A code value that is equal to the previous one will be set to zero

\end{description}
\begin{description}
\item[{rec}] \leavevmode{[}a dictionary with three keys{]}\begin{itemize}
\item {} 
data : an array of floats with dimenions nChannels X nDataPoints

\item {} 
trigChan : an array of integers with the triggers in decimal format

\item {} 
statusChan : an array of integers with the status codes in decimal format

\item {} 
chanLabels : a list containing the labels of the channels that were read,
in the same order they are inserted in the data matrix

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{bdfRecording}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{res1.bdf}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rec} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{n}{channels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{beginning}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_data\_parallel() (pybdf.bdfRecording method)}

\begin{fulllineitems}
\phantomsection\label{intro:pybdf.bdfRecording.get_data_parallel}\pysiglinewithargsret{\bfcode{get\_data\_parallel}}{\emph{beginning=0}, \emph{end=None}, \emph{channels=None}, \emph{trig=True}, \emph{status=True}, \emph{norm\_trig=True}, \emph{norm\_status=True}}{}
Read the data from a bdfRecording object using the multiprocessing
module to exploit multicore machines.
\begin{description}
\item[{beginning}] \leavevmode{[}int{]}
Start time of data chunk to read (seconds).

\item[{end}] \leavevmode{[}int{]}
End time of data chunk to read (seconds).

\item[{channels}] \leavevmode{[}list of integers or strings{]}
Channels to read. Both channel numbers, or channel names are accepted. Note that channel numbers are indexed starting from \emph{zero}.

\item[{trig}] \leavevmode{[}boolean{]}
If True, return the channel containing the triggers

\item[{status}] \leavevmode{[}boolean{]}
If True, return the channel containing the status codes

\item[{norm\_trig}] \leavevmode{[}boolean{]}
If True, the trigger channel will only signal \emph{changes} between one trigger status to the next. A trigger value that is equal to the previous one will be set to zero

\item[{norm\_status}] \leavevmode{[}boolean{]}
If True, the status channel will only signal \emph{changes} between one status code to the next. A code value that is equal to the previous one will be set to zero

\end{description}
\begin{description}
\item[{rec}] \leavevmode{[}a dictionary with three keys{]}\begin{itemize}
\item {} 
data : an array of floats with dimenions nChannels X nDataPoints

\item {} 
trigChan : an array of integers with the triggers in decimal format

\item {} 
statusChan : an array of integers with the status codes in decimal format

\item {} 
chanLabels : a list containing the labels of the channels that were read,
in the same order they are inserted in the data matrix

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{bdfRecording}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{res1.bdf}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rec} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{get\PYGZus{}data\PYGZus{}parallel}\PYG{p}{(}\PYG{n}{channels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{beginning}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pybdf}}, \pageref{intro:module-pybdf}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
