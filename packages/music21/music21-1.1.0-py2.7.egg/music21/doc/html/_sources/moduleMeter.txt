.. _moduleMeter:

music21.meter
=============

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED. Edit the .py file directly

.. module:: music21.meter

This module defines the :class:`~music21.meter.TimeSignature` object,
as well as component objects for defining nested metrical structures,
:class:`~music21.meter.MeterTerminal` and :class:`~music21.meter.MeterSequence` objects.




.. function:: fractionSum(fList)

    Given a list of fractions represented as a list, find the sum



    >>> from music21 import *
    >>> meter.fractionSum([(3,8), (5,8), (1,8)])
    (9, 8)
    >>> meter.fractionSum([(1,6), (2,3)])
    (5, 6)
    >>> meter.fractionSum([(3,4), (1,2)])
    (5, 4)
    >>> meter.fractionSum([(1,13), (2,17)])
    (43, 221)




.. function:: fractionToSlashMixed(fList)

    Given a list of fraction values, compact numerators by sum if
    denominators are the same



    >>> from music21 import *
    >>> meter.fractionToSlashMixed([(3, 8), (2, 8), (5, 8), (3, 4), (2, 16), (1, 16), (4, 16)])
    [('3+2+5', 8), ('3', 4), ('2+1+4', 16)]



.. function:: proportionToFraction(value)

    Given a floating point proportional value between 0 and 1, return the best-fit slash-base fraction



    >>> from music21 import *
    >>> meter.proportionToFraction(.5)
    (1, 2)
    >>> meter.proportionToFraction(.25)
    (1, 4)
    >>> meter.proportionToFraction(.75)
    (3, 4)
    >>> meter.proportionToFraction(.125)
    (1, 8)
    >>> meter.proportionToFraction(.375)
    (3, 8)
    >>> meter.proportionToFraction(.625)
    (5, 8)
    >>> meter.proportionToFraction(.333)
    (1, 3)
    >>> meter.proportionToFraction(0.83333)
    (5, 6)



.. function:: slashCompoundToFraction(value)




    >>> from music21 import *
    >>> meter.slashCompoundToFraction('3/8+2/8')
    [(3, 8), (2, 8)]
    >>> meter.slashCompoundToFraction('5/8')
    [(5, 8)]
    >>> meter.slashCompoundToFraction('5/8+2/4+6/8')
    [(5, 8), (2, 4), (6, 8)]




.. function:: slashMixedToFraction(valueSrc)

    Given a mixture if possible meter fraction representations, return
    a list of pairs. If originally given as a summed numerator; break
    into separate fractions.



    >>> from music21 import *
    >>> meter.slashMixedToFraction('3/8+2/8')
    ([(3, 8), (2, 8)], False)
    ⁠ 
    >>> meter.slashMixedToFraction('3+2/8')
    ([(3, 8), (2, 8)], True)



    >>> meter.slashMixedToFraction('3+2+5/8')
    ([(3, 8), (2, 8), (5, 8)], True)
    ⁠ 
    >>> meter.slashMixedToFraction('3+2+5/8+3/4')
    ([(3, 8), (2, 8), (5, 8), (3, 4)], True)



    >>> meter.slashMixedToFraction('3+2+5/8+3/4+2+1+4/16')
    ([(3, 8), (2, 8), (5, 8), (3, 4), (2, 16), (1, 16), (4, 16)], True)
    ⁠ 
    >>> meter.slashMixedToFraction('3+2+5/8+3/4+2+1+4')
    Traceback (most recent call last):
    ...
    MeterException: cannot match denominator to numerator in: 3+2+5/8+3/4+2+1+4



.. function:: slashToFraction(value)




    >>> from music21 import *
    >>> meter.slashToFraction('3/8')
    (3, 8, None)
    >>> meter.slashToFraction('7/32')
    (7, 32, None)
    >>> meter.slashToFraction('slow 6/8')
    (6, 8, 'slow')



TimeSignature
-------------

Inherits from: :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: TimeSignature(value='4/4', partitionRequest=None)

    The TimeSignature object is multi-faceted representation of nested hierarchical structures.

    For complete details on using this object, see :ref:`overviewMeters`.

    In general, providing a string representation of a meter will get the desired meter, properly configured. For example, we can create a 3/4 TimeSignature, below.



    >>> from music21 import *
    >>> ts = TimeSignature('3/4')
    >>> ts.beatCount
    3
    >>> ts.beatCountName
    'Triple'
    >>> ts.beatDuration.quarterLength
    1.0


    TimeSignature objects are generally positioned in Streams
    at specific positions (offsets), or they can be assigned
    to a special property in Measure that positions the
    TimeSignature at the start of a Measure. Once a Note has
    a local TimeSignature, a Note can get its beat positions
    and other meter-specific parameters.




    >>> m = stream.Measure()
    >>> m.timeSignature = meter.TimeSignature('3/4')
    >>> n = note.EighthNote()
    >>> m.repeatAppend(n, 6)
    >>> [n.beatStr for n in m.notes]
    ['1', '1 1/2', '2', '2 1/2', '3', '3 1/2']
    >>> m.timeSignature = meter.TimeSignature('6/8')
    >>> [n.beatStr for n in m.notes]
    ['1', '1 1/3', '1 2/3', '2', '2 1/3', '2 2/3']


    Numerous attributes of TimeSignature objects
    can be configured, including the multi-level
    partitioning of independent :class:`~music21.meter.MeterSequence`
    objects for beat, beam, accent, and display.
    For complete control, direct configuration of
    :attr:`~music21.meter.TimeSignature.beatSequence`,
    :attr:`~music21.meter.TimeSignature.beamSequence`,
    :attr:`~music21.meter.TimeSignature.accentSequence`,
    and :attr:`~music21.meter.TimeSignature.displaySequence`
    is allowed. Some high-level shortcuts are provided.
    For example, to set a different number of beats,
    the :attr:`~music21.meter.TimeSignature.beatCount`
    property can be set with a new value.




    >>> ts = meter.TimeSignature('6/8')
    >>> ts.beatCount
    2
    >>> ts.beatDuration.quarterLength
    1.5
    >>> ts.beatDivisionCountName
    'Compound'
    >>> ts.beatCount = 6
    >>> ts.beatDuration.quarterLength
    0.5
    >>> ts.beatDivisionCountName
    'Simple'




    >>> tsCommon = meter.TimeSignature('c')  # or common
    >>> tsCommon.beatCount
    4
    >>> tsCommon.denominator
    4
    >>> tsCommon.symbol
    'common'




    >>> tsCut = meter.TimeSignature("cut")
    >>> tsCut.beatCount
    2
    >>> tsCut.denominator
    2
    >>> tsCut.symbol
    'cut'



    **TimeSignature** **attributes**

        .. attribute:: accentSequence

            A :class:`~music21.meter.MeterSequence` governing accent partitioning.


        .. attribute:: displaySequence

            A :class:`~music21.meter.MeterSequence` governing the display of the TimeSignature.


        .. attribute:: beatSequence

            A :class:`~music21.meter.MeterSequence` governing beat partitioning.


        .. attribute:: beamSequence

            A :class:`~music21.meter.MeterSequence` governing automatic beaming.


        Attributes without Documentation: `classSortOrder`, `symbol`, `symbolizeDenominator`, `inherited`, `summedNumerator`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.isStream`, :attr:`~music21.base.Music21Object.isVariant`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.groups`, :attr:`~music21.base.Music21Object.id`

    **TimeSignature** **properties**

        .. attribute:: barDuration

            Return a :class:`~music21.duration.Duration` object equal to the total length of this TimeSignature.



            >>> from music21 import *
            >>> ts = TimeSignature('5/16')
            >>> ts.barDuration
            <music21.duration.Duration 1.25>




        .. attribute:: beatCount

            Return or set the count of beat units, or the number of beats in this TimeSignature.

            When setting beat units, one level of sub-partitions is automatically defined. Users can provide beat count values as integers or as lists of durations. For more precise configuration of the beat MeterSequence, manipulate the .beatSequence attribute directly.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatCount
            3
            >>> ts.beatDuration.quarterLength
            1.0
            >>> ts.beatCount = [1,1,1,1,1,1]
            >>> ts.beatCount
            6
            >>> ts.beatDuration.quarterLength
            0.5



        .. attribute:: beatCountName

            Return the beat count name, or the name given for the number of beat units. For example, 2/4 is duple; 9/4 is triple.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatCountName
            'Triple'
            ⁠ 
            >>> ts = TimeSignature('6/8')
            >>> ts.beatCountName
            'Duple'




        .. attribute:: beatDivisionCount

            Return the count of background beat units found within one beat, or the number of subdivisions in the beat unit in this TimeSignature.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatDivisionCount
            2
            ⁠ 
            >>> ts = TimeSignature('6/8')
            >>> ts.beatDivisionCount
            3



            >>> ts = TimeSignature('15/8')
            >>> ts.beatDivisionCount
            3
            ⁠ 
            >>> ts = TimeSignature('3/8')
            >>> ts.beatDivisionCount
            2



            >>> ts = TimeSignature('13/8', 13)
            >>> ts.beatDivisionCount
            Traceback (most recent call last):
            TimeSignatureException: cannot determine beat backgrond when each beat is not partitioned




        .. attribute:: beatDivisionCountName

            Return the beat count name, or the name given for the number of beat units. For example, 2/4 is duple; 9/4 is triple.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatDivisionCountName
            'Simple'
            ⁠ 
            >>> ts = TimeSignature('6/8')
            >>> ts.beatDivisionCountName
            'Compound'




        .. attribute:: beatDivisionDurations

            Return the beat division, or the durations that make up one beat, as a list of :class:`~music21.duration.Duration` objects, if and only if the TimeSignature has a uniform beat division for all beats.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatDivisionDurations
            [<music21.duration.Duration 0.5>, <music21.duration.Duration 0.5>]
            ⁠ 
            >>> ts = TimeSignature('6/8')
            >>> ts.beatDivisionDurations
            [<music21.duration.Duration 0.5>, <music21.duration.Duration 0.5>, <music21.duration.Duration 0.5>]



        .. attribute:: beatDuration

            Return a :class:`~music21.duration.Duration` object equal to the beat unit of this Time Signature, if and only if this TimeSignatyure has a uniform beat unit.



            >>> from music21 import *
            >>> ts = meter.TimeSignature('3/4')
            >>> ts.beatDuration
            <music21.duration.Duration 1.0>
            >>> ts = meter.TimeSignature('6/8')
            >>> ts.beatDuration
            <music21.duration.Duration 1.5>
            ⁠ 
            >>> ts = meter.TimeSignature('7/8')
            >>> ts.beatDuration
            <music21.duration.Duration 0.5>




        .. attribute:: beatLengthToQuarterLengthRatio




            >>> from music21 import *
            >>> a = TimeSignature('3/2')
            >>> a.beatLengthToQuarterLengthRatio
            2.0



        .. attribute:: beatSubDivisionDurations

            Return a subdivision of the beat division, or a list of :class:`~music21.duration.Duration` objects representing each beat division divided by two.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.beatSubDivisionDurations
            [<music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>]
            ⁠ 
            >>> ts = TimeSignature('6/8')
            >>> ts.beatSubDivisionDurations
            [<music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>, <music21.duration.Duration 0.25>]



        .. attribute:: classification

            Return the classification of this TimeSignature, such as Simple Triple or Compound Quadruple.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.classification
            'Simple Triple'
            >>> ts = TimeSignature('6/8')
            >>> ts.classification
            'Compound Duple'
            >>> ts = TimeSignature('4/32')
            >>> ts.classification
            'Simple Quadruple'



        .. attribute:: denominator


            Return the denominator of the TimeSignature as a number




            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.denominator
            4



        .. attribute:: musicxml

            No documentation.


        .. attribute:: mx

            No documentation.


        .. attribute:: numerator


            Return the numerator of the TimeSignature as a number.
            To set the numerator, change beatCount.



            >>> from music21 import *
            >>> ts = TimeSignature('3/4')
            >>> ts.numerator
            3



        .. attribute:: quarterLengthToBeatLengthRatio

            No documentation.


        .. attribute:: totalLength

            Total length of the TimeSignature, in Quarter Lengths.



            >>> from music21 import *
            >>> ts = TimeSignature('6/8')
            >>> ts.totalLength
            3.0



        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.beat`, :attr:`~music21.base.Music21Object.beatStr`, :attr:`~music21.base.Music21Object.beatStrength`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.duration`, :attr:`~music21.base.Music21Object.isGrace`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`, :attr:`~music21.base.Music21Object.seconds`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **TimeSignature** **methods**

        .. method:: getAccent(qLenPos)

            Return True or False if the qLenPos is at the start of an accent
            division.



            >>> from music21 import *
            >>> a = TimeSignature('3/4', 3)
            >>> a.accentSequence.partition([2,1])
            >>> a.accentSequence
            <MeterSequence {2/4+1/4}>
            >>> a.getAccent(0)
            True
            >>> a.getAccent(1)
            False
            >>> a.getAccent(2)
            True



        .. method:: getAccentWeight(qLenPos, level=0, forcePositionMatch=False, permitMeterModulus=False)

            Given a qLenPos,  return an accent level. In general, accents are assumed to define only a first-level weight.

            If `forcePositionMatch` is True, an accent will only be returned if the provided qLenPos is a near exact match to the provided quarter length. Otherwise, half of the minimum quarter length will be provided.

            If `permitMeterModulus` is True, quarter length positions greater than the duration of the Meter will be accepted as the modulus of the total meter duration.



            >>> from music21 import *
            >>> ts1 = meter.TimeSignature('3/4')
            >>> [ts1.getAccentWeight(x) for x in range(3)]
            [1.0, 0.5, 0.5]



        .. method:: getBeams(srcList, measureStartOffset=0.0)

            Given a qLen position and a list of Duration objects, return a list of Beams object.

            Can alternatively provide a flat stream, from which Durations are extracted.

            Duration objects are assumed to be adjoining; offsets are not used.

            This can be modified to take lists of rests and notes

            Must process a list at  time, because we cannot tell when a beam ends
            unless we see the context of adjoining durations.



            >>> from music21 import *
            >>> a = TimeSignature('2/4', 2)
            >>> a.beamSequence[0] = a.beamSequence[0].subdivide(2)
            >>> a.beamSequence[1] = a.beamSequence[1].subdivide(2)
            >>> a.beamSequence
            <MeterSequence {{1/8+1/8}+{1/8+1/8}}>
            >>> b = [duration.Duration('16th')] * 8
            >>> c = a.getBeams(b)
            >>> len(c) == len(b)
            True
            >>> print(c)
            [<music21.beam.Beams <music21.beam.Beam 1/start>/<music21.beam.Beam 2/start>>, <music21.beam.Beams <music21.beam.Beam 1/continue>/<music21.beam.Beam 2/stop>>, <music21.beam.Beams <music21.beam.Beam 1/continue>/<music21.beam.Beam 2/start>>, <music21.beam.Beams <music21.beam.Beam 1/stop>/<music21.beam.Beam 2/stop>>, <music21.beam.Beams <music21.beam.Beam 1/start>/<music21.beam.Beam 2/start>>, <music21.beam.Beams <music21.beam.Beam 1/continue>/<music21.beam.Beam 2/stop>>, <music21.beam.Beams <music21.beam.Beam 1/continue>/<music21.beam.Beam 2/start>>, <music21.beam.Beams <music21.beam.Beam 1/stop>/<music21.beam.Beam 2/stop>>]
            ⁠ 
            >>> a = TimeSignature('6/8')
            >>> b = [duration.Duration('eighth')] * 6
            >>> c = a.getBeams(b)
            >>> print(c)
            [<music21.beam.Beams <music21.beam.Beam 1/start>>, <music21.beam.Beams <music21.beam.Beam 1/continue>>, <music21.beam.Beams <music21.beam.Beam 1/stop>>, <music21.beam.Beams <music21.beam.Beam 1/start>>, <music21.beam.Beams <music21.beam.Beam 1/continue>>, <music21.beam.Beams <music21.beam.Beam 1/stop>>]




            >>> fourFour = TimeSignature('4/4')
            >>> d = duration.Duration
            >>> dList = [d('eighth'), d('quarter'), d('eighth'), d('eighth'), d('quarter'), d('eighth')]
            >>> beamList = fourFour.getBeams(dList)
            >>> print(beamList)
            [None, None, None, None, None, None]


            Pickup measure support included by taking in an additional measureStartOffset argument.




            >>> threeFour = meter.TimeSignature("3/4")
            >>> dList = [d('eighth'), d('eighth'), d('eighth')]
            >>> beamList = threeFour.getBeams(dList, measureStartOffset=1.5)
            >>> print(beamList)
            [<music21.beam.Beams <music21.beam.Beam 1/start>>, <music21.beam.Beams <music21.beam.Beam 1/continue>>, <music21.beam.Beams <music21.beam.Beam 1/stop>>]



        .. method:: getBeat(qLenPos)

            Given a quarterLength position, get the beat, where beats count from 1



            >>> from music21 import *
            >>> a = TimeSignature('3/4', 3)
            >>> a.getBeat(0)
            1
            >>> a.getBeat(2.5)
            3
            >>> a.beatSequence.partition(['3/8', '3/8'])
            >>> a.getBeat(2.5)
            2



        .. method:: getBeatDepth(qLenPos, align='quantize')

            Return the number of levels of beat partitioning given a QL into the TimeSignature. Note that by default beat partitioning always has a single, top-level partition.

            The `align` parameter is passed to the :meth:`~music21.meter.MeterSequence.positionToDepth` method, and can be used to find depths based on start position overlaps.



            >>> from music21 import *
            >>> a = TimeSignature('3/4', 3)
            >>> a.getBeatDepth(0)
            1
            >>> a.getBeatDepth(1)
            1
            >>> a.getBeatDepth(2)
            1
            ⁠ 
            >>> b = TimeSignature('3/4', 1)
            >>> b.beatSequence[0] = b.beatSequence[0].subdivide(3)
            >>> b.beatSequence[0][0] = b.beatSequence[0][0].subdivide(2)
            >>> b.beatSequence[0][1] = b.beatSequence[0][1].subdivide(2)
            >>> b.beatSequence[0][2] = b.beatSequence[0][2].subdivide(2)
            >>> b.getBeatDepth(0)
            3
            >>> b.getBeatDepth(.5)
            1
            >>> b.getBeatDepth(1)
            2



        .. method:: getBeatDuration(qLenPos)


            Returns a :class:`~music21.duration.Duration`
            object representing the length of the beat
            found at qLenPos.  For most standard
            meters, you can give qLenPos = 0
            and get the length of any beat in
            the TimeSignature; but the simpler
            :attr:`music21.meter.TimeSignature.beatDuration` parameter,
            will do that for you just as well.

            The advantage of this method is that
            it will work for asymmetrical meters, as the second
            example shows.


            Ex. 1: beat duration for 3/4 is always 1.0
            no matter where in the meter you query.



            >>> from music21 import *
            >>> ts1 = meter.TimeSignature('3/4')
            >>> ts1.getBeatDuration(.5)
            <music21.duration.Duration 1.0>
            >>> ts1.getBeatDuration(2.5)
            <music21.duration.Duration 1.0>


            Ex. 2: same for 6/8:




            >>> ts2 = meter.TimeSignature('6/8')
            >>> ts2.getBeatDuration(2.5)
            <music21.duration.Duration 1.5>


            Ex. 3: but for a compound meter of 3/8 + 2/8,
            where you ask for the beat duration
            will determine the length of the beat:




            >>> ts3 = meter.TimeSignature(['3/8','2/8']) # will partition as 2 beat
            >>> ts3.getBeatDuration(.5)
            <music21.duration.Duration 1.5>
            >>> ts3.getBeatDuration(1.5)
            <music21.duration.Duration 1.0>



        .. method:: getBeatOffsets()

            Return offset positions in a list for the start of each beat, assuming this object is found at offset zero.



            >>> from music21 import *
            >>> a = TimeSignature('3/4')
            >>> a.getBeatOffsets()
            [0.0, 1.0, 2.0]
            >>> a = TimeSignature('6/8')
            >>> a.getBeatOffsets()
            [0.0, 1.5]



        .. method:: getBeatProgress(qLenPos)


            Given a quarterLength position, get the beat,
            where beats count from 1, and return the the
            amount of qLen into this beat the supplied qLenPos
            is.




            >>> from music21 import *
            >>> a = meter.TimeSignature('3/4', 3)
            >>> a.getBeatProgress(0)
            (1, 0)
            >>> a.getBeatProgress(0.75)
            (1, 0.75)
            >>> a.getBeatProgress(1.0)
            (2, 0.0)
            >>> a.getBeatProgress(2.5)
            (3, 0.5)


            Works for specifically partitioned meters too:



            >>> a.beatSequence.partition(['3/8', '3/8'])
            >>> a.getBeatProgress(2.5)
            (2, 1.0)



        .. method:: getBeatProportion(qLenPos)

            Given a quarter length position into the meter, return a numerical progress through the beat (where beats count from one) with a floating-point value between 0 and 1 appended to this value that gives the proportional progress into the beat.



            >>> from music21 import *
            >>> ts1 = meter.TimeSignature('3/4')
            >>> ts1.getBeatProportion(0)
            1.0
            >>> ts1.getBeatProportion(0.5)
            1.5
            >>> ts1.getBeatProportion(1)
            2.0
            ⁠ 
            >>> ts3 = meter.TimeSignature(['3/8','2/8']) # will partition as 2 beat
            >>> ts3.getBeatProportion(.75)
            1.5
            >>> ts3.getBeatProportion(2)
            2.5



        .. method:: getBeatProportionStr(qLenPos)

            Return a string presentation of the beat.



            >>> from music21 import *
            >>> ts1 = meter.TimeSignature('3/4')
            >>> ts1.getBeatProportionStr(0)
            '1'
            >>> ts1.getBeatProportionStr(0.5)
            '1 1/2'
            >>> ts1.getBeatProportionStr(1)
            '2'
            >>> ts3 = meter.TimeSignature(['3/8','2/8']) # will partition as 2 beat
            >>> ts3.getBeatProportionStr(.75)
            '1 1/2'
            >>> ts3.getBeatProportionStr(2)
            '2 1/2'
            ⁠ 
            >>> ts4 = meter.TimeSignature(['6/8']) # will partition as 2 beat



        .. method:: getOffsetFromBeat(beat)


            Given a beat value, convert into an offset position.



            >>> from music21 import *
            >>> ts1 = meter.TimeSignature('3/4')
            >>> ts1.getOffsetFromBeat(1)
            0.0
            >>> ts1.getOffsetFromBeat(2)
            1.0
            >>> ts1.getOffsetFromBeat(3)
            2.0
            >>> ts1.getOffsetFromBeat(3.5)
            2.5
            >>> ts1.getOffsetFromBeat(3.25)
            2.25
            ⁠ 
            >>> ts1 = meter.TimeSignature('6/8')
            >>> ts1.getOffsetFromBeat(1)
            0.0
            >>> ts1.getOffsetFromBeat(2)
            1.5
            >>> ts1.getOffsetFromBeat(2.33)
            2.0
            >>> ts1.getOffsetFromBeat(2.5) # will be + .5 * 1.5
            2.25
            >>> ts1.getOffsetFromBeat(2.66)
            2.5


            Works for asymmetrical meters as well:




            >>> ts3 = meter.TimeSignature(['3/8','2/8']) # will partition as 2 beat
            >>> ts3.getOffsetFromBeat(1)
            0.0
            >>> ts3.getOffsetFromBeat(2)
            1.5
            >>> ts3.getOffsetFromBeat(1.66)
            1.0
            >>> ts3.getOffsetFromBeat(2.5)
            2.0





        .. method:: load(value, partitionRequest=None)

            Loading a meter destroys all internal representations



        .. method:: loadRatio(numerator, denominator, partitionRequest=None)

            Convenience method



        .. method:: quarterPositionToBeat(currentQtrPosition=0)

            For backward compatibility. Ultimately, remove.



        .. method:: ratioEqual(other)

            A basic form of comparison; does not determine if any internatl structures are equal; only outermost ratio.



        .. method:: setAccentWeight(weightList, level=0)

            Set accent weight, or floating point scalars, for the accent MeterSequence. Provide a list of values; if this list is shorter than the length of the MeterSequence, it will be looped; if this list is longer, only the first relevant value will be used.

            If the accent MeterSequence is subdivided, the level of depth to set is given by the optional level argument.



            >>> from music21 import *
            >>> a = TimeSignature('4/4', 4)
            >>> len(a.accentSequence)
            4
            >>> a.setAccentWeight([.8, .2])
            >>> a.getAccentWeight(0)
            0.8...
            >>> a.getAccentWeight(.5)
            0.8...
            >>> a.getAccentWeight(1)
            0.2...
            >>> a.getAccentWeight(2.5)
            0.8...
            >>> a.getAccentWeight(3.5)
            0.2...



        .. method:: setDisplay(value, partitionRequest=None)

            Set an indendent display value



            >>> from music21 import *
            >>> a = TimeSignature()
            >>> a.load('3/4')
            >>> a.setDisplay('2/8+2/8+2/8')
            >>> a.displaySequence
            <MeterSequence {2/8+2/8+2/8}>
            >>> a.beamSequence
            <MeterSequence {{1/8+1/8}+{1/8+1/8}+{1/8+1/8}}>
            >>> a.beatSequence # a single top-level partition is default for beat
            <MeterSequence {{1/8+1/8}+{1/8+1/8}+{1/8+1/8}}>
            >>> a.setDisplay('3/4')
            >>> a.displaySequence
            <MeterSequence {3/4}>



        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSite`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.hasVariantSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.purgeOrphans`, :meth:`~music21.base.Music21Object.purgeUndeclaredIds`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


CompoundTimeSignature
---------------------

Inherits from: :class:`~music21.meter.TimeSignature`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: CompoundTimeSignature(value='4/4', partitionRequest=None)



DurationDenominatorTimeSignature
--------------------------------

Inherits from: :class:`~music21.meter.TimeSignature`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: DurationDenominatorTimeSignature(value='4/4', partitionRequest=None)

    If you have played Hindemith you know these, 3/(dot-quarter) etc.



MeterSequence
-------------

Inherits from: :class:`~music21.meter.MeterTerminal`

.. class:: MeterSequence(value=None, partitionRequest=None)

    A meter sequence is a list of MeterTerminals, or other MeterSequences



    **MeterSequence** **attributes**

        Attributes without Documentation: `parenthesis`, `summedNumerator`

    **MeterSequence** **properties**

        .. attribute:: denominator

            No documentation.


        .. attribute:: depth

            Return how many unique levels deep this part is

            This should be optimized to store values unless the structure has changed.



        .. attribute:: flat

            Retrun a new MeterSequence composed of the flattend representation.



            >>> from music21 import *
            >>> a = meter.MeterSequence('3/4', 3)
            >>> b = a.flat
            >>> len(b)
            3
            ⁠ 
            >>> a[1] = a[1].subdivide(4)
            >>> b = a.flat
            >>> len(b)
            6



            >>> a[1][2] = a[1][2].subdivide(4)
            >>> a
            <MeterSequence {1/4+{1/16+1/16+{1/64+1/64+1/64+1/64}+1/16}+1/4}>
            >>> b = a.flat
            >>> len(b)
            9




        .. attribute:: flatWeight

            Retrun a list of flat weight valuess




        .. attribute:: numerator

            No documentation.


        .. attribute:: partitionStr

            Return the number of top-level partitions in this MeterSequence as a string.



            >>> from music21 import *
            >>> ms = meter.MeterSequence('2/4+2/4')
            >>> ms
            <MeterSequence {2/4+2/4}>
            >>> ms.partitionStr
            'Duple'
            >>> ms = meter.MeterSequence('6/4', 6)
            >>> ms
            <MeterSequence {1/4+1/4+1/4+1/4+1/4+1/4}>
            >>> ms.partitionStr
            'Sextuple'



        .. attribute:: weight




            >>> from music21 import *
            >>> a = meter.MeterSequence('3/4')
            >>> a.partition(3)
            >>> a.weight = 1
            >>> a[0].weight
            0.333...
            >>> b = meter.MeterTerminal('1/4', .25)
            >>> c = meter.MeterTerminal('1/4', .25)
            >>> d = meter.MeterSequence([b, c])
            >>> d.weight
            0.5



        Properties inherited from :class:`~music21.meter.MeterTerminal`: :attr:`~music21.meter.MeterTerminal.duration`

    **MeterSequence** **methods**

        .. method:: getLevel(level=0, flat=True)

            Return a complete MeterSequence with the same numerator/denominator
            reationship but that represents any partitions found at the rquested
            level. A sort of flatness with variable depth.



            >>> from music21 import *
            >>> b = meter.MeterSequence('4/4', 4)
            >>> b[1] = b[1].subdivide(2)
            >>> b[3] = b[3].subdivide(2)
            >>> b[3][0] = b[3][0].subdivide(2)
            >>> b
            <MeterSequence {1/4+{1/8+1/8}+1/4+{{1/16+1/16}+1/8}}>
            >>> b.getLevel(0)
            <MeterSequence {1/4+1/4+1/4+1/4}>
            >>> b.getLevel(1)
            <MeterSequence {1/4+1/8+1/8+1/4+1/8+1/8}>
            >>> b.getLevel(2)
            <MeterSequence {1/4+1/8+1/8+1/4+1/16+1/16+1/8}>



        .. method:: getLevelSpan(level=0)

            For a given level, return the time span of each terminal or sequnece



            >>> from music21 import *
            >>> b = meter.MeterSequence('4/4', 4)
            >>> b[1] = b[1].subdivide(2)
            >>> b[3] = b[3].subdivide(2)
            >>> b[3][0] = b[3][0].subdivide(2)
            >>> b
            <MeterSequence {1/4+{1/8+1/8}+1/4+{{1/16+1/16}+1/8}}>
            >>> b.getLevelSpan(0)
            [(0.0, 1.0), (1.0, 2.0), (2.0, 3.0), (3.0, 4.0)]
            >>> b.getLevelSpan(1)
            [(0.0, 1.0), (1.0, 1.5), (1.5, 2.0), (2.0, 3.0), (3.0, 3.5), (3.5, 4.0)]
            >>> b.getLevelSpan(2)
            [(0.0, 1.0), (1.0, 1.5), (1.5, 2.0), (2.0, 3.0), (3.0, 3.25), (3.25, 3.5), (3.5, 4.0)]



        .. method:: getLevelWeight(level=0)

            The weightList is an array of weights found in the components.
            The MeterSequence has a ._weight attribute, but it is not used here



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4', 4)
            >>> a.getLevelWeight()
            [0.25, 0.25, 0.25, 0.25]
            ⁠ 
            >>> b = meter.MeterSequence('4/4', 4)
            >>> b.getLevelWeight(0)
            [0.25, 0.25, 0.25, 0.25]



            >>> b[1] = b[1].subdivide(2)
            >>> b[3] = b[3].subdivide(2)
            >>> b.getLevelWeight(0)
            [0.25, 0.25, 0.25, 0.25]
            ⁠ 
            >>> b[3][0] = b[3][0].subdivide(2)
            >>> b
            <MeterSequence {1/4+{1/8+1/8}+1/4+{{1/16+1/16}+1/8}}>
            >>> b.getLevelWeight(0)
            [0.25, 0.25, 0.25, 0.25]
            >>> b.getLevelWeight(1)
            [0.25, 0.125, 0.125, 0.25, 0.125, 0.125]
            >>> b.getLevelWeight(2)
            [0.25, 0.125, 0.125, 0.25, 0.0625, 0.0625, 0.125]



        .. method:: isUniformPartition(depth=0)

            Return True if the top-level partitions have equal durations



            >>> from music21 import *
            >>> ms = meter.MeterSequence('3/8+2/8+3/4')
            >>> ms.isUniformPartition()
            False
            >>> ms = meter.MeterSequence('4/4')
            >>> ms.isUniformPartition()
            True
            >>> ms = meter.MeterSequence('2/4+2/4')
            >>> ms.isUniformPartition()
            True



        .. method:: load(value, partitionRequest=None, autoWeight=False, targetWeight=None)

            This method is called when a MeterSequence is created, or if a MeterSequence is re-set.

            User can enter a list of values or an abbreviated slash notation.

            autoWeight, if True, will attempt to set weights.
            tragetWeight, if given, will be used instead of self.weight



            >>> from music21 import *
            >>> a = meter.MeterSequence()
            >>> a.load('4/4', 4)
            >>> str(a)
            '{1/4+1/4+1/4+1/4}'
            ⁠ 
            >>> a.load('4/4', 2) # request 2 beats
            >>> str(a)
            '{1/2+1/2}'



            >>> a.load('5/8', 2) # request 2 beats
            >>> str(a)
            '{2/8+3/8}'
            ⁠ 
            >>> a.load('5/8+4/4')
            >>> str(a)
            '{5/8+4/4}'




        .. method:: partition(value)

            Partitioning creates and sets a number of MeterTerminals that make up this MeterSequence.

                   A simple way to partition based on argument time. Single integers are treated as beat counts; lists are treated as numerator lists; MeterSequence objects are call partitionByOther().

                   >>> from music21 import *
                   >>> a = meter.MeterSequence('5/4+3/8')
                   >>> len(a)
                   2
                   >>> b = meter.MeterSequence('13/8')
                   >>> len(b)
                   1
                   >>> b.partition(13)
                   >>> len(b)
                   13
                   >>> a.partition(b)
                   >>> len(a)
                   13



        .. method:: partitionByCount(countRequest, loadDefault=True)

            This will destroy any structure in the _partition



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4')
            >>> a.partitionByCount(2)
            >>> str(a)
            '{1/2+1/2}'
            >>> a.partitionByCount(4)
            >>> str(a)
            '{1/4+1/4+1/4+1/4}'



        .. method:: partitionByList(numeratorList)

            Given a numerator list, partition MeterSequence inot a new list
            of MeterTerminals



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4')
            >>> a.partitionByList([1,1,1,1])
            >>> str(a)
            '{1/4+1/4+1/4+1/4}'
            >>> a.partitionByList(['3/4', '1/8', '1/8'])
            >>> a
            <MeterSequence {3/4+1/8+1/8}>
            >>> a.partitionByList(['3/4', '1/8', '5/8'])
            Traceback (most recent call last):
            MeterException: Cannot set partition by ['3/4', '1/8', '5/8']




        .. method:: partitionByOther(other)

            Set partition to that found in another object



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4', 4)
            >>> b = meter.MeterSequence('4/4', 2)
            >>> a.partitionByOther(b)
            >>> len(a)
            2



        .. method:: positionToAddress(qLenPos, includeCoincidentBoundaries=False)

            Give a list of values that show all indices necessary to access
            the exact terminal at a given qLenPos.

            The len of the returned list also provides the depth at the specified qLen.



            >>> from music21 import *
            >>> a = meter.MeterSequence('3/4', 3)
            >>> a[1] = a[1].subdivide(4)
            >>> a
            <MeterSequence {1/4+{1/16+1/16+1/16+1/16}+1/4}>
            >>> len(a)
            3
            >>> a.positionToAddress(.5)
            [0]
            >>> a[0]
            <MeterTerminal 1/4>
            >>> a.positionToAddress(1.0)
            [1, 0]
            >>> a.positionToAddress(1.5)
            [1, 2]
            >>> a[1][2]
            <MeterTerminal 1/16>
            >>> a.positionToAddress(1.99)
            [1, 3]
            >>> a.positionToAddress(2.5)
            [2]




        .. method:: positionToDepth(qLenPos, align='quantize')

            Given a qLenPos, return the maximum available depth at this position



            >>> from music21 import *
            >>> b = meter.MeterSequence('4/4', 4)
            >>> b[1] = b[1].subdivide(2)
            >>> b[3] = b[3].subdivide(2)
            >>> b[3][0] = b[3][0].subdivide(2)
            >>> b
            <MeterSequence {1/4+{1/8+1/8}+1/4+{{1/16+1/16}+1/8}}>
            >>> b.positionToDepth(0)
            3
            >>> b.positionToDepth(0.25) # quantizing active by default
            3
            >>> b.positionToDepth(1)
            3
            >>> b.positionToDepth(1.5)
            2



        .. method:: positionToIndex(qLenPos, includeCoincidentBoundaries=False)

            Given a qLen pos (0 through self.duration.quarterLength), return
            the index of the active MeterTerminal or MeterSequence



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4')
            >>> a.positionToIndex(5)
            Traceback (most recent call last):
            ...
            MeterException: cannot access from qLenPos 5 where total duration is 4.0
            ⁠ 
            >>> a = MeterSequence('4/4')
            >>> a.positionToIndex(.5)
            0
            >>> a.positionToIndex(3.5)
            0
            >>> a.partition(4)
            >>> a.positionToIndex(0.5)
            0
            >>> a.positionToIndex(3.5)
            3
            >>> a.partition([1,2,1])
            >>> len(a)
            3
            >>> a.positionToIndex(2.9)
            1



        .. method:: positionToSpan(qLenPos, permitMeterModulus=False)

            Given a lenPos, return the span of the active region.
            Only applies to the top most level of partitions

            If `permitMeterModulus` is True, quarter length positions greater than the duration of the Meter will be accepted as the modulus of the total meter duration.



            >>> from music21 import *
            >>> a = meter.MeterSequence('3/4', 3)
            >>> a.positionToSpan(.5)
            (0, 1.0)
            >>> a.positionToSpan(1.5)
            (1.0, 2.0)
            >>> a.positionToSpan(4.5, permitMeterModulus=True)
            (1.0, 2.0)




        .. method:: positionToWeight(qLenPos)

            Given a lenPos, return the weight of the active region.
            Only applies to the top-most level of partitions



            >>> from music21 import *
            >>> a = meter.MeterSequence('3/4', 3)
            >>> a.positionToSpan(.5)
            (0, 1.0)
            >>> a.positionToSpan(1.5)
            (1.0, 2.0)




        .. method:: setLevelWeight(weightList, level=0)

            The `weightList` is an array of weights to be applied to a single level of the MeterSequence.



            >>> from music21 import *
            >>> a = meter.MeterSequence('4/4', 4)
            >>> a.setLevelWeight([1, 2, 3, 4])
            >>> a.getLevelWeight()
            [1, 2, 3, 4]
            ⁠ 
            >>> b = meter.MeterSequence('4/4', 4)
            >>> b.setLevelWeight([2, 3])
            >>> b.getLevelWeight(0)
            [2, 3, 2, 3]



            >>> b[1] = b[1].subdivide(2)
            >>> b[3] = b[3].subdivide(2)
            >>> b.getLevelWeight(0)
            [2, 3.0, 2, 3.0]
            ⁠ 
            >>> b[3][0] = b[3][0].subdivide(2)
            >>> b
            <MeterSequence {1/4+{1/8+1/8}+1/4+{{1/16+1/16}+1/8}}>
            >>> b.getLevelWeight(0)
            [2, 3.0, 2, 3.0]
            >>> b.getLevelWeight(1)
            [2, 1.5, 1.5, 2, 1.5, 1.5]
            >>> b.getLevelWeight(2)
            [2, 1.5, 1.5, 2, 0.75, 0.75, 1.5]



        .. method:: subdivideNestedHierarchy(depth, firstPartitionForm=None, normalizeDenominators=True)

            Create nested structure down to a specified depth; the first division is set to one; the second division may be by 2 or 3; remaining divisions are always by 2.

            This a destructive procedure that will remove any existing partition structures.

            `normalizeDenominators`, if True, will reduce all denominators to the same minimum level.



            >>> from music21 import *
            >>> ms = meter.MeterSequence('4/4')
            >>> ms.subdivideNestedHierarchy(1)
            >>> ms
            <MeterSequence {{1/2+1/2}}>
            >>> ms.subdivideNestedHierarchy(2)
            >>> ms
            <MeterSequence {{{1/4+1/4}+{1/4+1/4}}}>
            >>> ms.subdivideNestedHierarchy(3)
            >>> ms
            <MeterSequence {{{{1/8+1/8}+{1/8+1/8}}+{{1/8+1/8}+{1/8+1/8}}}}>
            >>> ms.subdivideNestedHierarchy(4)
            >>> ms
            <MeterSequence {{{{{1/16+1/16}+{1/16+1/16}}+{{1/16+1/16}+{1/16+1/16}}}+{{{1/16+1/16}+{1/16+1/16}}+{{1/16+1/16}+{1/16+1/16}}}}}>
            >>> ms.subdivideNestedHierarchy(5)
            >>> ms
            <MeterSequence {{{{{{1/32+1/32}+{1/32+1/32}}+{{1/32+1/32}+{1/32+1/32}}}+{{{1/32+1/32}+{1/32+1/32}}+{{1/32+1/32}+{1/32+1/32}}}}+{{{{1/32+1/32}+{1/32+1/32}}+{{1/32+1/32}+{1/32+1/32}}}+{{{1/32+1/32}+{1/32+1/32}}+{{1/32+1/32}+{1/32+1/32}}}}}}>




        .. method:: subdividePartitionsEqual(divisions=None)

            Subdivide all partitions by equally-spaced divisions, given a divisions value. Manipulates this MeterSequence in place.

            Divisions value may optionally be a MeterSequence, from which a top-level partitioning structure is derived.



            >>> from music21 import *
            >>> ms = meter.MeterSequence('2/4')
            >>> ms.partition(2)
            >>> ms
            <MeterSequence {1/4+1/4}>
            >>> ms.subdividePartitionsEqual(2)
            >>> ms
            <MeterSequence {{1/8+1/8}+{1/8+1/8}}>
            >>> ms[0].subdividePartitionsEqual(2)
            >>> ms
            <MeterSequence {{{1/16+1/16}+{1/16+1/16}}+{1/8+1/8}}>
            >>> ms[1].subdividePartitionsEqual(2)
            >>> ms
            <MeterSequence {{{1/16+1/16}+{1/16+1/16}}+{{1/16+1/16}+{1/16+1/16}}}>
            ⁠ 
            >>> ms = meter.MeterSequence('2/4+3/4')
            >>> ms.subdividePartitionsEqual(None)




        Methods inherited from :class:`~music21.meter.MeterTerminal`: :meth:`~music21.meter.MeterTerminal.ratioEqual`, :meth:`~music21.meter.MeterTerminal.subdivide`, :meth:`~music21.meter.MeterTerminal.subdivideByCount`, :meth:`~music21.meter.MeterTerminal.subdivideByList`, :meth:`~music21.meter.MeterTerminal.subdivideByOther`


MeterTerminal
-------------



.. class:: MeterTerminal(slashNotation=None, weight=1)

    A MeterTerminal is a nestable primitive of rhythmic division



    >>> from music21 import *
    >>> a = meter.MeterTerminal('2/4')
    >>> a.duration.quarterLength
    2.0
    >>> a = meter.MeterTerminal('3/8')
    >>> a.duration.quarterLength
    1.5
    >>> a = meter.MeterTerminal('5/2')
    >>> a.duration.quarterLength
    10.0




    **MeterTerminal** **properties**

        .. attribute:: denominator

            No documentation.


        .. attribute:: depth

            Return how many levels deep this part is. Depth of a terminal is always 1



        .. attribute:: duration


            duration gets or sets a duration value that
            is equal in length to the totalLength



            >>> from music21 import *
            >>> a = meter.MeterTerminal()
            >>> a.numerator = 3
            >>> a.denominator = 8
            >>> d = a.duration
            >>> d.type
            'quarter'
            >>> d.dots
            1
            >>> d.quarterLength
            1.5



        .. attribute:: numerator

            No documentation.


        .. attribute:: weight

            No documentation.


    **MeterTerminal** **methods**

        .. method:: ratioEqual(other)

            Compare the numerator and denominator of another object.
            Note that these have to be exact matches; 3/4 is not the same as 6/8



            >>> from music21 import meter
            >>> a = meter.MeterTerminal('3/4')
            >>> b = meter.MeterTerminal('6/4')
            >>> c = meter.MeterTerminal('2/4')
            >>> d = meter.MeterTerminal('3/4')
            >>> a.ratioEqual(b)
            False
            >>> a.ratioEqual(c)
            False
            >>> a.ratioEqual(d)
            True



        .. method:: subdivide(value)

            Subdivision takes a MeterTerminal and, making it into a a collection of MeterTerminals, Returns a MeterSequence.

            This is different than a partitioning a MeterSequence in that this does not happen in place and instead returns a new object.

            If an integer is provided, assume it is a partition count



        .. method:: subdivideByCount(countRequest=None)

            retrun a MeterSequence



            >>> from music21 import *
            >>> a = meter.MeterTerminal('3/4')
            >>> b = a.subdivideByCount(3)
            >>> isinstance(b, meter.MeterSequence)
            True
            >>> len(b)
            3



        .. method:: subdivideByList(numeratorList)

            Return a MeterSequence
            countRequest is within the context of the beatIndex



            >>> from music21 import *
            >>> a = meter.MeterTerminal('3/4')
            >>> b = a.subdivideByList([1,1,1])
            >>> len(b)
            3



        .. method:: subdivideByOther(other)

            Return a MeterSequence
            based on another MeterSequence



            >>> from music21 import *
            >>> a = meter.MeterSequence('1/4+1/4+1/4')
            >>> a
            <MeterSequence {1/4+1/4+1/4}>
            >>> b = meter.MeterSequence('3/8+3/8')
            >>> a.subdivideByOther(b)
            <MeterSequence {{3/8+3/8}}>




NonPowerOfTwoTimeSignature
--------------------------

Inherits from: :class:`~music21.meter.TimeSignature`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: NonPowerOfTwoTimeSignature(value='4/4', partitionRequest=None)



