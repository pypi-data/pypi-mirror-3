<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Extending lk_worker</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5951 2009-05-18 18:03:10Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left{
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="extending-lk-worker">
<h1 class="title">Extending lk_worker</h1>

<div class="sidebar">
<p class="first sidebar-title">This page</p>
<div class="contents last topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#nodes-as-navigation" id="id1">Nodes as navigation</a><ul>
<li><a class="reference internal" href="#context" id="id2">Context</a></li>
<li><a class="reference internal" href="#generalisation" id="id3">Generalisation</a></li>
<li><a class="reference internal" href="#complex-extensions" id="id4">Complex extensions</a></li>
<li><a class="reference internal" href="#applications-are-node-types" id="id5">Applications are node types</a></li>
<li><a class="reference internal" href="#reports-are-not-extendable" id="id6">Reports are not extendable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extension-interfaces" id="id7">Extension Interfaces</a><ul>
<li><a class="reference internal" href="#type-definition" id="id8">Type definition</a></li>
<li><a class="reference internal" href="#user-interface-controllers" id="id9">User Interface Controllers</a></li>
<li><a class="reference internal" href="#data-definition" id="id10">Data definition</a></li>
<li><a class="reference internal" href="#user-interface" id="id11">User Interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linking-into-the-node-structure" id="id12">Linking into the node structure</a></li>
</ul>
</div>
</div>
<div class="section" id="nodes-as-navigation">
<h1><a class="toc-backref" href="#id1">Nodes as navigation</a></h1>
<div class="section" id="context">
<h2><a class="toc-backref" href="#id2">Context</a></h2>
<p>The graph structure supported by nb allows for navigation through a
set of linked entities, and also provides access control based on
that structure. Navigation and access control by themselves do not
make business applications and the structure needs to be extended using
application specific data, views and controls. Extension should be
done in a flexible, configurable, way, rather than by code
modification.</p>
<p>There is no limit on what application any one node can be, nor is
there any intention of limiting the data that can be associated with a
node. There is no intention of limiting nodes according to, say, the
type, class or application of a parent node. The flexibility,
therefore, comes within the node itself. The user sees a consistent
navigation structure, while the detail depends on the individual
node. The overall user experience then depends on how the system
designer chooses to lay out the structure (including the degree of
flexibility given to users to create their own structures).</p>
</div>
<div class="section" id="generalisation">
<h2><a class="toc-backref" href="#id3">Generalisation</a></h2>
<p>Any node may have arbitrary data extensions associated with it. If
there are data extensions that support, say, project activities and
book sales, then a node may have neither, either or both of these data
extensions associated with it. Of course, any particular application
may restrict what happens, but this remains the general case.</p>
<p>The extension principle that supports this general case requires the
code to consider, at every appropriate point, what data extensions are
available and in use, and to invoke the relevant supporting code for
each extension in turn. This requires that a data extension must come
with a set of supporting code segments or data that can be used at
appropriate points.</p>
</div>
<div class="section" id="complex-extensions">
<h2><a class="toc-backref" href="#id4">Complex extensions</a></h2>
<p>A data extension is, in the simplest case, a table with a zero-to-one
relationship with a node. That is, there cannot be more than one entry
on the table for a given node.</p>
<p>A more complex extension would involve a table with a many-to-one
relationship with a node. Some care might be needed in system design
to distinguish between multiple records attached to a node on the one
hand, and multiple children of a node on the other. The decision
whether to take one approach or the other depends on speed of
implementation (it is marginally easier to use child nodes), volume of
data (child nodes provide a built in paged lists) and the need for
flexibility in navigation and data linking. Attaching files to a node
seems a reasonable use of a specific data extension, while attaching
sub-activities to an activity would be best done using child nodes.</p>
<p>In principle it is possible to construct a data extension that is a
set of interlinked tables in its own right. In this case, node
navigation is used to reach the data while navigation within the data
is provided by application specific code. Such an application is
likely to be less flexible than one based on smaller extensions and
node navigation but may be better able to support special application
interfaces and relationships that are not obviously hierarchical.</p>
<p>The advantage of hanging a complex extension onto a node is that the
node navigation bcomes a type of menu and the node based acccess
control can be applied. In many cases this advantage may be too
difficult to use, or simply irrelevant. The extension mechanism is not
meant to be applied officiously in the face of evidence that other
methods are better.</p>
</div>
<div class="section" id="applications-are-node-types">
<h2><a class="toc-backref" href="#id5">Applications are node types</a></h2>
<p>An application is a collection of data and business processes that
address some business issue.</p>
<p>At its simplest, an application could re-use data structures, perhaps
doing no more than defining a possible set of values for a status
field, or defining a work-flow suited to a particular business
context. In effect, this defines a node type.</p>
<p>A more complex application might require extension data items specific
to that application, but might still rely on the generalised display
and edit facilities. Again, this can be thought of as a node type.</p>
<p>More complex still, an application would provide special user
interface displays intended to support business processes in some
specific way. In principle, such an application may also manage the
way in which nodes are added to the structure and the types of nodes
that could be added.</p>
<p>The nb extensions are, at this stage, limited to defining node
types. It is, of course, possible to define a node type that takes a
user to a different world, but nb itself assumes that applications are
built using some combinations of node type and node access permission.</p>
<p>An node type consists of some combination of data items, a set of
actions that the user might be able to do (read, modify, delete and
other context dependent variants on these ideas), some application
specific variations on node data (such as status), and appropriate
views to support the business processes.</p>
</div>
<div class="section" id="reports-are-not-extendable">
<h2><a class="toc-backref" href="#id6">Reports are not extendable</a></h2>
<p>Reports are independent pieces of code that are given appropriate
parameters and produce a stand-alone result.</p>
<p>In general, reports are not extendable. That is, a report is designed
to do whatever it does, and it must make assumptions about the data
that is available. It would be reasonable, as a design principle, for a
report to produce a usable result if some aspects of the desired data
are not available, but that is all.</p>
<p>It is possible that a certain report, or report class, may be written
in an extendable way. This possibility is not covered here.</p>
<p>The user interface must be extendable in as much as user-requestable
reports must be made available for requesting. As a report request
process has not yet been designed, this aspect is covered here.</p>
</div>
</div>
<div class="section" id="extension-interfaces">
<h1><a class="toc-backref" href="#id7">Extension Interfaces</a></h1>
<div class="section" id="type-definition">
<h2><a class="toc-backref" href="#id8">Type definition</a></h2>
<p>A type definition is made up of:</p>
<ul>
<li><p class="first">name</p>
<p>A human readable type name - this value is stored in the node data
and is the key to all subsequent interpretation.</p>
</li>
</ul>
<ul>
<li><p class="first">paths</p>
<p>A set of URLs relating to the current node that are to appear in the
navigation area of a page. The basic set consists of:</p>
<ul class="simple">
<li>display: show a read-only page</li>
<li>detail: show an edit/update page</li>
<li>list: list all child nodes</li>
<li>search: search from this node downwards</li>
</ul>
<p>Since nodes may contain any data (and be of any type) these standard
links will normally be to the generalised code. The generalised code
supports user interface extensions and may be sufficient in many
cases. The standard url dispatcher also supports type dependent
controllers which provide flexibility at the aplication level.</p>
<p>Other links may be added to support business process actions.
Generally, the presence or absence of a link on a user's view is
controlled by user access permissions.</p>
</li>
<li><p class="first">other data</p>
<p>There will also be special text and codes that are interpretable by
the application. Specifically, there may be option lists that are
specific to the application. For example, a set of possible
priorities. Option lists take a specific structure.</p>
</li>
</ul>
</div>
<div class="section" id="user-interface-controllers">
<h2><a class="toc-backref" href="#id9">User Interface Controllers</a></h2>
<p>Controllers respond to URLs. For URLs that contain a node reference,
the dispatcher can invoke a controller that depends on the type of the
node. This has the effect of turning a node type into an application.</p>
<blockquote>
<ul class="simple">
<li>display an editable page = 'nb.controller.display.edit'</li>
<li>display a page for adding a new entry = 'nb.controller.display.add'</li>
<li>display data read-only = 'nb.controller.display.formatted'</li>
<li>display a list of sub-nodes = 'nb.controller.display.list'</li>
<li>present a default page = 'nb.controller.display.default'</li>
<li>respond to a POST = 'nb.controller.respond.update'</li>
<li>respond to a POST = 'nb.controller.respond.insert'</li>
<li>respond to request for a file = 'nb.controller.download.file'</li>
</ul>
</blockquote>
<p>Each of these code segments overrides the relevant generalised page
and must provide a complete view for the page, using all of the
relevant data for the node type. Node navigation is not handled or
replaced by these code segments.</p>
<p>The use of these type-specific pages assumes that data validation and
insert/update is handled by the data specific code segments outlined
in the next section.</p>
<p>Any controller can, of course, make use of the user interface
extensions.</p>
</div>
<div class="section" id="data-definition">
<h2><a class="toc-backref" href="#id10">Data definition</a></h2>
<p>A data definition provides a number of code segments that support read
validate and update of the data as well as optional user interface
extensions for search, display and edit.</p>
<ul>
<li><p class="first">read/write/validate</p>
<p>Read from the database is managed using a node-based query that is
modified according to filtering or sorting options.  Adding entities
to this query allows for data extensions, but there is no guarantee
of the order in which entities are added.  At the same time, some
extensions involve multiple sub-records, or data from a separate
database, so separate queries for this data might be appropriate.
The data from the various queries is used to construct a single
object dictionary that can be passed to other processes so that
these other processes see a consistent picture of the data.</p>
<ul>
<li><p class="first">extend query = 'nd.read.query.extend'</p>
<p>extend the given node query - perhaps using a join - to include
the data extension.</p>
</li>
<li><p class="first">extend data object = 'nd.read.data.extend'</p>
<p>Place the extension data into the data object. This could be a
simple as identifying the database entity from the returned result
of the node query, or a more complex construction of multiple
sub-records.</p>
</li>
<li><p class="first">write from an extended object = 'nd.write.data.extend'</p>
<p>Use an extended object (or possibly a sub-set of one) as a data
source to write data back to the database.</p>
</li>
<li><p class="first">delete from an extended object = 'nd.delete.data.extend'</p>
<p>Use an extended object to identify, and delete, entries in the
database.</p>
</li>
<li><p class="first">validate data in an extended object = 'nd.validate.data.extend'</p>
<p>Validate the data in the given extended object and raise errors.</p>
</li>
<li><p class="first">compare data in extended objects = 'nd.compare.data.extend'</p>
<p>Compare two extended objects and report on differences</p>
</li>
</ul>
</li>
<li><p class="first">search</p>
<p>Search requires the creation and the application of a filter. A
filter is simply a dictionary containing named values. The following
item is part of the data interface because it does not depend on the
user interface and can be used by other code.</p>
<ul>
<li><p class="first">extend filter query = 'nd.search.query.extend'</p>
<p>Extend a filter query using the given filter.</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="user-interface">
<h2><a class="toc-backref" href="#id11">User Interface</a></h2>
<blockquote>
These items extend the generalised interface.  They will normally be
invoked for every node, regardless of whether the node has the
relevant data extension.  Since every data extension can be seen on
the generalised interface the user may potentially populate any or
all data extensions on any one node.  The data extension code must
impose any limitations that might be required by the application
context by applying relevant conditions from other data or by
applying access permissions.</blockquote>
<ul>
<li><p class="first">Node display and interaction</p>
<ul>
<li><p class="first">add form elements = 'nd.view.form.extend'</p>
<p>Place form elements on to the given display form.</p>
</li>
<li><p class="first">populate form elements = 'nd.view.form.populate'</p>
<p>Place data from the data object into the form elements.</p>
</li>
<li><p class="first">process form elements = 'nd.view.form.process'</p>
<p>Validate user input.</p>
</li>
<li><p class="first">store from form elements = 'nd.view.form.store'</p>
<p>Store the data to the database.</p>
</li>
<li><p class="first">Populate the main page in the display page = 'nd.display.main'</p>
<p>Provide some text that can appear in the main body of the display
page.</p>
</li>
<li><p class="first">Populate the sidebar in the display page = 'nd.display.side'</p>
<p>Provide some text that can appear in the side bar of the display
page.</p>
</li>
</ul>
</li>
<li><p class="first">search</p>
<p>Search requires the creation and the application of a filter. A
filter is simply a dictionary containing named values. These items
extend the user interface accordingly.</p>
<ul>
<li><p class="first">make filter form = 'nd.search.form.extend'</p>
<p>Add form elements to a form to give the user a search facility on
this data.</p>
</li>
<li><p class="first">fill form from filter = 'nd.search.form.populate'</p>
<p>Given a filter, populate the form</p>
</li>
<li><p class="first">Populate the filter object = 'nd.search.form.store'</p>
<p>Place items from the form into the filter object.</p>
</li>
<li><p class="first">make filter from form</p>
<p>Given a form, construct the elements of the filter.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="linking-into-the-node-structure">
<h1><a class="toc-backref" href="#id12">Linking into the node structure</a></h1>
<p>Extensions and types are registered in a static instance of the
ExtensionStore class.  The data structures that are used to define the
data extensions and types are held somewhere within each package and
passed to the register method of the ExtensionStore.</p>
<p>There are, in principle, (and possibly 'at'least') four ways of having
a type or extension register itself:</p>
<ol class="arabic">
<li><p class="first">For each extension or group of extensions, place a code module into
an 'extensions' directory that is accessible from the startup
environment.  Initialisation code in nb will execute (that is,
import) all modules within this directory.</p>
<p>This method seems to challenge the software release process as it
becomes difficult to manage extensions that have different revision
cycles.</p>
</li>
<li><p class="first">For each extension or group of extensions, place a suitable
'import' statement into a startup.py module that is accessible from
the startup environment.</p>
<p>This keeps the configuration separate from the revision cycle.  It
is much the same as the ini file approach, with the disadvantage
that it is a separate file.</p>
</li>
<li><p class="first">Place references to the modules to be imported into the
initialisation file.</p>
<p>This keeps the configuration separate from the revision cycle.</p>
</li>
<li><p class="first">Have the nb startup code search the full path for all modules named
'nb_register_extension.py', or something similar, and import each one.</p>
<p>This seems to do the job without explicit configuration, although
it leads to slow start-up and to the possibility of finding
something that is not actually what we want.</p>
</li>
</ol>
<p>The method that is used is a combination of the last two mechanisms.</p>
<blockquote>
<ul class="simple">
<li>The ini file will contain one or more 'package = xxx' entries.</li>
<li>Each package entry refers to a python package that is visible on the path.</li>
<li>The package is then treated as a directory and searched for files
named 'nb_register_extension.py' or 'nb_register_*_extension.py'
and imports each one.</li>
</ul>
</blockquote>
</div>
</div>
</body>
</html>
