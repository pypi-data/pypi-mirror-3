\documentclass[11pt]{paper}
\usepackage{amssymb,latexsym}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{graphicx}
%\textwidth=6.5in
%\textheight=9.5in
\usepackage{color,fancyvrb}
\usepackage{soul,color}
\definecolor{NavyBlue}      {cmyk}{0.94,0.54,0,0}
\setulcolor{NavyBlue}

   
\begin{document}


\setcounter{page}{1}

\title{qmath Quick Card}
\author{Marco Abrate} 
\maketitle
\vskip-0.6cm
\noindent \small{abrate.m@gmail.com}




\tableofcontents

\section{Installation}
qmath can be installed by python. To run qmath with python, Python 2.2 or later must already be installed. The latest release is recommended. Python is available from http://www.python.org/.

The first step is to download the qmath tarball from http://pypi.python.org/pypi.
Open a shell. Unpack the tarball in a temporary directory (not directly in Python's site-packages). Commands:
\begin{verbatim}
  tar zxf qmath-X.Y.Z.tar.gz
\end{verbatim}
X, Y and Z are the major and minor version numbers of the tarball.
Go to the directory created by expanding the tarball:
\begin{verbatim}
  cd qmath-X.Y.Z
\end{verbatim}
Get root privileges:
\begin{verbatim}
  su
 
 (enter root password)
\end{verbatim}
To install for python type:
\begin{verbatim}
python setup.py install
\end{verbatim}
If the python executable isn't on your path, you'll have to specify the complete path, such as /usr/local/bin/python.

\bigskip

\section{Classes}

\noindent $\textcolor{blue}{\texttt{class quaternion}}(attitude)$

\noindent Quaternion class. 

\noindent $attitude$ can be:

\noindent - a number (of any type, complex are included);
\begin{verbatim}
    >>> import qmath
    >>> qmath.quaternion(1)
    (1.0)
    >>> qmath.quaternion(1+1j)
    (1.0+1.0i)
\end{verbatim}
\noindent - a list or a numpy array of the components with respect to \texttt{1,i,j} and \texttt{k}; 
\begin{verbatim}
    >>> qmath.quaternion([1,2,3,4])
    (1.0+2.0i+3.0j+4.0k)
    >>> qmath.quaternion(np.array([1,2,3,4]))
    (1.0+2.0i+3.0j+4.0k)
\end{verbatim}
\noindent - a string of the form \texttt{'a+bi+cj+dk'};
\begin{verbatim}
    >>> qmath.quaternion('1+1i+3j-2k')
    (1.0+1.0i+3.0j-2.0k)
\end{verbatim}
\noindent - a rotation about an axis using pairs (rotation angle, axis of rotation);
\begin{verbatim}
    >>> qmath.quaternion(0.5 * math.pi, [0,0,1])
    (0.968912421711+0.247403959255k)
\end{verbatim}


\noindent - a list whose components are Euler angles;
\begin{verbatim}
    >>> import math
    >>> qmath.quaternion([0.0,math.pi / 6,math.pi / 3])
    (0.836516303738+0.482962913145i+0.224143868042j-0.129409522551k)
\end{verbatim}
\noindent - a 3X3 rotation matrix. The matrix must be given as a numpy array.
\begin{verbatim}
    import numpy as np
    >>> qmath.quaternion(np.array([[0  ,-0.8 ,-0.6],\\
                                   [0.8,-0.36, 0.48],\\
                                   [0.6,0.48 ,-0.64]]))
    (0.707106781187i+0.565685424949j+0.424264068712k)
\end{verbatim}        
    
\bigskip

\section{Methods}
\noindent $\textcolor{blue}{\texttt{\_\_repr\_\_}}(self)$ 

Quaternions are represented in the algebraic way: $q = a+bi+cj+dk$, and $a,b,c,d$ are floats.

\medskip
 
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{getitem}\_\_}}(self,key)$

Returns one of the four float components of the quaternion. This method allows to get the components by \texttt{quaternion[key]}.

\medskip

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{setitem}\_\_}}(self,key, number)$

Set one of the four float components of the quaternion. This method allows to set the components by \texttt{quaternion[key] = number}.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{delitem}\_\_}}(self,key)$

Delete (set to zero) one of the four float components of the quaternion. This method allows to write \texttt{del quaternion[key]}.

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{delslice}\_\_}}(self,key_1,key_2)$

Delete (set to zero) the components of the quaternion from the $key_1-th$ to the $key_2-th$. This method allows to write \texttt{del quaternion[1:3]}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{contains}\_\_}}(self,key)$

Returns $0$ if the component of the quaternion with respect to $key$ is zero, $1$ otherwise. This method allows to write \texttt{del 'k' in quaternion}.
\begin{verbatim}
    >>> q = qmath.quaternion('1+1i+5k')
    >>> 'j' in q
    False
    >>> 'i' in q
    True
\end{verbatim}

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{eq}\_\_}}(self,other)$

Returns \texttt{True} if two quaternion are equal, \texttt{False} otherwise. This method allows to write \texttt{quaternion1 == quaternion2}.
\begin{verbatim}
    >>> import qmath
    >>> q = qmath.quaternion('1+1k')
    >>> q == 0
    False
    >>> q == '1+1k'
    True
\end{verbatim}
\noindent Also equalities with a tolerance are admitted:
\begin{verbatim}
    >>> q == qmath.quaternion([1,0,1e-15,1])|1e-9
    True
    >>> q == [1,1,1e-15,0]
    False
        
\end{verbatim}
\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{ne}\_\_}}(self,other)$

The opposite of $\_\_$eq$\_\_$. This method allows to write \texttt{quaternion1 != quaternion2}.

\begin{verbatim}
    >>> q = qmath.quaternion('1+1k')
    >>> q != 0
    True
    >>> q != '1+1k'
    False
\end{verbatim}

\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{iadd}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{isub}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{imul}\_\_}}(self,other)$ 

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{idiv}\_\_}}(self,other)$

These methods are called to implement the augmented arithmetic assignments. These methods should attempt to do the operation in-place (modifying self) and return the result.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{add}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{sub}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{mul}\_\_}}(self,other)$

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{div}\_\_}}(self,other)$

These methods are called to implement the binary arithmetic operations. For instance, to evaluate the expression \texttt{x + y}, where \texttt{x} is a quaternion, \texttt{x.\_\_\mbox{add}\_\_(y)} is called. \texttt{y} can either be a quaternion or something that can be converted to quaternion.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{rmul}\_\_}}(self,other)$ 

\noindent $\textcolor{blue}{\texttt{\_\_\mbox{rdiv}\_\_}}(self,other)$

These methods are called to implement the binary arithmetic operations with reflected operands.


\medskip        
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{neg}\_\_}}(self)$

Return the opposite of a quaternion. You can write \texttt{- quaternion}.


\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{pow}\_\_}}(self,exponent)$

Implements the operator \texttt{**}. The power of a quaternion can be computed for integer power (both positive or negative) and also if the exponent is half or third a number: for example square or cube roots are evaluated. (see also \texttt{sqrt} and \texttt{croot})
\begin{verbatim}
    >>> base = qmath.quaternion('1+1i+2j-2k')
    >>> base ** 3
    (-26.0-6.0i-12.0j+12.0k)
    >>> base ** (-2)
    (-0.08-0.02i-0.04j+0.04k)
    >>> qmath.quaternion([-5,1,0,1]) ** (1.0/3)
    (1.0+1.0i+1.0k)
    >>> qmath.quaternion([-5,1,0,1]) ** (2.0/3)
    (-1.0+2.0i+2.0k)
    >>> qmath.quaternion('1.0+1.0i+1.0k') ** 2
    (-1.0+2.0i+2.0k)
\end{verbatim}
\medskip
\noindent $\textcolor{blue}{\texttt{\_\_\mbox{abs}\_\_}}(self)$ 

Returns the modulus of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{equal}}}(self,other[,tolerance])$ 

Returns quaternion equality with arbitrary tolerance. If no tolerance is admitted it is the same as $\texttt{\_\_\mbox{eq}\_\_}(self,other)$.
\begin{verbatim}
    >>> a = qmath.quaternion([1,1,1e-15,0])
    >>> b = qmath.quaternion(1+1j)
    >>> a.equal(b,1e-9)
    True
    >>> a.equal(b)
    False
\end{verbatim}

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{real}}}(self)$ 

Returns the real part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{imag}}}(self)$ 

Returns the imaginary part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{trace}}}(self)$ 

Returns the trace of the quaternion (the double of its real part).

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{conj}}}(self)$ 

Returns the conjugate of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{norm}}}(self)$ 

Returns the norm of the quaternion (the square of the modulus).

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{delta}}}(self)$ 

Returns the $\delta$ of the quaternion, that is the opposite of the norm of the imaginary part of the quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{inverse}}}(self)$ 

Quaternionic inverse, if it exists. It is the same as \texttt{quaternion ** (-1)}.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{unitary}}}(self)$ 

Returns the normalized quaternion, if different from zero.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{sqrt}}}(self)$ 

Computes the square root of the quaternion. If the quaternion has only two roots, the one with positive trace is given: if this method returns r, also -r is a root.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{croot}}}(self)$ 

Computes the cube root (unique) of a quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{QuaternonToRotation}}}(self)$ 

Converts the quaternion, if unitary, into a rotation matrix.

\bigskip

\section{Additional Functions}

\noindent $\textcolor{blue}{\texttt{\mbox{real}}}(object)$ 

The same as $\texttt{\mbox{object.real}}()$.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{imag}}}(object)$ 

The same as $\texttt{\mbox{object.imag}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{trace}}}(object)$ 

The same as $\texttt{\mbox{object.trace}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{conj}}}(object)$ 

The same as $\texttt{\mbox{object.conj}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{norm}}}(object)$ 

The same as $\texttt{\mbox{object.norm}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{delta}}}(object)$ 

The same as $\texttt{\mbox{object.delta}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{inverse}}}(object)$ 

The same as $\texttt{\mbox{object.inverse}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{unitary}}}(object)$ 

The same as $\texttt{\mbox{object.unitary}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{sqrt}}}(object)$ 

The same as $\texttt{\mbox{object.sqrt}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{croot}}}(object)$ 

The same as $\texttt{\mbox{object.croot}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{QuaternonToRotation}}}(object)$ 

The same as $\texttt{\mbox{object.QuaternioinToRotation}}().$

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{RotationToQuaternion}}}(angle,vector)$ 

Converts a pair angle-vector into a quaternion.


\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{StringToQuaternion}}}(string)$ 

Converts a string into a quaternion.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{MatrixToEuler}}}(matrix)$ 

Converts a 3X3 matrix into a vector having Euler angles as components.

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{EulerToQuaternion}}}(list)$ 

Converts a vector whose components are Euler angles into a quaternion.
    

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{identity}}}()$ 

Returns 1 as a quaternion.
\begin{verbatim}
    >>> qmath.identity()
    (1.0)
\end{verbatim}
\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{zero}}}()$ 

Returns 0 as a quaternion.
\begin{verbatim}
    >>> qmath.zero()
    (0.0)
\end{verbatim}

\medskip
\noindent $\textcolor{blue}{\texttt{\mbox{dot}}}(object_1,object_2)$ 

Returns the dot product of two quaternions.
\begin{verbatim}
    >>> a = qmath.quaternion('1+2i-2k')
    >>> b = qmath.quaternion('3-2i+8j')
    >>> qmath.dot(a,b)
    -1.0
\end{verbatim}

\medskip


\noindent $\textcolor{blue}{\texttt{\mbox{CrossRatio}}}(a,b,c,d)$ 

Returns the cross ratio of four quaternions defined by:
$$
{\texttt{\mbox{CrossRatio}}}(a,b,c,d) = (a-c)\cdot(a-d)^{-1}\cdot(b-d)\cdot(b-c)^{-1}.
$$ 
If $a = d$ or $b = c$ returns the string \texttt{\mbox{'Infinity'}}.

The arguments of {\texttt{\mbox{CrossRatio}}} can be passed as a tuple.
\begin{verbatim}
    >>> a = qmath.quaternion([1,0,1,0])
    >>> b = qmath.quaternion([0,1,0,1])
    >>> c = qmath.quaternion([-1,0,-1,0])
    >>> d = qmath.quaternion([0,-1,0,-1])
    >>> qmath.CrossRatio(a,b,c,d)
    (2.0)
    >>> tpl = a,b,c,d
    >>> qmath.CrossRatio(tpl)
    (2.0)
    >>> qmath.CrossRatio(a,b,b,d)
    'Infinity'
    >>> qmath.CrossRatio(a,a,a,d)
    (1.0)
    >>> qmath.CrossRatio(a,b,a,b)
    (0.0)
\end{verbatim}
\medskip

\noindent $\textcolor{blue}{\texttt{\mbox{Moebius}}}(z,a,b,c,d)$ 

Returns the Moebius transformation with parameters a,b,c and d:
$$
f(z)=(a\cdot z+b)\cdot(c\cdot z+d)^{-1}. 
$$
If $c \cdot z + d = 0$ returns the string \texttt{\mbox{'Infinity'}}. 

The arguments of {\texttt{\mbox{Moebius}}} can be passed as a tuple.
\begin{verbatim}
    >>> a = qmath.quaternion([1,1,1,0])
    >>> b = qmath.quaternion([-2,1,0,1])
    >>> c = qmath.quaternion([1,0,0,0])
    >>> d = qmath.quaternion([0,-1,-3,-4])
    >>> z = qmath.quaternion([1,1,3,4])
    >>> qmath.Moebius(z,a,b,c,d)
    (-5.0+7.0i+7.0k)
    >>> d = - z
    >>> z = qmath.Moebius(z,a,b,c,d)
    >>> z
    'Infinity'
    >>> qmath.Moebius(z,a,b,c,d)
    (1.0+1.0i+1.0j)
\end{verbatim}

\bigskip



\end{document}