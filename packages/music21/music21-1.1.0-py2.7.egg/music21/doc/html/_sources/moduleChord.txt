.. _moduleChord:

music21.chord
=============

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED. Edit the .py file directly

.. module:: music21.chord


This module defines the Chord object, a sub-class of :class:`~music21.note.GeneralNote`
as well as other methods, functions, and objects related to chords.




.. function:: fromForteClass(notation)

    Return a Chord given a Forte-class notation. The Forte class can be specified as string (e.g., 3-11) or as a list of cardinality and number (e.g., [8,1]).

    If no match is available, None is returned.



    >>> from music21 import *
    >>> chord.fromForteClass('3-11')
    <music21.chord.Chord C E- G>
    >>> chord.fromForteClass('3-11b')
    <music21.chord.Chord C E G>
    >>> chord.fromForteClass('3-11a')
    <music21.chord.Chord C E- G>
    >>> chord.fromForteClass((11,1))
    <music21.chord.Chord C C# D E- E F F# G G# A B->



.. function:: fromIntervalVector(notation, getZRelation=False)

    Return one or more Chords given an interval vector.



    >>> from music21 import *
    >>> chord.fromIntervalVector([0,0,0,0,0,1])
    <music21.chord.Chord C F#>
    >>> chord.fromIntervalVector((5,5,5,5,5,5)) == None
    True
    ⁠ 
    >>> chord.fromIntervalVector((1,1,1,1,1,1))
    <music21.chord.Chord C C# E F#>



    >>> chord.fromIntervalVector((1,1,1,1,1,1), getZRelation=True)
    <music21.chord.Chord C C# E- G>
    ⁠ 
    >>> chord.fromIntervalVector((1,1,1,1,1,1)).getZRelation()
    <music21.chord.Chord C C# E- G>




Chord
-----

Inherits from: :class:`~music21.note.NotRest`, :class:`~music21.note.GeneralNote`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Chord(notes=[], **keywords)

    Class for dealing with chords

    A Chord functions like a Note object but has multiple pitches.

    Create chords by passing a string of pitch names



    >>> from music21 import *
    >>> dmaj = chord.Chord(["D","F#","A"])


    Or you can combine already created Notes or Pitches:




    >>> Cnote = note.Note()
    >>> Cnote.name = 'C'
    >>> Enote = note.Note()
    >>> Enote.name = 'E'
    >>> Gnote = note.Note()
    >>> Gnote.name = 'G'


    And then create a chord with note objects:




    >>> cmaj = chord.Chord([Cnote, Enote, Gnote])


    Chord has the ability to determine the root of a chord, as well as the bass note of a chord.
    In addition, Chord is capable of determining what type of chord a particular chord is, whether
    it is a triad or a seventh, major or minor, etc, as well as what inversion the chord is in.



    **Chord** **attributes**

        .. attribute:: isChord

            Boolean read-only value describing if this GeneralNote object is a Chord. Is True


        .. attribute:: isNote

            Boolean read-only value describing if this GeneralNote object is a Note. Is False


        .. attribute:: isRest

            Boolean read-only value describing if this GeneralNote object is a Rest. Is False


        .. attribute:: beams

            A :class:`music21.beam.Beams` object.


        Attributes inherited from :class:`~music21.note.GeneralNote`: :attr:`~music21.note.GeneralNote.lyrics`, :attr:`~music21.note.GeneralNote.expressions`, :attr:`~music21.note.GeneralNote.articulations`, :attr:`~music21.note.GeneralNote.editorial`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.isStream`, :attr:`~music21.base.Music21Object.isVariant`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`

    **Chord** **properties**

        .. attribute:: pitches

            Get or set a list of all Pitch objects in this Chord.



            >>> from music21 import *
            >>> c = chord.Chord(["C4", "E4", "G#4"])
            >>> c.pitches
            [C4, E4, G#4]
            >>> [p.midi for p in c.pitches]
            [60, 64, 68]
            ⁠ 
            >>> d = chord.Chord()
            >>> d.pitches = c.pitches
            >>> d.pitches
            [C4, E4, G#4]



        .. attribute:: chordTablesAddress


            Return a three-element tuple that represents
            that raw data location for information on the
            set class interpretation of this Chord.
            The data format is Forte set class cardinality,
            index number, and inversion status
            (where 0 is invariant, and -1 and 1 represent
            inverted or not, respectively).



            >>> from music21 import *
            >>> c = chord.Chord(["C4", "E4", "G#4"])
            >>> c.chordTablesAddress
            (3, 12, 0)



        .. attribute:: color

            Return the Note color.



        .. attribute:: commonName


            return the most common name associated with this Chord as a string.
            does not currently check enharmonic equivalents.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.commonName
            'minor triad'
            ⁠ 
            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.commonName
            'major triad'



            >>> from music21 import *
            >>> c3 = chord.Chord(['c', 'd-', 'e', 'f#'])
            >>> c3.commonName
            'all-interval tetrachord'




        .. attribute:: duration

            Get and set the duration of this Chord as a Duration object.



            >>> from music21 import *
            >>> c = chord.Chord(['a', 'c', 'e'])
            >>> c.duration
            <music21.duration.Duration 1.0>


            Durations can be overridden after the fact:




            >>> d = duration.Duration()
            >>> d.quarterLength = 2
            >>> c.duration = d
            >>> c.duration
            <music21.duration.Duration 2.0>
            >>> c.duration == d
            True
            >>> c.duration is d
            True




        .. attribute:: fifth

            shortcut for getChordStep(5)



            >>> from music21 import *
            >>> cMaj1stInv = chord.Chord(['E3','C4','G5'])
            >>> cMaj1stInv.fifth
            G5
            >>> cMaj1stInv.fifth.midi
            79





        .. attribute:: forteClass

            Return the Forte set class name as a string. This assumes a Tn formation, where inversion distinctions are represented.

            (synonym: forteClassTn)



            >>> from music21 import *
            ⁠ 
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.forteClass
            '3-11A'



            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.forteClass
            '3-11B'



        .. attribute:: forteClassNumber

            Return the number of the Forte set class within the defined set group. That is, if the set is 3-11, this method returns 11.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.forteClassNumber
            11



        .. attribute:: forteClassTn


            A synonym for "forteClass"

            Return the Forte Tn set class name, where inversion distinctions are represented.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.forteClass
            '3-11A'
            ⁠ 
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.forteClassTn
            '3-11B'



        .. attribute:: forteClassTnI

            Return the Forte TnI class name, where inversion distinctions are not represented.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.forteClassTnI
            '3-11'



        .. attribute:: fullName

            Return the most complete representation of this Note, providing duration and pitch information.



            >>> from music21 import *
            >>> c = chord.Chord(["D","F#","A"])
            >>> c.fullName
            'Chord {D | F-sharp | A} Quarter'
            ⁠ 
            >>> chord.Chord(['d1', 'e4-', 'b3-'], quarterLength=2/3.).fullName
            'Chord {D1 | E4-flat | B3-flat} Quarter Triplet (0.67QL)'



        .. attribute:: hasZRelation

            Return True or False if the Chord has a Z-relation.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.hasZRelation
            False



        .. attribute:: intervalVector

            Return the interval vector for this Chord as a list of integers.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.intervalVector
            [0, 0, 1, 1, 1, 0]



        .. attribute:: intervalVectorString

            Return the interval vector as a string representation.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.intervalVectorString
            '<001110>'



        .. attribute:: isPrimeFormInversion

            Return True or False if the Chord represents a set class inversion.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.isPrimeFormInversion
            False
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.isPrimeFormInversion
            True



        .. attribute:: midiEvents

            Get or set this Chord as a list of :class:`music21.midi.base.MidiEvent` objects.



            >>> from music21 import *
            >>> c = chord.Chord(['c3','g#4', 'b5'])
            >>> c.volume = volume.Volume(velocity=90)
            >>> c.volume.velocityIsRelative = False
            >>> c.midiEvents
            [<MidiEvent DeltaTime, t=0, track=None, channel=None>, <MidiEvent NOTE_ON, t=None, track=None, channel=1, pitch=48, velocity=90>, <MidiEvent DeltaTime, t=0, track=None, channel=None>, <MidiEvent NOTE_ON, t=None, track=None, channel=1, pitch=68, velocity=90>, <MidiEvent DeltaTime, t=0, track=None, channel=None>, <MidiEvent NOTE_ON, t=None, track=None, channel=1, pitch=83, velocity=90>, <MidiEvent DeltaTime, t=1024, track=None, channel=None>, <MidiEvent NOTE_OFF, t=None, track=None, channel=1, pitch=48, velocity=0>, <MidiEvent DeltaTime, t=0, track=None, channel=None>, <MidiEvent NOTE_OFF, t=None, track=None, channel=1, pitch=68, velocity=0>, <MidiEvent DeltaTime, t=0, track=None, channel=None>, <MidiEvent NOTE_OFF, t=None, track=None, channel=1, pitch=83, velocity=0>]



        .. attribute:: midiFile

            Return a complete :class:`music21.midi.base.MidiFile` object based on the Chord.

            The :class:`music21.midi.base.MidiFile` object can be used to write a MIDI file
            of this Chord with default parameters using the :meth:`music21.midi.base.MidiFile.write`
            method, given a file path. The file must be opened in 'wb' mode.



            >>> from music21 import *
            >>> c = chord.Chord(['c3','g#4', 'b5'])
            >>> mf = c.midiFile
            >>> mf.open('/Volumes/xdisc/_scratch/midi.mid', 'wb')
            >>> mf.write()
            >>> mf.close()



        .. attribute:: multisetCardinality

            Return an integer representing the cardinality of the mutliset, or the number of pitch values.



            >>> from music21 import *
            >>> c1 = chord.Chord(["D4", "A4", "F#5", "D6"])
            >>> c1.multisetCardinality
            4



        .. attribute:: mx

            No documentation.


        .. attribute:: normalForm

            Return the normal form of the Chord represented as a list of integers.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.normalForm
            [0, 4, 7]



        .. attribute:: normalFormString

            Return a string representation of the normal form of the Chord.



            >>> from music21 import *
            >>> c1 = chord.Chord(['f#', 'e-', 'g'])
            >>> c1.normalFormString
            '<034>'



        .. attribute:: orderedPitchClasses

            Return an list of pitch class integers, ordered form lowest to highest.



            >>> from music21 import *
            >>> c1 = chord.Chord(["D4", "A4", "F#5", "D6"])
            >>> c1.orderedPitchClasses
            [2, 6, 9]



        .. attribute:: orderedPitchClassesString

            Return a string representation of the pitch class values.



            >>> from music21 import *
            >>> c1 = chord.Chord(['f#', 'e-', 'g'])
            >>> c1.orderedPitchClassesString
            '<367>'
            >>> # redundancies are removed
            >>> c1 = chord.Chord(['f#', 'e-', 'e-', 'g'])
            >>> c1.orderedPitchClassesString
            '<367>'



        .. attribute:: pitchClassCardinality

            Return a the cardinality of pitch classes, or the number of unique pitch classes, in the Chord.



            >>> from music21 import *
            >>> c1 = chord.Chord(["D4", "A4", "F#5", "D6"])
            >>> c1.pitchClassCardinality
            3



        .. attribute:: pitchClasses

            Return a list of all pitch classes in the chord as integers.



            >>> from music21 import *
            >>> c1 = chord.Chord(["D4", "A4", "F#5", "D6"])
            >>> c1.pitchClasses
            [2, 9, 6, 2]



        .. attribute:: pitchNames

            Return a list of Pitch names from each  :class:`~music21.pitch.Pitch` object's :attr:`~music21.pitch.Pitch.name` attribute.



            >>> from music21 import *
            >>> c = chord.Chord(['g#', 'd-'])
            >>> c.pitchNames
            ['G#', 'D-']
            >>> c.pitchNames = ['c2', 'g2']
            >>> c.pitchNames
            ['C', 'G']



        .. attribute:: pitchedCommonName

            Return the common name of this Chord preceded by its root, if a root is available.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c', 'e', 'g'])
            >>> c2.pitchedCommonName
            'C-major triad'



        .. attribute:: primeForm

            Return a representation of the Chord as a prime-form list of pitch class integers.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.primeForm
            [0, 3, 7]



        .. attribute:: primeFormString

            Return a representation of the Chord as a prime-form set class string.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.primeFormString
            '<037>'



        .. attribute:: quality


            returns the quality of the underlying triad of a triad or
            seventh, either major, minor, diminished, augmented, or other.



            >>> from music21 import *
            >>> a = chord.Chord(['a', 'c', 'e'])
            >>> a.quality
            'minor'


            Inversions don't matter, nor do added tones so long as a root can be found.




            >>> a = chord.Chord(['f', 'b', 'd', 'g'])
            >>> a.quality
            'major'
            ⁠ 
            >>> a = chord.Chord(['c', 'a-', 'e'])
            >>> a.quality
            'augmented'



            >>> a = chord.Chord(['c','c#','d'])
            >>> a.quality
            'other'


            Incomplete triads are returned as major or minor:




            >>> a = chord.Chord(['c','e-'])
            >>> a.quality
            'minor'




            >>> a = chord.Chord(['e-','g'])
            >>> a.quality
            'major'





        .. attribute:: scaleDegrees


            returns a list of two-element tuples for each
            pitch in the chord where the first element of the tuple
            is the scale degree as an int and the second is an Accidental
            object that specifies the alteration from the scale degree (could
            be None if the note is a part of the scale)


            It is easiest to see the utility of this method using a
            chord subclass, :class:`music21.roman.RomanNumeral`,
            but it is also callable from this Chord object if the
            Chord has a Key or Scale context set for it.




            >>> from music21 import *
            >>> k = key.Key('f#')  # 3-sharps minor
            >>> rn = roman.RomanNumeral('V', k)
            >>> rn.key
            <music21.key.Key of f# minor>
            >>> rn.pitches
            [C#5, E#5, G#5]
            >>> rn.scaleDegrees
            [(5, None), (7, <accidental sharp>), (2, None)]
            >>> rn2 = roman.RomanNumeral('N6', k)
            >>> rn2.pitches
            [B4, D5, G5]
            >>> rn2.scaleDegrees # N.B. -- natural form used for minor!
            [(4, None), (6, None), (2, <accidental flat>)]


            As mentioned above, the property can also get its scale from context if
            the chord is embedded in a Stream.  Let's create the same V in f#-minor
            again, but give it a context of c-sharp minor, and then c-minor instead:




            >>> chord1 = chord.Chord(["C#5", "E#5", "G#5"])
            >>> st1 = stream.Stream()
            >>> st1.append(key.Key('c#'))   # c-sharp minor
            >>> st1.append(chord1)
            >>> chord1.scaleDegrees
            [(1, None), (3, <accidental sharp>), (5, None)]




            >>> st2 = stream.Stream()
            >>> chord2 = chord.Chord(["C#5", "E#5", "G#5"])
            >>> st2.append(key.Key('c'))    # c minor
            >>> st2.append(chord2)          # same pitches as before gives different scaleDegrees
            >>> chord2.scaleDegrees
            [(1, <accidental sharp>), (3, <accidental double-sharp>), (5, <accidental sharp>)]




            >>> st3 = stream.Stream()
            >>> st3.append(key.Key('C'))    # C major
            >>> chord2 = chord.Chord(["C4","C#4","D4","E-4","E4","F4"])  # 1st 1/2 of chromatic
            >>> st3.append(chord2)
            >>> chord2.scaleDegrees
            [(1, None), (1, <accidental sharp>), (2, None), (3, <accidental flat>), (3, None), (4, None)]




        .. attribute:: seventh

            shortcut for getChordStep(7)



            >>> from music21 import *
            >>> bDim7_2ndInv = chord.Chord(['F2','A-3','B4','D5'])
            >>> bDim7_2ndInv.seventh
            A-3



        .. attribute:: third

            shortcut for getChordStep(3)



            >>> from music21 import *
            >>> cMaj1stInv = chord.Chord(['E3','C4','G5'])
            >>> cMaj1stInv.third
            E3
            >>> cMaj1stInv.third.octave
            3



        .. attribute:: tie

            either None or a :class:`~music21.note.Tie` object.


        .. attribute:: volume


            Get or set the :class:`~music21.volume.Volume` object for this Chord. When setting the .volume property, all pitches are treated as having the same Volume object.



            >>> from music21 import *
            >>> c = chord.Chord(['g#', 'd-'])
            >>> c.volume
            <music21.volume.Volume realized=0.71>
            >>> c.volume = volume.Volume(velocity=64)
            >>> c.volume.velocityIsRelative = False
            >>> c.volume
            <music21.volume.Volume realized=0.5>
            >>> c.volume = [volume.Volume(velocity=96), volume.Volume(velocity=96)]
            >>> c.hasComponentVolumes()
            True
            >>> c._volume == None
            True
            >>> c.volume.velocity
            96
            >>> c.volume.velocityIsRelative = False
            >>> c.volume  # return a new volume that is an average
            <music21.volume.Volume realized=0.76>




        Properties inherited from :class:`~music21.note.NotRest`: :attr:`~music21.note.NotRest.notehead`, :attr:`~music21.note.NotRest.noteheadFill`, :attr:`~music21.note.NotRest.noteheadParen`, :attr:`~music21.note.NotRest.stemDirection`

        Properties inherited from :class:`~music21.note.GeneralNote`: :attr:`~music21.note.GeneralNote.lyric`, :attr:`~music21.note.GeneralNote.musicxml`, :attr:`~music21.note.GeneralNote.quarterLength`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.beat`, :attr:`~music21.base.Music21Object.beatDuration`, :attr:`~music21.base.Music21Object.beatStr`, :attr:`~music21.base.Music21Object.beatStrength`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.isGrace`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`, :attr:`~music21.base.Music21Object.seconds`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Chord** **methods**

        .. method:: annotateIntervals(inPlace=True, stripSpecifiers=True, sortPitches=True)


            Add lyrics to the chord that show the distance of each note from
            the bass.  By default we show only the generic interval:




            >>> from music21 import *
            >>> c1 = chord.Chord(['C2','E2','G2','C3'])
            >>> c2 = c1.annotateIntervals(inPlace = False)
            >>> c2.lyrics
            [<music21.note.Lyric number=1 syllabic=single text="8">, <music21.note.Lyric number=2 syllabic=single text="5">, <music21.note.Lyric number=3 syllabic=single text="3">]
            >>> [l.text for l in c2.lyrics]
            ['8', '5', '3']


            The `stripSpecifiers` parameter can be used to show only the intervals size (3, 5, etc)
            or the complete interval specification (m3, P5, etc.)




            >>> c3 = c1.annotateIntervals(inPlace = False, stripSpecifiers = False)
            >>> c3.lyrics
            [<music21.note.Lyric number=1 syllabic=single text="P8">, <music21.note.Lyric number=2 syllabic=single text="P5">, <music21.note.Lyric number=3 syllabic=single text="M3">]
            >>> [l.text for l in c3.lyrics]
            ['P8', 'P5', 'M3']


            This chord was giving us problems:



            >>> c4 = chord.Chord(['G4', 'E4', 'B3', 'E3'])
            >>> c4.annotateIntervals(stripSpecifiers = False)
            >>> [l.text for l in c4.lyrics]
            ['m3', 'P8', 'P5']


            If sortPitches is false it still gives problems...




            >>> c4 = chord.Chord(['G4', 'E4', 'B3', 'E3'])
            >>> c4.annotateIntervals(stripSpecifiers = False, sortPitches = False)
            >>> [l.text for l in c4.lyrics]
            ['m3', 'm6', 'm3']







            >>> c = chord.Chord(['c4', 'd-4', 'g4'])
            >>> c.annotateIntervals()
            >>> [l.text for l in c.lyrics]
            ['5', '2']
            ⁠ 
            >>> c = chord.Chord(['c4', 'd-4', 'g4'])
            >>> c.annotateIntervals(stripSpecifiers=False)
            >>> [l.text for l in c.lyrics]
            ['P5', 'm2']



            >>> c = chord.Chord(['c4', 'd---4', 'g4'])
            >>> c.annotateIntervals(stripSpecifiers=False)
            >>> [l.text for l in c.lyrics]
            ['P5', 'dd2']






        .. method:: areZRelations(other)

            Check of chord other is also a z relations



            >>> from music21 import *
            >>> c1 = chord.Chord(["C", "c#", "e", "f#"])
            >>> c2 = chord.Chord(["C", "c#", "e-", "g"])
            >>> c3 = chord.Chord(["C", "c#", "f#", "g"])
            >>> c1.areZRelations(c2)
            True
            >>> c1.areZRelations(c3)
            False



        .. method:: bass(newbass=0)

            returns the bass Pitch or sets it to the given Pitch.
            example:




            >>> from music21 import *
            >>> cmaj1stInv = chord.Chord(['C4', 'E3', 'G5'])
            >>> cmaj1stInv.bass()
            E3


            The bass is usually defined to the lowest note in the chord,
            but we want to be able to override this.  You might want an implied
            bass for instance some people (following the music theorist
            Rameau) call a diminished seventh chord (vii7)
            a dominant chord with a omitted bass -- here we will specify the bass
            to be a note not in the chord:




            >>> vo9 = chord.Chord(['B3', 'D4', 'F4', 'A-4'])
            >>> vo9.bass()
            B3
            >>> vo9.bass(pitch.Pitch('G3'))
            >>> vo9.bass()
            G3





        .. method:: canBeDominantV()


            Returns True if the chord is a Major Triad or a Dominant Seventh



            >>> from music21 import *
            >>> a = chord.Chord(['g', 'b', 'd', 'f'])
            >>> a.canBeDominantV()
            True



        .. method:: canBeTonic()


            returns True if the chord is a major or minor triad



            >>> from music21 import *
            >>> a = chord.Chord(['g', 'b', 'd', 'f'])
            >>> a.canBeTonic()
            False
            >>> a = chord.Chord(['g', 'b', 'd'])
            >>> a.canBeTonic()
            True



        .. method:: closedPosition(forceOctave=None, inPlace=False, leaveRedundantPitches=False)

            Returns a new Chord object with the same pitch classes,
            but now in closed position.

            If `forcedOctave` is provided, the bass of the chord will
            be shifted to that provided octave.

            If inPlace is True then the original chord is returned with new pitches.



            >>> from music21 import *
            >>> chord1 = chord.Chord(["C#4", "G5", "E6"])
            >>> chord2 = chord1.closedPosition()
            >>> chord2
            <music21.chord.Chord C#4 E4 G4>


            Force octave changes the octave of the bass note (and all notes above it...)



            >>> c2 = chord.Chord(["C#4", "G5", "E6"])
            >>> str(c2.closedPosition(forceOctave = 2).pitches)
            '[C#2, E2, G2]'
            ⁠ 
            >>> c3 = chord.Chord(["C#4", "G5", "E6"])
            >>> str(c3.closedPosition(forceOctave = 6).pitches)
            '[C#6, E6, G6]'



            Redundant pitches are removed by default, but can be retained...



            >>> c4 = chord.Chord(["C#4", "C5", "F7", "F8"])
            >>> c5 = c4.closedPosition(4, inPlace = False)
            >>> str(c5.pitches)
            '[C#4, F4, C5]'
            >>> c6 = c4.closedPosition(4, inPlace = False, leaveRedundantPitches=True)
            >>> str(c6.pitches)
            '[C#4, F4, F4, C5]'


            Implicit octaves work fine...



            >>> c7 = chord.Chord(["A4", "B4", "A"])
            >>> c7.closedPosition(4, inPlace = True)
            >>> str(c7.pitches)
            '[A4, B4]'



        .. method:: containsSeventh()


            Returns True if the chord contains at least one of each of Third, Fifth, and Seventh.
            raises an exception if the Root can't be determined




            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E', 'G', 'B'])
            >>> other = chord.Chord(['C', 'D', 'E', 'F', 'G', 'B'])
            >>> cchord.containsSeventh() # returns True
            True
            >>> other.containsSeventh() # returns True
            True



        .. method:: containsTriad()

            returns True or False if there is no triad above the root.
            "Contains vs. Is": A dominant-seventh chord contains a triad.

            example:



            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E', 'G'])
            >>> other = chord.Chord(['C', 'D', 'E', 'F', 'G'])
            >>> cchord.containsTriad() #returns True
            True
            >>> other.containsTriad() #returns True
            True
            >>> scale = chord.Chord(['C', 'D-', 'E', 'F#', 'G', 'A#', 'B'])
            >>> scale.containsTriad() #returns True
            True



        .. method:: findRoot()

            Looks for the root by finding the note with the most 3rds above it
                   Generally use root() instead, since if a chord doesn't know its root, root() will
                   run findRoot() automatically.

                   example:
                   >>> from music21 import *
                   >>> cmaj = chord.Chord(['E', 'G', 'C'])
                   >>> cmaj.findRoot() # returns C
                   C



        .. method:: getChordStep(chordStep, testRoot=None)


            Returns the (first) pitch at the
            provided scaleDegree (Thus, it's exactly like semitonesFromChordStep, except it
            instead of the number of semitones.)

            Returns None if none can be found.

            Example:



            >>> from music21 import *
            >>> cmaj = chord.Chord(['C','E','G#'])
            >>> cmaj.getChordStep(3) # will return the third of the chord
            E
            >>> gis = cmaj.getChordStep(5) # will return the fifth of the chord
            >>> gis.name
            'G#'
            >>> print cmaj.getChordStep(6)
            None



        .. method:: getColor(pitchTarget)

            For a pitch in this Chord, return the color stored in self.editorial, or, if set for each component, return the color assigned to this component.



        .. method:: getNotehead(p)

            Given a pitch in this Chord, return an associated notehead attribute, or return 'normal' if not defined for that Pitch.

            If the pitch is not found, None will be returned.




            >>> from music21 import *
            >>> n1 = note.Note('D4')
            >>> n2 = note.Note('G4')
            >>> n2.notehead = 'diamond'
            >>> c1 = chord.Chord([n1, n2])
            >>> c1.getNotehead(c1.pitches[1])
            'diamond'
            >>> c1.getNotehead(c1.pitches[0])
            'normal'
            >>> c1.getNotehead(pitch.Pitch('A#6')) is None
            True




        .. method:: getStemDirection(p)

            Given a pitch in this Chord, return an associated stem attribute, or return 'unspecified' if not defined for that Pitch.


            If the pitch is not found, None will be returned.




            >>> from music21 import *
            >>> n1 = note.Note('D4')
            >>> n2 = note.Note('G4')
            >>> n2.stemDirection = 'double'
            >>> c1 = chord.Chord([n1, n2])
            >>> c1.getStemDirection(c1.pitches[1])
            'double'
            >>> c1.getStemDirection(c1.pitches[0])
            'unspecified'



        .. method:: getTie(p)


            Given a pitch in this Chord, return an
            associated Tie object, or return None
            if not defined for that Pitch.



            >>> from music21 import *
            >>> c1 = chord.Chord(['d', 'e-', 'b-'])
            >>> t1 = tie.Tie('start')
            >>> c1.setTie(t1, c1.pitches[2]) # just to b-
            >>> c1.getTie(c1.pitches[2]) == t1
            True
            >>> c1.getTie(c1.pitches[0]) == None
            True



        .. method:: getVolume(p)

            For a given Pitch in this Chord, return the :class:`~music21.volume.Volume` object.



        .. method:: getZRelation()

            Return a Z relation if it exists, otherwise return None.



            >>> from music21 import *
            >>> chord.fromIntervalVector((1,1,1,1,1,1))
            <music21.chord.Chord C C# E F#>
            >>> chord.fromIntervalVector((1,1,1,1,1,1)).getZRelation()
            <music21.chord.Chord C C# E- G>



        .. method:: hasAnyRepeatedDiatonicNote(testRoot=None)

            Returns True if for any diatonic note (e.g., C or C# = C) there are two or more
            different notes (such as E and E-) in the chord. If there are no repeated
            scale degrees, return false.

            example:



            >>> from music21 import *
            >>> cchord = chord.Chord (['C', 'E', 'E-', 'G'])
            >>> other = chord.Chord (['C', 'E', 'F-', 'G'])
            >>> cchord.hasAnyRepeatedDiatonicNote()
            True
            >>> other.hasAnyRepeatedDiatonicNote() # returns false (chromatically identical notes of different scale degrees do not count).
            False



        .. method:: hasComponentVolumes()

            Utility method to determine if this object has component :class:`~music21.volume.Volume` objects assigned to each note-component.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c4', 'd-1', 'g6'])
            >>> c1.volume = [60, 20, 120]
            >>> [n.volume.velocity for n in c1]
            [60, 20, 120]
            >>> c1.hasComponentVolumes()
            True
            >>> c2 = chord.Chord(['c4', 'd-1', 'g6'])
            >>> c2.volume.velocity = 23
            >>> c2.hasComponentVolumes()
            False
            ⁠ 
            >>> c3 = chord.Chord(['c4', 'd-1', 'g6'])
            >>> c3.volume = [.2, .5, .8]
            >>> [n.volume.velocity for n in c3]
            [25, 64, 102]



            >>> c4 = chord.Chord(['c4', 'd-1', 'g6'])
            >>> c4.volume = 89
            >>> c4.volume.velocity
            89
            >>> c4.hasComponentVolumes()
            False



        .. method:: hasRepeatedChordStep(chordStep, testRoot=None)

            Returns True if chordStep above testRoot (or self.root()) has two
            or more different notes (such as E and E-) in it.  Otherwise
            returns false.

            example:




            >>> from music21 import *
            >>> cchord = chord.Chord (['G2', 'E4', 'E-5', 'C6'])
            >>> cchord.hasRepeatedChordStep(3)
            True
            >>> cchord.hasRepeatedChordStep(5)
            False



        .. method:: intervalFromChordStep(chordStep, testRoot=None)

            Exactly like semitonesFromChordStep, except it returns the interval itself instead of the number
            of semitones.

            example:




            >>> from music21 import *
            >>> cmaj = chord.Chord(['C', 'E', 'G'])
            >>> cmaj.intervalFromChordStep(3) #will return the interval between C and E
            <music21.interval.Interval M3>
            >>> cmaj.intervalFromChordStep(5) #will return the interval between C and G
            <music21.interval.Interval P5>
            >>> print cmaj.intervalFromChordStep(6)
            None



        .. method:: inversion()

            returns an integer representing which inversion (if any) the chord is in. Chord
                   does not have to be complete, but determines the inversion by looking at the relationship
                   of the bass note to the root. Returns max value of 5 for inversion of a thirteenth chord.
                   Returns 0 if bass to root interval is 1 or if interval is not a common inversion (1st-5th).
                   Octave of bass and root are irrelevant to this calculation of inversion.

                   Method doesn't check to see if inversion is reasonable according to the chord provided
                   (if only two pitches given, an inversion is still returned)
                   see :meth:`~music21.harmony.ChordSymbol.inversionIsValid` for checker method on ChordSymbolObjects.

                   >>> from music21 import *
                   >>> a = chord.Chord(['g', 'b', 'd', 'f'])
                   >>> a.inversion()
                   2
                   >>> CTriad1stInversion = chord.Chord(['E1', 'G1', 'C2'])
                   >>> CTriad1stInversion.inversion()
                   1
                   >>> CTriad2ndInversion = chord.Chord(['G1', 'E2', 'C2'])
                   >>> CTriad2ndInversion.inversion()
                   2
                   >>> DSeventh3rdInversion = chord.Chord(['C', 'B'])
                   >>> DSeventh3rdInversion.bass(pitch.Pitch('B4'))
                   >>> DSeventh3rdInversion.inversion()
                   3
                   >>> GNinth4thInversion = chord.Chord(['G', 'B', 'D', 'F', 'A'])
                   >>> GNinth4thInversion.bass(pitch.Pitch('A4'))
                   >>> GNinth4thInversion.inversion()
                   4
                   >>> BbEleventh5thInversion = chord.Chord(['B-','D','F','A','C','E-'])
                   >>> BbEleventh5thInversion.bass(pitch.Pitch('E-4'))
                   >>> BbEleventh5thInversion.inversion()
                   5



        .. method:: inversionName()


            Returns an integer representing the common abbreviation
            for the inversion the chord is in.
            If chord is not in a common inversion, returns None.

            Third inversion sevenths return 42 not 2



            >>> from music21 import *
            >>> a = chord.Chord(['G3', 'B3', 'F3', 'D3'])
            >>> a.inversionName()
            43



        .. method:: isAugmentedSixth()


            returns True if the chord is an Augmented 6th chord in first inversion.
            (N.B. a French/Swiss sixth technically needs to be in second inversion)



            >>> from music21 import *
            >>> c = chord.Chord(['A-3','C4','E-4','F#4'])
            >>> c.isAugmentedSixth()
            True
            >>> c.pitches[3].getEnharmonic(inPlace = True)
            >>> c.pitches
            [A-3, C4, E-4, G-4]
            >>> c.isAugmentedSixth()
            False




        .. method:: isAugmentedTriad()

            Returns True if chord is an Augmented Triad, that is, if it contains only notes that are
            either in unison with the root, a major third above the root, or an augmented fifth above the
            root. Additionally, must contain at least one of each third and fifth above the root.
            Chord might NOT seem to have to be spelled correctly because incorrectly spelled Augmented Triads are
            usually augmented triads in some other inversion (e.g. C-E-Ab is a 2nd inversion aug triad; C-Fb-Ab
            is 1st inversion).  However, B#-Fb-Ab does return False as expeccted).

            Returns false if is not an augmented triad.



            >>> import music21.chord
            >>> c = music21.chord.Chord(["C4", "E4", "G#4"])
            >>> c.isAugmentedTriad()
            True
            >>> c = music21.chord.Chord(["C4", "E4", "G4"])
            >>> c.isAugmentedTriad()
            False

            Other spellings will give other roots!
            >>> c = music21.chord.Chord(["C4", "E4", "A-4"])
            >>> c.isAugmentedTriad()
            True
            >>> c.root()
            A-4



            >>> c = music21.chord.Chord(["C4", "F-4", "A-4"])
            >>> c.isAugmentedTriad()
            True
            >>> c = music21.chord.Chord(["B#4", "F-4", "A-4"])
            >>> c.isAugmentedTriad()
            False



        .. method:: isConsonant()


            returns True if the chord is
                 one pitch
                 two pitches: uses :meth:`~music21.interval.Interval.isConsonant()` , which
                 checks if interval is a major or minor third or sixth or perfect fifth.
                 three pitches: if chord is a major or minor triad not in second inversion.

            These rules define all common-practice consonances (and earlier back to about 1300 all imperfect consonances)



            >>> from music21 import *
            >>> c1 = chord.Chord(['C3', 'E4', 'G5'])
            >>> c1.isConsonant()
            True
            >>> c2 = chord.Chord(['G3', 'E-4', 'C5'])
            >>> c2.isConsonant()
            False
            >>> c3 = chord.Chord(['F2','A2','C3','E-3'])
            >>> c3.isConsonant()
            False
            >>> c4 = chord.Chord(['C1','G1','C2','G2','C3','G3'])
            >>> c4.isConsonant()
            True
            >>> c5 = chord.Chord(['G1','C2','G2','C3','G3'])
            >>> c5.isConsonant()
            False
            >>> c6 = chord.Chord(['F#'])
            >>> c6.isConsonant()
            True
            >>> c7 = chord.Chord(['C1','C#1','D-1'])
            >>> c7.isConsonant()
            False


            Spelling does matter




            >>> c8 = chord.Chord(['D-4','G#4'])
            >>> c8.isConsonant()
            False
            >>> c9 = chord.Chord(['D3','A2','D2','D2','A4'])
            >>> c9.isConsonant()
            True
            >>> c10 = chord.Chord(['D3','A2','D2','D2','A1'])
            >>> c10.isConsonant()
            False
            ⁠ 
            >>> c11 = chord.Chord(['F3','D4','A4'])
            >>> c11.isConsonant()
            True
            >>> c12 = chord.Chord(['F3','D4','A4','E#4'])
            >>> c12.isConsonant()
            False




        .. method:: isDiminishedSeventh()

            Returns True if chord is a Diminished Seventh, that is, if it contains only notes that are
            either in unison with the root, a minor third above the root, a diminished fifth, or a minor seventh
            above the root. Additionally, must contain at least one of each third and fifth above the root.
            Chord must be spelled correctly. Otherwise returns false.



            >>> from music21 import *
            >>> a = chord.Chord(['c', 'e-', 'g-', 'b--'])
            >>> a.isDiminishedSeventh()
            True



        .. method:: isDiminishedTriad()

            Returns True if chord is a Diminished Triad, that is, if it contains only notes that are
            either in unison with the root, a minor third above the root, or a diminished fifth above the
            root. Additionally, must contain at least one of each third and fifth above the root.
            Chord must be spelled correctly. Otherwise returns false.



            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E-', 'G-'])
            >>> other = chord.Chord(['C', 'E-', 'F#'])
            ⁠ 
            >>> cchord.isDiminishedTriad() #returns True
            True
            >>> other.isDiminishedTriad() #returns False
            False



        .. method:: isDominantSeventh()

            Returns True if chord is a Dominant Seventh, that is, if it contains only notes that are
            either in unison with the root, a major third above the root, a perfect fifth, or a major seventh
            above the root. Additionally, must contain at least one of each third and fifth above the root.
            Chord must be spelled correctly. Otherwise returns false.



            >>> from music21 import *
            >>> a = chord.Chord(['b', 'g', 'd', 'f'])
            >>> a.isDominantSeventh()
            True



        .. method:: isFalseDiminishedSeventh()

            Returns True if chord is a Diminished Seventh, that is, if it contains only notes that are
            either in unison with the root, a minor third above the root, a diminished fifth, or a minor seventh
            above the root. Additionally, must contain at least one of each third and fifth above the root.
            Chord MAY BE SPELLED INCORRECTLY. Otherwise returns false.



        .. method:: isFrenchAugmentedSixth()


            Returns True if the chord is a French augmented sixth chord
            (flat 6th scale degree in bass, tonic, second scale degree, and raised 4th).


            N.B. The findRoot() method of music21.chord Chord determines
            the root based on the note with
            the most thirds above it. However, under this definition, a
            1st-inversion french augmented sixth chord
            resembles a second inversion chord, not the first inversion
            subdominant chord it is based
            upon. We fix this by adjusting the root. First, however, we
            check to see if the chord is
            in second inversion to begin with, otherwise its not
            a Fr+6 chord. This is to avoid ChordException errors.




            >>> from music21 import *
            >>> fr6a = chord.Chord(['A-3','C4','D4','F#4'])
            >>> fr6a.isFrenchAugmentedSixth()
            True
            >>> fr6b = chord.Chord(['A-3','C4','E--4','F#4'])
            >>> fr6b.isFrenchAugmentedSixth()
            False




        .. method:: isGermanAugmentedSixth()

            No documentation.


        .. method:: isHalfDiminishedSeventh()

            Returns True if chord is a Half Diminished Seventh, that is, if it contains only notes that are
            either in unison with the root, a minor third above the root, a diminished fifth, or a major seventh
            above the root. Additionally, must contain at least one of each third, fifth, and seventh above the root.
            Chord must be spelled correctly. Otherwise returns false.



            >>> from music21 import *
            >>> c1 = chord.Chord(['C4','E-4','G-4','B-4'])
            >>> c1.isHalfDiminishedSeventh()
            True

            Incorrectly spelled chords are not considered half-diminished sevenths
            >>> c2 = chord.Chord(['C4','E-4','G-4','A#4'])
            >>> c2.isHalfDiminishedSeventh()
            False

            Nor are incomplete chords


            >>> c3 = chord.Chord(['C4', 'G-4','B-4'])
            >>> c3.isHalfDiminishedSeventh()
            False



        .. method:: isIncompleteMajorTriad()


            Returns True if the chord is an incomplete Major triad, or, essentially,
            a dyad of root and major third



            >>> from music21 import *
            >>> c1 = chord.Chord(['C4','E3'])
            >>> c1.isMajorTriad()
            False
            >>> c1.isIncompleteMajorTriad()
            True


            Note that complete major triads return False:




            >>> c2 = chord.Chord(['C4','E3', 'G5'])
            >>> c2.isIncompleteMajorTriad()
            False



        .. method:: isIncompleteMinorTriad()


            returns True if the chord is an incomplete Minor triad, or, essentially,
            a dyad of root and minor third



            >>> from music21 import *
            >>> c1 = chord.Chord(['C4','E-3'])
            >>> c1.isMinorTriad()
            False
            >>> c1.isIncompleteMinorTriad()
            True
            >>> c2 = chord.Chord(['C4','E-3', 'G5'])
            >>> c2.isIncompleteMinorTriad()
            False



        .. method:: isItalianAugmentedSixth(restrictDoublings=False)


            Returns true if the chord is a properly spelled Italian augmented sixth chord in
            first inversion.


            If restrictDoublings is set to True then only the tonic may be doubled.




            >>> from music21 import *
            >>> c1 = chord.Chord(['A-4','C5','F#6'])
            >>> c1.isItalianAugmentedSixth()
            True


            Spelling and inversions matter




            >>> c2 = chord.Chord(['A-4','C5','G-6'])
            >>> c2.isItalianAugmentedSixth()
            False
            >>> c3 = chord.Chord(['F#4','C5','A-6'])
            >>> c3.isItalianAugmentedSixth()
            False


            If doubling rules are turned on then only the tonic can be doubled:




            >>> c4 = chord.Chord(['A-4','C5','F#6', 'C6', 'C7'])
            >>> c4.isItalianAugmentedSixth(restrictDoublings = True)
            True
            >>> c5 = chord.Chord(['A-4','C5','F#6', 'C5', 'F#7'])
            >>> c5.isItalianAugmentedSixth(restrictDoublings = True)
            False
            >>> c5.isItalianAugmentedSixth(restrictDoublings = False)
            True



        .. method:: isMajorTriad()


            Returns True if chord is a Major Triad, that is, if it contains only notes that are
            either in unison with the root, a major third above the root, or a perfect fifth above the
            root. Additionally, must contain at least one of each third and fifth above the root.
            Chord must be spelled correctly. Otherwise returns false.

            Example:



            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E', 'G'])
            >>> other = chord.Chord(['C', 'G'])
            >>> cchord.isMajorTriad() # returns True
            True
            >>> other.isMajorTriad() # returns False
            False



        .. method:: isMinorTriad()


            Returns True if chord is a Minor Triad, that is, if it contains only notes that are
            either in unison with the root, a minor third above the root, or a perfect fifth above the
            root. Additionally, must contain at least one of each third and fifth above the root.
            Chord must be spelled correctly. Otherwise returns false.

            Example:



            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E-', 'G'])
            >>> other = chord.Chord(['C', 'E', 'G'])
            >>> cchord.isMinorTriad() # returns True
            True
            >>> other.isMinorTriad() # returns False
            False



        .. method:: isSeventh()


            Returns True if chord contains at least one of each of Third, Fifth, and Seventh,
            and every note in the chord is a Third, Fifth, or Seventh, such that there are no
            repeated scale degrees (ex: E and E-). Else return false.

            Example:



            >>> from music21 import *
            >>> cchord = chord.Chord(['C', 'E', 'G', 'B'])
            >>> other = chord.Chord(['C', 'D', 'E', 'F', 'G', 'B'])
            >>> cchord.isSeventh() # returns True
            True
            >>> other.isSeventh() # returns False
            False



        .. method:: isSwissAugmentedSixth()


            Returns true is it is a respelled German augmented 6th chord with
            sharp 2 instead of flat 3.  This chord has many names,
            Swiss Augmented Sixth, Alsatian Chord, English A6, Norwegian, etc.
            as well as doubly-augmented sixth, which is a bit of a misnomer since
            it is the 4th that is doubly augmented, not the sixth.



        .. method:: isTriad()

            returns True or False
            "Contains vs. Is:" A dominant-seventh chord is NOT a triad.
            returns True if the chord contains at least one Third and one Fifth and all notes are
            equivalent to either of those notes. Only returns True if triad is spelled correctly.

            example:



            >>> from music21 import *
            >>> cchord = chord.Chord(['C4', 'E4', 'A4'])
            >>> other = chord.Chord(['C', 'D', 'E', 'F', 'G'])
            >>> cchord.isTriad() # returns True
            True
            >>> other.isTriad()
            False
            >>> incorrectlySpelled = chord.Chord(['C','D#','G'])
            >>> incorrectlySpelled.isTriad()
            False
            >>> incorrectlySpelled.pitches[1].getEnharmonic(inPlace = True)
            >>> incorrectlySpelled.isTriad()
            True



        .. method:: removeRedundantPitchClasses(inPlace=True)

            Remove all but the FIRST instance of a pitch class with more than one instance of that pitch class.

            If `inPlace` is True, a copy is not made and None is returned; otherwise a copy is made and that
            copy is returned.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c2', 'e3', 'g4', 'e3'])
            >>> c1.removeRedundantPitchClasses(inPlace=True)
            >>> c1.pitches
            [C2, G4, E3]
            ⁠ 
            >>> c2 = chord.Chord(['c5', 'e3', 'g4', 'c2', 'e3', 'f-4'])
            >>> c2.removeRedundantPitchClasses(inPlace=True)
            >>> c2.pitches
            [C5, G4, E3]




        .. method:: removeRedundantPitchNames(inPlace=True)

            Remove all but the FIRST instance of a pitch class with more than one instance of that pitch name
            regardless of octave (but note that spelling matters, so that in the example, the F-flat stays even
            though there is already an E.)

            If `inPlace` is True, a copy is not made and None is returned; otherwise a copy is made and that
            copy is returned.



            >>> from music21 import *
            >>> c2 = chord.Chord(['c5', 'e3', 'g4', 'c2', 'e3', 'f-4'])
            >>> c2.removeRedundantPitchNames(inPlace = True)
            >>> c2.pitches
            [C5, G4, E3, F-4]




        .. method:: removeRedundantPitches(inPlace=True)


            Remove all but one instance of a pitch that appears twice.
            It removes based on the name of the note and the octave, so the same note name in two different
            octaves is retained.

            If `inPlace` is True, a copy is not made and None is returned; otherwise a copy is made and that copy is returned.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c2', 'e3', 'g4', 'e3'])
            >>> c1.removeRedundantPitches(inPlace=True)
            >>> c1.pitches
            [C2, G4, E3]
            >>> c1.forteClass
            '3-11B'
            ⁠ 
            >>> c2 = chord.Chord(['c2', 'e3', 'g4', 'c5'])
            >>> c2c = c2.removeRedundantPitches(inPlace=False)
            >>> c2c.pitches
            [C2, E3, G4, C5]


            It is a known bug that because pitch.nameWithOctave gives
            the same value for B-flat in octave 1 as B-natural in octave
            negative 1, negative octaves can screw up this method.
            With all the things left to do for music21, it doesn't seem
            a bug worth squashing at this moment, but FYI:



            >>> p1 = pitch.Pitch('B-')
            >>> p1.octave = 1
            >>> p2 = pitch.Pitch('B')
            >>> p2.octave = -1
            >>> c3 = chord.Chord([p1, p2])
            >>> c3.removeRedundantPitches(inPlace=True)
            >>> c3.pitches
            [B-1]


            The first pitch survives:



            >>> c3.pitches[0] is p1
            True
            >>> c3.pitches[0] is p2
            False




        .. method:: root(newroot=False)

            Returns or sets the Root of the chord.  if not set, will run findRoot (q.v.)

            example:




            >>> from music21 import *
            >>> cmaj = chord.Chord(['E3', 'C4', 'G5'])
            >>> cmaj.root()
            C4



        .. method:: seekChordTablesAddress()

            Utility method to return the address to the chord table.

            Table addresses are TN based three character codes:
            cardinaltiy, Forte index number, inversion

            Inversion is either 0 (for symmetrical) or -1/1

            NOTE: time consuming, and only should be run when necessary.



            >>> from music21 import *
            >>> c1 = chord.Chord(['c3'])
            >>> c1.orderedPitchClasses
            [0]
            >>> c1.seekChordTablesAddress()
            (1, 1, 0)
            ⁠ 
            >>> c1 = chord.Chord(['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'b'])
            >>> c1.seekChordTablesAddress()
            (11, 1, 0)



            >>> c1 = chord.Chord(['c', 'e', 'g'])
            >>> c1.seekChordTablesAddress()
            (3, 11, -1)
            ⁠ 
            >>> c1 = chord.Chord(['c', 'e-', 'g'])
            >>> c1.seekChordTablesAddress()
            (3, 11, 1)



            >>> c1 = chord.Chord(['c', 'c#', 'd#', 'e', 'f#', 'g#', 'a#'])
            >>> c1.seekChordTablesAddress()
            (7, 34, 0)
            ⁠ 
            >>> c1 = chord.Chord(['c', 'c#', 'd'])
            >>> c1.seekChordTablesAddress()
            (3, 1, 0)



        .. method:: semiClosedPosition(forceOctave=None, inPlace=False, leaveRedundantPitches=False)


            Similar to :meth:`~music21.chord.Chord.ClosedPosition` in that it
            moves everything within an octave EXCEPT if there's already
            a pitch at that step, then it puts it up an octave.  It's a
            very useful display standard for dense post-tonal chords.



            >>> from music21 import *
            >>> c1 = chord.Chord(['C3','E5','C#6','E-7', 'G8','C9','E#9'])
            >>> c2 = c1.semiClosedPosition(inPlace=False)
            >>> c2.pitches
            [C3, E-3, G3, C#4, E4, E#5]

            `leaveRedundantPitches` still works, and gives them a new octave!



            >>> c3 = c1.semiClosedPosition(inPlace=False, leaveRedundantPitches=True)
            >>> c3.pitches
            [C3, E-3, G3, C4, E4, C#5, E#5]

            of course `forceOctave` still works, as does `inPlace=True`.



            >>> c1.semiClosedPosition(forceOctave=2, inPlace=True, leaveRedundantPitches=True)
            >>> c1.pitches
            [C2, E-2, G2, C3, E3, C#4, E#4]




        .. method:: semitonesFromChordStep(chordStep, testRoot=None)


            Returns the number of semitones (mod12) above the root
            that the chordStep lies (i.e., 3 = third of the chord; 5 = fifth, etc.)
            if one exists.  Or None if it does not exist.

            You can optionally specify a note.Note object to try as the root.  It does
            not change the Chord.root object.  We use these methods to figure out
            what the root of the triad is.

            Currently there is a bug that in the case of a triply diminished
            third (e.g., "c" => "e----"), this function will incorrectly claim
            no third exists.  Perhaps this should be construed as a feature.

            In the case of chords such as C, E-, E, semitonesFromChordStep(3)
            will return the number for the first third, in this case 3.  It
            will not return 4, nor a list object (3,4).  You probably do not
            want to be using tonal chord manipulation functions on chords such
            as these anyway.  Check for such cases with
            chord.hasAnyRepeatedDiatonicNote first.

            Tools with the expression "chordStep" in them refer to the diatonic
            third, fifth, etc., of the chord.  They have little to do with
            the scale degree of the scale or key that the chord is embedded
            within.  See "chord.scaleDegrees" for this functionality.


            example:




            >>> from music21 import *
            >>> cchord = chord.Chord(['E3', 'C4', 'G5'])
            >>> cchord.semitonesFromChordStep(3) # distance from C to E
            4
            >>> cchord.semitonesFromChordStep(5) # C to G
            7
            >>> print cchord.semitonesFromChordStep(6) # will return None
            None
            ⁠ 
            >>> achord = chord.Chord(['a2', 'c4', 'c#5', 'e#7'])
            >>> achord.semitonesFromChordStep(3) # returns the semitones to the FIRST third.
            3
            >>> achord.semitonesFromChordStep(5)
            8
            >>> print achord.semitonesFromChordStep(2) # will return None
            None




        .. method:: setColor(value, pitchTarget=None)

            Set color for specific pitch



        .. method:: setNotehead(nh, pitchTarget)

            Given a notehead attribute as a string and a pitch object in this Chord, set the notehead attribute of that pitch to the value of that notehead. Valid notehead type names are found in note.noteheadTypeNames (see below):



            >>> from music21 import *
            >>> note.noteheadTypeNames
            ['slash', 'triangle', 'diamond', 'square', 'cross', 'x', 'circle-x', 'inverted triangle', 'arrow down', 'arrow up', 'slashed', 'back slashed', 'normal', 'cluster', 'none', 'do', 're', 'mi', 'fa', 'so', 'la', 'ti', 'circle dot', 'left triangle', 'rectangle']
            ⁠ 
            >>> n1 = note.Note('D4')
            >>> n2 = note.Note('G4')
            >>> c1 = chord.Chord([n1, n2])
            >>> c1.setNotehead('diamond', c1.pitches[1]) # just to g
            >>> c1.getNotehead(c1.pitches[1])
            'diamond'
            >>> c1.getNotehead(c1.pitches[0])
            'normal'

            If a chord has two of the same pitch, but each associated with a different notehead, then
            object equality must be used to distinguish between the two.




            >>> c2 = chord.Chord(['D4','D4'])
            >>> secondD4 = c2.pitches[1]
            >>> c2.setNotehead('diamond', secondD4)
            >>> for i in [0,1]:
            ...    print c2.getNotehead(c2.pitches[i])
            normal
            diamond




        .. method:: setStemDirection(stem, pitchTarget)

            Given a stem attribute as a string and a pitch object in this Chord, set the stem attribute of that pitch to the value of that stem. Valid stem directions are found note.stemDirectionNames (see below).



            >>> from music21 import *
            >>> note.stemDirectionNames
            ['up', 'down', 'noStem', 'double', 'unspecified', 'none']
            ⁠ 
            >>> n1 = note.Note('D4')
            >>> n2 = note.Note('G4')
            >>> c1 = chord.Chord([n1, n2])
            >>> c1.setStemDirection('double', c1.pitches[1]) # just to g
            >>> c1.getStemDirection(c1.pitches[1])
            'double'
            >>> c1.getStemDirection(c1.pitches[0])
            'unspecified'

            If a chord has two of the same pitch, but each associated with a different stem, then
            object equality must be used to distinguish between the two.




            >>> c2 = chord.Chord(['D4','D4'])
            >>> secondD4 = c2.pitches[1]
            >>> c2.setStemDirection('double', secondD4)
            >>> for i in [0,1]:
            ...    print c2.getStemDirection(c2.pitches[i])
            unspecified
            double




        .. method:: setTie(t, pitchTarget)

            Given a tie object (or a tie type string) and a pitch in this Chord,
            set the pitch's tie attribute in this chord to that tie type.




            >>> from music21 import *
            >>> c1 = chord.Chord(['d3', 'e-4', 'b-4'])
            >>> t1 = tie.Tie('start')
            >>> c1.setTie(t1, 'b-4') # or it can be done with a pitch.Pitch object
            >>> c1.getTie(c1.pitches[2]) == t1
            True



            Setting a tie with a chord with the same pitch twice requires
            getting the exact pitch object out to be sure which one...




            >>> c2 = chord.Chord(['D4','D4'])
            >>> secondD4 = c2.pitches[1]
            >>> c2.setTie('start', secondD4)
            >>> for i in [0,1]:
            ...    print c2.getTie(c2.pitches[i])
            None
            <music21.tie.Tie start>




        .. method:: setVolume(vol, pitchTarget=None)

            Set the :class:`~music21.volume.Volume` object of a specific pitch target. If no pitch target is given, the first pitch is used.



            >>> from music21 import *



        .. method:: sortAscending(inPlace=False)

            No documentation.


        .. method:: sortChromaticAscending()


            Same as sortAscending but notes are sorted by midi number, so F## sorts above G-.



        .. method:: sortDiatonicAscending(inPlace=False)


            The notes are sorted by Scale degree and then by Offset (so F## sorts below G-).
            Notes that are the identical pitch retain their order

            After talking with Daniel Jackson, let's try to make the chord object as immutable
            as possible, so we return a new Chord object with the notes arranged from lowest to highest




            >>> from music21 import *
            >>> cMajUnsorted = chord.Chord(['E4', 'C4', 'G4'])
            >>> cMajSorted = cMajUnsorted.sortDiatonicAscending()
            >>> cMajSorted.pitches[0].name
            'C'
            ⁠ 
            >>> c2 = chord.Chord(['E4', 'C4', 'G4'])
            >>> junk = c2.sortDiatonicAscending(inPlace=True)
            >>> c2
            <music21.chord.Chord C4 E4 G4>



        .. method:: sortFrequencyAscending()


            Same as above, but uses a note's frequency to determine height; so that
            C# would be below D- in 1/4-comma meantone, equal in equal temperament,
            but below it in (most) just intonation types.



        .. method:: transpose(value, inPlace=False)

            Transpose the Note by the user-provided value. If the value
            is an integer, the transposition is treated in half steps and
            enharmonics might be simplified (not done yet). If the value is a
            string, any Interval string specification can be provided.


            If inPlace is set to True (default = False) then the original
            chord is changed.  Otherwise a new Chord is returned.


            We take a three-note chord (G, A, C#) and transpose it up a minor third,
            getting the chord B-flat, C, E.




            >>> from music21 import *
            >>> a = chord.Chord(['g4', 'a3', 'c#6'])
            >>> b = a.transpose('m3')
            >>> b
            <music21.chord.Chord B-4 C4 E6>


            Here we create the interval object first (rather than giving
            a string) and specify transposing down six semitones, instead
            of saying A-4.




            >>> aInterval = interval.Interval(-6)
            >>> b = a.transpose(aInterval)
            >>> b
            <music21.chord.Chord C#4 D#3 F##5>


            If `inPlace` is True then rather than returning a new chord, the
            chord itself is changed.




            >>> a.transpose(aInterval, inPlace=True)
            >>> a
            <music21.chord.Chord C#4 D#3 F##5>



        Methods inherited from :class:`~music21.note.NotRest`: :meth:`~music21.note.NotRest.jsonAttributes`

        Methods inherited from :class:`~music21.note.GeneralNote`: :meth:`~music21.note.GeneralNote.addLyric`, :meth:`~music21.note.GeneralNote.augmentOrDiminish`, :meth:`~music21.note.GeneralNote.compactNoteInfo`, :meth:`~music21.note.GeneralNote.getGrace`, :meth:`~music21.note.GeneralNote.hasLyrics`, :meth:`~music21.note.GeneralNote.insertLyric`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSite`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.hasVariantSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.purgeOrphans`, :meth:`~music21.base.Music21Object.purgeUndeclaredIds`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


