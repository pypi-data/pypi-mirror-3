/*-------------------------------------------------------------------------
#Coco.ATG -- Attributed Grammar
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald H. Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/

from Errors import Errors
from CharClass import CharClass
from Core import Node
from Core import DFA
from Core import Graph
from Core import Symbol
from Core import Tab
from Core import Comment
from DriverGen import DriverGen
from ParserGen import ParserGen

COMPILER Coco

   id          = 0
   str         = 1

#-------------------------------------------------------------------------

CHARACTERS
  letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit     = "0123456789".
  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  printable = '\x20' .. '\x7e'.
  alchar    = '\x00' .. '\xff' .
  stringCh  = ANY - '"' - '\\' - cr - lf.
  charCh    = ANY - '\'' - '\\' - cr - lf.
  hex       = "0123456789abcdef".

TOKENS
  ident     = letter { letter | digit }.
  number    = digit { digit }.
  string    = '"' {stringCh | '\\' printable} '"' |
              "'" { charCh | '\\' printable} "'"  .
  badString = '"' {stringCh | '\\' printable} (cr | lf) |
              "'" {charCh | '\\' printable } (cr | lf) .

PRAGMAS
  ddtSym    = '$' { digit | letter }.  (. self.la.val = '-' + str(self.la.val[1:])
                                          Tab.parseArgs( [ self.la.val, 'filler1', 'filler2' ] ) .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. g    = Graph( )
                                   g1   = Graph( )
                                   g2   = Graph( )
                                   s    = set( )    .)
= /*                            (. beg = self.token.pos .)
  { ANY }                       (. end = self.la.pos
                                   ParserGen.usingPos = Position( self.scanner.buffer, beg, end - beg, 0 ) .)*/
  [ Imports<out ParserGen.usingPos> ]
  "COMPILER"                    (. self.genScanner = True
                                   Tab.ignored = set( )       .)
  ident                         (. gramName = self.token.val
                                   beg = self.la.pos .)
  { ANY }                       (. Tab.semDeclPos = Position(self.scanner.buffer, beg, self.la.pos - beg, 0) .)
  [ "IGNORECASE"                (. DFA.ignoreCase = True .) ]
  [ "CHARACTERS" { SetDecl } ]
  [ "TOKENS"  { TokenDecl<Node.t> } ]
  [ "NAMES"   { NameDecl } ]
  [ "PRAGMAS" { TokenDecl<Node.pr> } ]
  { "COMMENTS"                  (. nested = False .)
    "FROM" TokenExpr<out g1>
    "TO" TokenExpr<out g2>
    [ "NESTED"                  (. nested = True .)
    ]                           (. Comment(g1.l, g2.l, nested) .)
  }
  { "IGNORE" Set<out s>         (. Tab.ignored |= s # set union .)
  }

  SYNC
  "PRODUCTIONS"                 (. if self.genScanner:
                                      DFA.MakeDeterministic()
                                   Graph.DeleteNodes()          .)
  { ident                       (. sym = Symbol.Find(self.token.val)
                                   undef = (sym is None)
                                   if undef:
                                      sym = Symbol(Node.nt, self.token.val, self.token.line)
                                   else:
                                      if sym.typ == Node.nt:
                                         if sym.graph is not None:
                                            self.SemErr("name declared twice")
                                      else:
                                         self.SemErr("this symbol kind not allowed on left side of production")
                                      sym.line = self.token.line
                                   noAttrs = (sym.attrPos is None)
                                   sym.attrPos = None
                                   noRet = (sym.retVar is None)
                                   sym.retVar = None .)
    [ AttrDecl<sym> ]           (. if not undef:
                                      if noAttrs != (sym.attrPos is None) or (noRet != (sym.retVar is None)):
                                         self.SemErr("attribute mismatch between declaration and use of this symbol") .)
    [ SemText<out sym.semPos> ]
    WEAK '='
    Expression<out g>           (. sym.graph = g.l
                                   Graph.Finish(g) .)
    WEAK '.'
  }
  "END" ident                   (. if gramName != self.token.val:
                                      self.SemErr("name does not match grammar name")
                                   Tab.gramSy = Symbol.Find(gramName)
                                   if Tab.gramSy is None:
                                      self.SemErr("missing production for grammar name")
                                   else:
                                      sym = Tab.gramSy
                                      if sym.attrPos is not None:
                                         self.SemErr("grammar symbol must not have attributes")
                                   Tab.noSym = Symbol(Node.t, "???", 0) #noSym gets highest number
                                   Tab.SetupAnys()
                                   Tab.RenumberPragmas()
                                   if Tab.ddt[2]:
                                      Node.PrintNodes()
                                   if Errors.count == 0:
                                      sys.stdout.write( "checking\n" )
                                      Tab.CompSymbolSets()
                                      if Tab.ddt[7]:
                                         Tab.XRef()
                                      if Tab.GrammarOk():
                                         if not Tab.ddt[9]:
                                            sys.stdout.write( "parser" )
                                            ParserGen.WriteParser(Tab.ddt[10])
                                            if self.genScanner:
                                               sys.stdout.write( " + scanner" )
                                               DFA.WriteScanner(Tab.ddt[10])
                                               if Tab.ddt[0]:
                                                  DFA.PrintStates()
                                            if Tab.ddt[11]:
                                               sys.stdout.write( " + driver" )
                                               DriverGen.WriteDriver()
                                            sys.stdout.write( " generated\n" )
                                         if Tab.ddt[8]:
                                            ParserGen.WriteStatistics()
                                   if Tab.ddt[6]:
                                      Tab.PrintSymbolTable()      .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl
=
  ident                         (. name = self.token.val
                                   c = CharClass.Find(name)
                                   if c is not None:
                                      self.SemErr("name declared twice") .)
  '=' Set<out s>                (. if len(s) == 0:
                                      self.SemErr("character set must not be empty")
                                   c = CharClass(name, s) .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<out s>
=
  SimSet<out s>
  { '+' SimSet<out s2>          (. s |= s2 .)
  | '-' SimSet<out s2>          (. s -= s2 .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<out s>                   (. n1 = 0
                                   n2 = 0
                                   name = '' .)
=                               (. s = set( )
                                   mx = CharClass.charSetSize      .)
( ident                         (. c = CharClass.Find(self.token.val)
                                   if c is None:
                                      self.SemErr("undefined name")
                                   else:
                                      s |= c.set      .)
| String<out name>
  (                             (. for i in xrange( 0, len(name) ):
                                      if DFA.ignoreCase:
                                         s.add(ord(name[i].lower()))
                                      else:
                                         s.add(ord(name[i])) .)
    |                           (. if (len(name) != 1) or (ord(name[0]) > mx-1):
                                      self.SemErr("unacceptable character value")
                                   else:
                                      n1 = ord(name[0]) % mx
                                   if DFA.ignoreCase and (n1 >= ord('A')) and (n1 <= ord('Z')):
                                      n1 += 32 .)
      ".."
      (   String<out name>      (. if (len(name) != 1) or (ord(name[0]) > mx-1):
                                      self.SemErr("unacceptable character value")
                                   else:
                                      n2 = ord(name[0]) % mx
                                   if DFA.ignoreCase and ((n2 >= ord('A')) and (n2 <= ord('Z'))):
                                      n2 += 32 .)
        | SingleChar<out n2, mx>
      )                         (. for i in xrange( n1, n2+1 ):
                                      s.add(i)    .)
  )
| SingleChar<out n1, mx>       (. s.add(n1) .)
    [ ".."
      (   String<out name>      (. if (len(name) != 1) or (ord(name[0]) > mx-1):
                                      self.SemErr("unacceptable character value")
                                   else:
                                      n2 = ord(name[0]) % mx
                                   if DFA.ignoreCase and ((n2 >= ord('A')) and (n2 <= ord('Z'))):
                                      n2 += 32  .)
        | SingleChar<out n2, mx>
      )                         (. for i in xrange( n1, n2 ):
                                      s.add(i)                 .)
    ]

| "ANY"                         (. s = set( )
                                   for num in xrange( 0, CharClass.charSetSize ):
                                      s.add(num)
                                   s.add('ANYCHAR')              .)
)
.

/*--------------------------------------------------------------------------------------*/

SingleChar<out n, mx>
=                               (. n = 0 .)
  "CHR" "(" number              (. n = int( self.token.val )
                                   if n > (mx - 1):
                                      self.SemErr("unacceptable character value")
                                   if DFA.ignoreCase and ((n >= ord('A')) and (n <= ord('Z'))):
                                      n += 32
                                   n %= mx                 .)
  ")" .

/*--------------------------------------------------------------------------------------*/

String<out name>
= string                        (. name = self.token.val
                                   name = DFA.Unescape( name[ 1 : -1 ] ) .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<typ>
=
  Sym<out s>                    (. name,kind = s
                                   sym = Symbol.Find(name)
                                   if sym is not None:
                                      self.SemErr("name declared twice")
                                   else:
                                      sym = Symbol(typ, name, self.token.line)
                                      sym.tokenKind = Symbol.fixedToken
                                   self.tokenString = None .)
  SYNC
  ( '=' TokenExpr<out g> '.'    (. if kind == self.str:
                                      self.SemErr("a literal must not be declared with a structure")
                                   Graph.Finish(g)
                                   if (self.tokenString is None) or (self.tokenString == self.noString):
                                      DFA.ConvertToStates(g.l, sym)
                                   else:   # TokenExpr is a single string
                                      if Tab.literals.get(self.tokenString) is not None:
                                         self.SemErr("token string declared twice")
                                      Tab.literals[self.tokenString] = sym
                                      DFA.MatchLiteral(self.tokenString, sym)
                                      .)
  |                             (. if kind == self.id:
                                      genScanner = False
                                   else:
                                      DFA.MatchLiteral(sym.name, sym) .)
  )
  [ SemText<out sym.semPos>     (. if typ != Node.pr:
                                      self.SemErr("semantic action not allowed here") .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<sym>
=
   '<'
   (
   ( '^' | "out") ident        (. sym.retVar = self.token.val     .)
 /*     [ ':'                    (. beg = self.la.pos .)
         { ANY }               (. sym.retType = self.scanner.buffer.getString( beg, self.token.pos ) .)
      ] */
      (   '>'
         | ','                 (. beg = self.la.pos
                                  col = self.la.col               .)
            {  ANY | badString (. self.SemErr("bad string in attributes") .)
            } '>'              (. if self.token.pos > beg:
                                     sym.attrPos = Position( self.scanner.buffer, beg, self.token.pos - beg, col )   .)
      )
   |                           (. beg = self.la.pos
                                  col = self.la.col .)
      { ANY | badString        (. self.SemErr("bad string in attributes") .)
      } '>'                    (. if self.token.pos > beg:
                                     sym.attrPos = Position( self.scanner.buffer, beg, self.token.pos - beg, col )   .)
   )
| '<.'
   (
   ( '^' | "out") ident        (. sym.retVar = self.token.val     .)
/*      [ ':'                    (. beg = self.la.pos .)
         { ANY }               (. sym.retType = self.scanner.buffer.getString( beg, self.token.pos ) .)
      ] */
      (   '.>'
         | ','                 (. beg = self.la.pos
                                  col = self.la.col               .)
            {  ANY | badString (. self.SemErr("bad string in attributes") .)
            } '.>'             (. if self.token.pos > beg:
                                     sym.attrPos = Position( self.scanner.buffer, beg, self.token.pos - beg, col )   .)
      )
   |                           (. beg = self.la.pos
                                  col = self.la.col .)
      { ANY | badString        (. self.SemErr("bad string in attributes") .)
      } '.>'                   (. if self.token.pos > beg:
                                     sym.attrPos = Position( self.scanner.buffer, beg, self.token.pos - beg, col )   .)
   )
.

/*------------------------------------------------------------------------------------*/

Expression<out g>
=
  Term<out g>                   (. first = True   .)
  { WEAK '|'
    Term<out g2>                (. if first:
                                      Graph.MakeFirstAlt(g)
                                      first = False
                                   Graph.MakeAlternative(g, g2) .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<out g>                     (. rslv = None
                                   g = None          .)
=
( [                             (. rslv = Node(Node.rslv, None, self.la.line) .)
    Resolver<out rslv.pos>      (. g = Graph(rslv) .)
  ]
  Factor<out g2>                (. if rslv is not None:
                                      Graph.MakeSequence(g, g2)
                                   else:
                                      g = g2 .)
  { Factor<out g2>              (. Graph.MakeSequence(g, g2) .)
  }
  |                             (. g = Graph(Node(Node.eps, None, 0)) .)
)                               (. if g is None:   # invalid start of Term
                                      g = Graph(Node(Node.eps, None, 0)) .)
.

/*------------------------------------------------------------------------------------*/

Factor<out g>                   (. weak = False
                                   g = None      .)
=
( [ "WEAK"                      (. weak = True   .)
  ]
  Sym<out s>                    (. name,kind = s
                                   sym = Symbol.Find(name)
                                   if (sym is None) and (kind == self.str):
                                      sym = Tab.literals.get(name)
                                   undef = (sym is None)
                                   if undef:
                                      if kind == self.id:
                                         sym = Symbol(Node.nt, name, 0)  # forward nt
                                      elif self.genScanner:
                                         sym = Symbol(Node.t, name, self.token.line)
                                         DFA.MatchLiteral(sym.name, sym)
                                      else:  # undefined string in production
                                         self.SemErr("undefined string in production")
                                         sym = Tab.eofSy  # dummy
                                   typ = sym.typ
                                   if (typ != Node.t) and (typ != Node.nt):
                                      self.SemErr("this symbol kind is not allowed in a production")
                                   if weak:
                                      if typ == Node.t:
                                         typ = Node.wt
                                      else:
                                         self.SemErr("only terminals may be weak")
                                   p = Node(typ, sym, self.token.line)
                                   g = Graph(p) .)
  [ Attribs<p>                  (. if kind != self.id:
                                      self.SemErr("a literal must not have attributes") .)
  ]                             (. if undef:
                                      sym.attrPos = p.pos    # dummy
                                      sym.retVar = p.retVar  # AH - dummy
                                   elif ((p.pos is None) != (sym.attrPos is None)) or ((p.retVar is None) != (sym.retVar is None)):
                                      self.SemErr("attribute mismatch between declaration and use of this symbol") .)
| '(' Expression<out g> ')'
| '[' Expression<out g> ']'     (. Graph.MakeOption(g) .)
| '{' Expression<out g> '}'     (. Graph.MakeIteration(g) .)
| SemText<out pos>              (. p = Node(Node.sem, None, 0)
                                   p.pos = pos
                                   g = Graph(p) .)
| "ANY"                         (. p = Node(Node.any, None, 0)  # p.set is set in Tab.SetupAnys
                                   g = Graph(p) .)
| "SYNC"                        (. p = Node(Node.sync, None, 0)
                                   g = Graph(p) .)
)                               (. if g is None:   # invalid start of Factor
                                      g = Graph(Node(Node.eps, None, 0)) .)
.

/*------------------------------------------------------------------------------------*/

Resolver<out pos>
=
  "IF" "("                      (. beg = self.la.pos
                                   col = self.la.col .)
  Condition                     (. pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<out g>
=
  TokenTerm<out g>              (. first = True .)
  { WEAK '|'
    TokenTerm<out g2>           (. if first:
                                      Graph.MakeFirstAlt(g)
                                      first = False
                                   Graph.MakeAlternative(g, g2) .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<out g>
=
  TokenFactor<out g>
  { TokenFactor<out g2>         (. Graph.MakeSequence(g, g2) .)
  }
  [ "CONTEXT"
    '(' TokenExpr<out g2>       (. Graph.SetContextTrans(g2.l)
                                   Graph.MakeSequence(g, g2) .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<out g>
=
                                (. g = None.)
( Sym<out s>                    (. name,kind = s
                                   if kind == self.id:
                                      c = CharClass.Find(name)
                                      if c is None:
                                         self.SemErr("undefined name")
                                         c = CharClass(s.name, set( ) )
                                      p = Node(Node.clas, None, 0)
                                      p.val = c.n
                                      g = Graph(p)
                                      self.tokenString = self.noString
                                   else:    # str
                                      g = Graph.StrToGraph(name)
                                      if self.tokenString is None:
                                         self.tokenString = name
                                      else:
                                         self.tokenString = self.noString .)
| '(' TokenExpr<out g> ')'
| '[' TokenExpr<out g> ']'      (. Graph.MakeOption(g) .)
| '{' TokenExpr<out g> '}'      (. Graph.MakeIteration(g) .)
)                               (. if g is None:    # invalid start of TokenFactor
                                      g = Graph(Node(Node.eps, None, 0)) .)
.

/*------------------------------------------------------------------------------------*/

Sym<out s>
=                               (. name = "???"
                                   kind = self.id .)
(   ident                       (. kind = self.id
                                   name = self.token.val .)
  | string                      (. kind = self.str
                                   name = "\"" + self.token.val[ 1 : -1 ] + "\""
                                   if DFA.ignoreCase:
                                      name = name.lower()
                                   if name.find(' ') >= 0:
                                      self.SemErr("literal tokens must not contain blanks") .)
)
                                (. s = name, kind  .)
.

/*------------------------------------------------------------------------------------*/

Attribs<n>
=
  '<'
  ( ( '^' | "out")              (. beg = self.la.pos .)
    { ANY | badString           (. self.SemErr("bad string in attributes") .)
    }                           (. n.retVar = self.scanner.buffer.getString(beg, self.la.pos) .)
    ( '>'
    | ','                       (. beg = self.la.pos
                                   col = self.la.col .)
      { ANY | badString         (. self.SemErr("bad string in attributes") .)
      } '>'                     (. if self.token.pos > beg:
                                      n.pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
    )
  |                             (. beg = self.la.pos
                                   col = self.la.col .)
    {  ANY | badString          (. self.SemErr("bad string in attributes") .)
    } '>'                       (. if self.token.pos > beg:
                                      n.pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
  )
  |
  "<."
  ( ( '^' | "out")              (. beg = self.la.pos .)
    { ANY | badString           (. self.SemErr("bad string in attributes") .)
    }                           (. n.retVar = self.scanner.buffer.getString(beg, self.la.pos) .)
    ( ".>"
    | ','                       (. beg = self.la.pos
                                   col = self.la.col .)
      { ANY | badString         (. self.SemErr("bad string in attributes") .)
      } ".>"                    (. if self.token.pos > beg:
                                      n.pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
    )
  |                             (. beg = self.la.pos
                                   col = self.la.col .)
    {  ANY | badString          (. self.SemErr("bad string in attributes") .)
    } ".>"                      (. if self.token.pos > beg:
                                      n.pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
  ).

/*------------------------------------------------------------------------------------*/

SemText<out pos>
=
  "(."                          (. beg = self.la.pos
                                   col = self.la.col .)
  { ANY
  | badString                   (. self.SemErr( "bad string in semantic action" ) .)
  | "(."                        (. self.SemErr( "missing end of previous semantic action") .)
 } ".)"                  (. pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col) .)
   .

/*------------------------------------------------------------------------------------*/

NameDecl
=
  ident                         (. alias = self.token.val .)
  "="
  ( ident | string )            (. Tab.NewName(alias, self.token.val) .)
  "." .

/*------------------------------------------------------------------------------------*/
Imports<out pos>                (. beg = None
                                   pos = None .)
=
   [ 'from'                     (. beg = self.token.pos .)
     ident { '.' ident } ]
   'import'                     (. if beg == None:
                                      beg = self.token.pos .)
      ( (     ident { '.' ident } { ',' ident { '.' ident } } )
      | ( '(' ident { '.' ident } { ',' ident { '.' ident } } ')' )
      | '*' )
   { [ 'from'
     ident { '.' ident } ]
   'import'
      ( (     ident { '.' ident } { ',' ident { '.' ident } } )
      | ( '(' ident { '.' ident } { ',' ident { '.' ident } } ')' ) ) }
                                (. end = self.la.pos
                                   pos = Position( self.scanner.buffer, beg, end - beg, 0 ) .)
.

END Coco.
