#define PP_CAT_(a,b) a ## b
#define PP_CAT(a,b) PP_CAT_(a,b)
#define PP_STR_(a) #a
#define PP_STR(a) PP_STR_(a)

#define HANDLE_BASE PP_CAT(iBase,HANDLE_TYPE)
#define HANDLE_PYTYPE PP_CAT(HANDLE_BASE,_Type)
#define HANDLE_CTYPE PP_CAT(iBase_,PP_CAT(HANDLE_TYPE,Handle))
#define HANDLE_OBJ PP_CAT(HANDLE_BASE,_Object)
#define HANDLE_STR PP_STR(HANDLE_TYPE)

static PyTypeObject HANDLE_PYTYPE;

static PyObject *
PP_CAT(HANDLE_BASE,_FromHandle)(HANDLE_CTYPE h)
{
    HANDLE_OBJ *o = PP_CAT(HANDLE_BASE,_New)();
    if(o == NULL)
        return NULL;

    o->handle = h;
    return (PyObject*)o;
}

static PyObject *
PP_CAT(HANDLE_BASE,_new) (PyTypeObject *cls,PyObject *args,PyObject *kw)
{
    static char *kwlist[] = {"object",0};
    HANDLE_OBJ *obj;

    if( !PyArg_ParseTupleAndKeywords(args,kw,"O!",kwlist,&HANDLE_PYTYPE,
                                     &obj))
        return NULL;

    return PP_CAT(HANDLE_BASE,_FromHandle) (obj->handle);
}

static PyObject *
PP_CAT(HANDLE_BASE,_repr) (HANDLE_OBJ *self)
{
    return PyString_FromFormat("<%s %p>",self->ob_type->tp_name,
                               (void*)self->handle);
}

static PyObject *
PP_CAT(HANDLE_BASE,_str) (HANDLE_OBJ *self)
{
    return PP_CAT(HANDLE_BASE,_repr) (self);
}

static PyObject *
PP_CAT(HANDLE_BASE,_richcompare) (HANDLE_OBJ *lhs,HANDLE_OBJ *rhs,int op)
{
    if(!PP_CAT(HANDLE_BASE,_Check) (lhs) || !PP_CAT(HANDLE_BASE,_Check) (rhs))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    switch(op)
    {
    case Py_EQ:
        return PyBool_FromLong(lhs->handle == rhs->handle);
    case Py_NE:
        return PyBool_FromLong(lhs->handle != rhs->handle);
    default:
        PyErr_SetNone(PyExc_TypeError);
        return NULL;
    }
}

static long
PP_CAT(HANDLE_BASE,_hash) (HANDLE_OBJ *self)
{
    return (long)self->handle;
}

static PyTypeObject HANDLE_PYTYPE = {
    PyObject_HEAD_INIT(NULL)
    0,                                             /* ob_size */
    "itaps.iBase." HANDLE_STR,                     /* tp_name */
    sizeof(HANDLE_OBJ),                            /* tp_basicsize */
    0,                                             /* tp_itemsize */
    0,                                             /* tp_dealloc */
    0,                                             /* tp_print */
    0,                                             /* tp_getattr */
    0,                                             /* tp_setattr */
    0,                                             /* tp_compare */
    (reprfunc)PP_CAT(HANDLE_BASE,_repr),           /* tp_repr */
    0,                                             /* tp_as_number */
    0,                                             /* tp_as_sequence */
    0,                                             /* tp_as_mapping */
    (hashfunc)PP_CAT(HANDLE_BASE,_hash),           /* tp_hash */
    0,                                             /* tp_call */
    (reprfunc)PP_CAT(HANDLE_BASE,_str),            /* tp_str */
    0,                                             /* tp_getattro */
    0,                                             /* tp_setattro */
    0,                                             /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                            /* tp_flags */
    "iBase " HANDLE_STR " objects",                /* tp_doc */
    0,                                             /* tp_traverse */
    0,                                             /* tp_clear */
    (richcmpfunc)PP_CAT(HANDLE_BASE,_richcompare), /* tp_richcompare */
    0,                                             /* tp_weaklistoffset */
    0,                                             /* tp_iter */
    0,                                             /* tp_iternext */
    0,                                             /* tp_methods */
    0,                                             /* tp_members */
    0,                                             /* tp_getset */
    0,                                             /* tp_base */
    0,                                             /* tp_dict */
    0,                                             /* tp_descr_get */
    0,                                             /* tp_descr_set */
    0,                                             /* tp_dictoffset */
    0,                                             /* tp_init */
    0,                                             /* tp_alloc */
    PP_CAT(HANDLE_BASE,_new),                      /* tp_new */
};

static HANDLE_CTYPE
PP_CAT(HANDLE_BASE,_GetHandle)(PyObject *o)
{
    if(PP_CAT(HANDLE_BASE,_Check)(o))
        return PP_CAT(HANDLE_BASE,_GET_HANDLE)(o);
    
    if(o == NULL)
        PyErr_BadArgument();
    else
        PyErr_SetString(PyExc_TypeError,HANDLE_STR " is required");
    return NULL;
}

static PyObject *
PP_CAT(HANDLE_BASE,Arr_getitem)(void *data,void *arr)
{
    subarray_t *sub = NULL;
    PyObject *instance = NULL;

    if(PyObject_TypeCheck((PyObject*)arr,&iBaseArr_Type))
    {
        iBaseArr_Object *o = (iBaseArr_Object*)arr;
        instance = o->instance;
        sub = o->funcs;
    }

    if(sub)
        return sub->creator(instance,*(HANDLE_CTYPE*)data);
    else
        return PP_CAT(HANDLE_BASE,_FromHandle)(*(HANDLE_CTYPE*)data);
}

static int
PP_CAT(HANDLE_BASE,Arr_setitem)(PyObject *item,void *data,void *arr)
{
    subarray_t *sub = NULL;
    PyObject *instance = NULL;

    if(PyObject_TypeCheck((PyObject*)arr,&iBaseArr_Type))
    {
        iBaseArr_Object *o = (iBaseArr_Object*)arr;
        instance = o->instance;
        sub = o->funcs;
    }

    if(!PP_CAT(HANDLE_BASE,_Check)(item))
        return -1;

    if(sub && PyObject_TypeCheck(item,sub->el_type) &&
       PyObject_RichCompareBool(instance,sub->getter(item),Py_NE))
        return -1;

    *(HANDLE_CTYPE*)data = PP_CAT(HANDLE_BASE,_GET_HANDLE)(item);
    return 0;
}

static void
PP_CAT(HANDLE_BASE,Arr_copyswapn)(void *dst,npy_intp dstride,void *src,
                                  npy_intp sstride,npy_intp n,int swap,
                                  void *arr)
{
    npy_intp i;
    PyArray_CopySwapFunc *copyswap = PyArray_DESCR(arr)->f->copyswap;
    char *dstptr = dst;
    char *srcptr = src;
    if(!src) sstride = 0;
	
    for(i=0; i<n; i++)
    {
        copyswap(dstptr,srcptr,swap,arr);
        dstptr += dstride;
        srcptr += sstride;
    }
}

static void
PP_CAT(HANDLE_BASE,Arr_copyswap)(void *dst,void *src,int swap,void *arr)
{
    if(src)
        memcpy(dst,src,sizeof(HANDLE_CTYPE));

    if(swap)
    {
        char *start = (char *)dst;
        char *end = start + sizeof(HANDLE_CTYPE) - 1;
        char tmp;

        for(; start < end; start++, end--)
        {
            tmp = *start;
            *start = *end;
            *end = tmp;
        }
    }
}

static int
PP_CAT(HANDLE_BASE,Arr_compare)(const void *d1, const void *d2, void *arr)
{
    int tmp = memcmp(d1,d2,sizeof(HANDLE_CTYPE));
    return (tmp>0) - (tmp<0); /* good ol' sgn() */
}

static npy_bool
PP_CAT(HANDLE_BASE,Arr_nonzero)(void *data,void *arr)
{
    return *(HANDLE_CTYPE*)data != 0;
}

static PyArray_ArrFuncs PP_CAT(HANDLE_BASE,Arr_funcs) = {
    {0},                                          /* cast */   
    PP_CAT(HANDLE_BASE,Arr_getitem),              /* getitem */
    PP_CAT(HANDLE_BASE,Arr_setitem),              /* setitem */
    PP_CAT(HANDLE_BASE,Arr_copyswapn),            /* copyswapn */
    PP_CAT(HANDLE_BASE,Arr_copyswap),             /* copyswap */
    PP_CAT(HANDLE_BASE,Arr_compare),              /* compare */
    0,                                            /* argmax */
    0,                                            /* dotfunc */
    0,                                            /* scanfunc */
    0,                                            /* fromstr */
    PP_CAT(HANDLE_BASE,Arr_nonzero),              /* nonzero */
};

static void
PP_CAT(HANDLE_BASE,Arr_equal)(char **args,npy_intp *dims,npy_intp *steps,
                              void *data)
{
    char *ip1 = args[0], *ip2 = args[1], *op1 = args[2];
    npy_intp is1 = steps[0], is2 = steps[1], os1 = steps[2];
    npy_intp n = dims[0];
    npy_intp i;
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op1 += os1)
    {
        HANDLE_CTYPE in1 = *(HANDLE_CTYPE*)ip1;
        HANDLE_CTYPE in2 = *(HANDLE_CTYPE*)ip2;
        *((npy_bool *)op1) = (in1 == in2);
    }
}

static void
PP_CAT(HANDLE_BASE,Arr_notequal)(char **args,npy_intp *dims,npy_intp *steps,
                                 void *data)
{
    char *ip1 = args[0], *ip2 = args[1], *op1 = args[2];
    npy_intp is1 = steps[0], is2 = steps[1], os1 = steps[2];
    npy_intp n = dims[0];
    npy_intp i;
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op1 += os1)
    {
        HANDLE_CTYPE in1 = *(HANDLE_CTYPE*)ip1;
        HANDLE_CTYPE in2 = *(HANDLE_CTYPE*)ip2;
        *((npy_bool *)op1) = (in1 != in2);
    }
}

static void
PP_CAT(HANDLE_BASE,_RegisterArray)(char type,PyUFuncObject *eq,
                                   PyUFuncObject *neq)
{
    PyArray_Descr *descr = PyArray_DescrNewFromType(NPY_INTP);
    int types[3];

    /* I refuse to write my own sort functions so I will hijack NumPy's */
    int i;
    for(i=0; i<PyArray_NSORTS; i++)
    {
        PP_CAT(HANDLE_BASE,Arr_funcs).sort[i]    = descr->f->sort[i];
        PP_CAT(HANDLE_BASE,Arr_funcs).argsort[i] = descr->f->argsort[i];
    }

    descr->f = &PP_CAT(HANDLE_BASE,Arr_funcs);

    /* Note: if you change the byteorder, make sure to call copyswap in
       (HANDLE_BASE)_new and their subtypes */
    descr->typeobj = &HANDLE_PYTYPE;
    descr->kind = type;
    descr->type = type;
#if NPY_FEATURE_VERSION >= 0x00000005
    descr->flags = NPY_USE_GETITEM | NPY_USE_SETITEM;
#else
    descr->hasobject = NPY_USE_GETITEM | NPY_USE_SETITEM;
#endif
    descr->elsize = sizeof(HANDLE_CTYPE);

    HANDLE_NPYTYPE = PyArray_RegisterDataType(descr);

    types[0] = types[1] = HANDLE_NPYTYPE; types[2] = NPY_BOOL;
    PyUFunc_RegisterLoopForType(eq, HANDLE_NPYTYPE,
                                PP_CAT(HANDLE_BASE,Arr_equal),types,0);
    PyUFunc_RegisterLoopForType(neq,HANDLE_NPYTYPE,
                                PP_CAT(HANDLE_BASE,Arr_notequal),types,0);
}
