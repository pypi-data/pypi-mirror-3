#summary Here is a list of OSI features that can be accessed through yaposib

== Problem ==
{{{
Problem
}}}
Models an LP problem


=== Main methods ===

{{{
Problem.markHotStart()
}}}
Makes an internal optimization snapshot of the problem (an internal
warmstart object is built)


{{{
Problem.unmarkHotStart()
}}}
Deletes the internal snapshot of the problem (if existing)


{{{
Problem.solve(True/False)
}}}
Solves the internal problem:
  * If an internal snapshot exists, use it.
  * If the problem has already been solved, use the internal `ReSolve`.
  * If the argument is true, add a branch and bound call.


{{{
Problem.status
}}}
RO Attribute.
string describing the solver status:
"undefined", "abandoned", "optimal", "infeasible" or "limitreached".
You can get more details using the properties
  * isAbandoned
  * isProvenOptimal
  * isProvenPrimalInfeasible
  * isProvenDualInfeasible
  * isPrimalObjectiveLimitReached
  * isDualObjectiveLimitReached
  * isIterationLimitReached


{{{
Problem.writeLp("filename")
}}}
Write the problem in a file (lp format). The argument is appended the
extension ".lp"


=== Objective ===

{{{
Problem.obj
}}}
Objective function
Represents the objective of the problem


{{{
Problem.obj.value
}}}
RO attribute (double)
Objective value


{{{
Problem.obj.maximize
}}}
RW attribute (bool)
min/max problem


{{{
Problem.obj.name
}}}
RW attribute (string)
name


{{{
Problem.obj.__len__
}}}
number of columns


{{{
Problem.obj.__iter__
}}}
Makes iterable


{{{
Problem.obj.__getitem__
}}}
get the given coef with `Problem.obj[i]`


{{{
Problem.obj.__setitem__
}}}
set the given coef with `Problem.obj[i] = double`


=== Rows ===

{{{
Problem.rows
}}}
Represents every rows


{{{
Problem.rows.add(vec([(1, 2.0),(3, 0.1),...]))
}}}
adds the given row to the problem and returns a Row object


{{{
Problem.rows.__len__
}}}
the number of rows


{{{
Problem.rows.__iter__
}}}
Makes iterable


{{{
Problem.rows.__getitem__
}}}
allows to get the row of index with `Problem.rows[i]`


{{{
Problem.rows.__delitem__
}}}
deletes the row of given index with del `Problem.rows[i]`


{{{
Problem.rows[i].index
}}}
RO Attribute (int)
index in the problem


{{{
Problem.rows[i].name
}}}
RW Attribute (string)
name of the row


{{{
Problem.rows[i].lowerbound
}}}
RW Attribute (double)
lowerbound of the row


{{{
Problem.rows[i].upperbound
}}}
RW Attribute (double)
upperbound of the row


{{{
Problem.rows[i].indices
}}}
RO Attribute (list of int)
indices of the columns refered by the row


{{{
Problem.rows[i].values
}}}
RO Attribute (list of double)
values of the coefficients for the columns refered by the row


{{{
Problem.rows[i].dual
}}}
RW Attribute (double)
dual value of the row


{{{
Problem.rows[i].activity
}}}
RO Attribute (double)
activity of the row


=== Columns ===

{{{
Problem.cols
}}}
Variables
Represent all the columns of the problem


{{{
Problem.cols.add(vec([(1, 2.0),(3, 0.1),...]))
}}}
adds the given column (returns a Col object)


{{{
Problem.cols.__len__
}}}
returns the number of columns


{{{
Problem.cols.__getitem__
}}}
returns the column at the given index with `Problem.cols[i]`


{{{
Problem.cols.__iter__
}}}
make iterable


{{{
Problem.cols.__delitem__
}}}
deletes the column at given index with del `Problem.cols[i]`


{{{
Problem.cols[i].index
}}}
RO Attribute (int)
index in problem


{{{
Problem.cols[i].name
}}}
RW Attribute (string)
name


{{{
Problem.cols[i].lowerbound
}}}
RW Attribute (double)
lowerbound


{{{
Problem.cols[i].upperbound
}}}
RW Attribute (double)
upperbound


{{{
Problem.cols[i].indices
}}}
RO Attribute (list of int)
indices of the row refered by the column


{{{
Problem.cols[i].values
}}}
RO Attribute (list of double)
values of the coefficients for the rows refered by the column


{{{
Problem.cols[i].solution
}}}
RW Attribute (double)
solution


{{{
Problem.cols[i].reducedcost
}}}
RO Attribute (double)
reduced cost


{{{
Problem.cols[i].integer
}}}
RW Attribute (double)
integer variable?


=== Problem Tuning ===

==== RW Attributes ====

{{{
Problem.maxNumIterations
}}}
RW attribute (int)
The maximum number of iterations (whatever that means for the given
solver) the solver can execute before terminating (When solving/resolving)


{{{
Problem.maxNumIterationsHotStart
}}}
RW attribute (int)
The maximum number of iterations (whatever that means for the given
solver) the solver can execute when hot starting before terminating.


{{{
Problem.dualObjectiveLimit
}}}
RW attribute (double)
Dual objective limit. This is to be used as a termination criteria in
methods where the dual objective monotonically changes (e.g., dual
simplex, the volume algorithm)


{{{
Problem.primalObjectiveLimit
}}}
RW attribute (double)
Primal objective limit. This is to be used as a termination criteria in
methods where the primal objective monotonically changes (e.g., primal
simplex)


{{{
Problem.dualTolerance
}}}
RW attribute (double)
The maximum amount the dual constraints can be violated and still be
considered feasible.


{{{
Problem.primalTolerance
}}}
RW attribute (double)
The maximum amount the primal constraints can be violated and still be
considered feasible.


{{{
Problem.objOffset
}}}
RW attribute (double)
The value of any constant term in the objective function.


{{{
Problem.doPreSolveInInitial
}}}
RW attribute (bool)
Whether to do a presolve in initialSolve.


{{{
Problem.doDualInInitial
}}}
RW attribute (bool)
Whether to use a dual algorithm in initialSolve. The reverse is to use a
primal algorithm


{{{
Problem.doPreSolveInReSolve
}}}
RW attribute (bool)
Whether to do a presolve in resolve


{{{
Problem.doDualInResolve
}}}
RW attribute (bool)
Whether to use a dual algorithm in resolve. The reverse is to use a primal
algorithm


{{{
Problem.doScale
}}}
RW attribute (bool)
Whether to scale problem


{{{
Problem.doCrash
}}}
RW attribute (bool)
Whether to create a non-slack basis (only in initialSolve)


{{{
Problem.doInBranchAndCut
}}}
RW attribute (bool)
Whether we are in branch and cut - so can modify behavior


==== RO Attributes ====

{{{
Problem.iterationCount
}}}
RO attribute (int)
Get the number of iterations it took to solve the problem (whatever
iteration means to the solver).


{{{
Problem.integerTolerance
}}}
RO attribute (double)
Get the integer tolerance of the solver


{{{
Problem.isAbandoned
}}}
RO attribute (bool)
Are there numerical difficulties?


{{{
Problem.isProvenOptimal
}}}
RO attribute (bool)
Is optimality proven?


{{{
Problem.isProvenPrimalInfeasible
}}}
RO attribute (bool)
Is primal infeasiblity proven?


{{{
Problem.isProvenDualInfeasible
}}}
RO attribute (bool)
Is dual infeasiblity proven?


{{{
Problem.isPrimalObjectiveLimitReached
}}}
RO attribute (bool)
Is the given primal objective limit reached?


{{{
Problem.isDualObjectiveLimitReached
}}}
RO attribute (bool)
Is the given dual objective limit reached?


{{{
Problem.isIterationLimitReached
}}}
RO attribute (bool)
Iteration limit reached?


== Helper ==

{{{
vec([(0,0.1),(1,2.3)])
}}}
Helper function that returns a internal type of sparse vector.
See OSI's `CoinPackedVector`. Write only.

