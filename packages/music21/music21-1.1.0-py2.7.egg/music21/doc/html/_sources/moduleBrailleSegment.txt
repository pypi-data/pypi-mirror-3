.. _moduleBraille.segment:

music21.braille.segment
=======================

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED. Edit the .py file directly

.. module:: music21.braille.segment


Inner classes and methods for transcribing musical segments into braille.


This module was made in consultation with the manual "Introduction to Braille
Music Transcription, Second Edition" by Mary Turner De Garmo, 2005. It is
available from the Library of Congress `here <http://www.loc.gov/nls/music/>`_,
and will henceforth be referred to as BMTM.




.. function:: addGroupingAttributes(allSegments, **partKeywords)


    Modifies the attributes of all :class:`~music21.braille.segment.BrailleElementGrouping`
    instances in a list of :class:`~music21.braille.segment.BrailleSegment` instances. The
    necessary information is retrieved both by passing in partKeywords as an argument and
    by taking into account the linear progression of the groupings and segments.



.. function:: addSegmentAttributes(allSegments, **partKeywords)


    Modifies the attributes of a :class:`~music21.braille.segment.BrailleSegment`
    by passing partKeywords as an argument.



.. function:: compareNoteGroupings(noteGroupingA, noteGroupingB)


    Takes in two note groupings, noteGroupingA and noteGroupingB. Returns True
    if both groupings have identical contents. False otherwise.



.. function:: extractBrailleElements(music21Measure)


    Takes in a :class:`~music21.stream.Measure` and returns a
    :class:`~music21.braille.segment.BrailleElementGrouping` of correctly ordered
    :class:`~music21.base.Music21Object` instances which can be directly transcribed to
    braille.




    >>> from music21.braille import segment
    >>> from music21 import spanner
    >>> from music21 import tinyNotation
    >>> tn = tinyNotation.TinyNotationStream("c16 c c c d d d d", "2/4")
    >>> tn = tn.makeNotation(cautionaryNotImmediateRepeat=False)
    >>> measure = tn[0]
    >>> measure.append(spanner.Slur(measure.notes[0],measure.notes[-1]))
    >>> measure.show("text")
    {0.0} <music21.clef.TrebleClef>
    {0.0} <music21.meter.TimeSignature 2/4>
    {0.0} <music21.note.Note C>
    {0.25} <music21.note.Note C>
    {0.5} <music21.note.Note C>
    {0.75} <music21.note.Note C>
    {1.0} <music21.note.Note D>
    {1.25} <music21.note.Note D>
    {1.5} <music21.note.Note D>
    {1.75} <music21.note.Note D>
    {2.0} <music21.spanner.Slur <music21.note.Note C><music21.note.Note D>>
    {2.0} <music21.bar.Barline style=final>


    Spanners are dealt with in :meth:`~music21.braille.segment.prepareSlurredNotes`,
    so they are not returned by this method, as seen below.




    >>> segment.extractBrailleElements(measure)
    2/4
    <music21.clef.TrebleClef>
    <music21.note.Note C>
    <music21.note.Note C>
    <music21.note.Note C>
    <music21.note.Note C>
    <music21.note.Note D>
    <music21.note.Note D>
    <music21.note.Note D>
    <music21.note.Note D>
    <music21.bar.Barline style=final>



.. function:: findSegments(music21Part, **partKeywords)


    Takes in a :class:`~music21.stream.Part` or :class:`~music21.tinyNotation.TinyNotationStream`
    and a list of partKeywords. Returns a list of :class:`~music21.segment.BrailleSegment` instances.


    Five methods get called in the generation of segments:

    * :meth:`~music21.braille.segment.prepareSlurredNotes`
    * :meth:`~music21.braille.segment.getRawSegments`
    * :meth:`~music21.braille.segment.addGroupingAttributes`
    * :meth:`~music21.braille.segment.addSegmentAttributes`
    * :meth:`~music21.braille.segment.fixArticulations`




    >>> from music21.braille import test
    >>> example = test.example11_2()
    >>> allSegments = findSegments(example, segmentBreaks = [(8, 3.0)])
    >>> allSegments[0]
    ---begin segment---
    <music21.braille.segment BrailleSegment>
    Measure 0, Signature Grouping 1:
    sharps -3, mode None
    4/4
    ===
    Measure 0, Note Grouping 1:
    <music21.clef.TrebleClef>
    <music21.note.Note B->
    ===
    Measure 1, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note E->
    <music21.note.Note D>
    <music21.note.Note E->
    ===
    Measure 2, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note F>
    <music21.note.Note E->
    ===
    Measure 3, Note Grouping 1:
    <music21.note.Note A->
    <music21.note.Note G>
    <music21.note.Note C>
    <music21.note.Note C>
    ===
    Measure 4, Note Grouping 1:
    <music21.note.Note B->
    <music21.note.Note B->
    ===
    Measure 5, Note Grouping 1:
    <music21.note.Note E->
    <music21.note.Note B->
    <music21.note.Note A->
    <music21.note.Note G>
    ===
    Measure 6, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note F>
    <music21.note.Note C>
    ===
    Measure 7, Note Grouping 1:
    <music21.note.Note C>
    <music21.note.Note F>
    <music21.note.Note A->
    <music21.note.Note D>
    ===
    Measure 8, Note Grouping 1:
    <music21.note.Note E->
    ** Music Hyphen **
    ===
    ---end segment---
    >>> allSegments[1]
    ---begin segment---
    <music21.braille.segment BrailleSegment>
    Measure 8, Note Grouping 1:
    <music21.note.Note G>
    ===
    Measure 9, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note F>
    <music21.note.Note F>
    <music21.note.Note F>
    ===
    Measure 10, Note Grouping 1:
    <music21.note.Note A->
    <music21.note.Note G>
    <music21.note.Note B->
    ===
    Measure 11, Note Grouping 1:
    <music21.note.Note B->
    <music21.note.Note A>
    <music21.note.Note A>
    <music21.note.Note C>
    ===
    Measure 12, Note Grouping 1:
    <music21.note.Note B->
    <music21.note.Note B->
    ===
    Measure 13, Note Grouping 1:
    <music21.note.Note E->
    <music21.note.Note B->
    <music21.note.Note A->
    <music21.note.Note G>
    ===
    Measure 14, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note F>
    <music21.note.Note C>
    ===
    Measure 15, Note Grouping 1:
    <music21.note.Note C>
    <music21.note.Rest rest>
    <music21.note.Note F>
    <music21.note.Rest rest>
    ===
    Measure 16, Note Grouping 1:
    <music21.note.Note A->
    <music21.note.Note D>
    ===
    Measure 17, Note Grouping 1:
    <music21.note.Note E->
    <music21.bar.Barline style=final>
    ===
    ---end segment---



.. function:: fixArticulations(allSegments)


    Goes through each :class:`~music21.braille.segment.BrailleSegment` and modifies the
    list of :attr:`~music21.note.GeneralNote.articulations` of a :class:`~music21.note.Note`
    if appropriate. In particular, two rules are applied:

    * Doubling rule => If four or more of the same :class:`~music21.articulations.Articulation`
      are found in a row, the first instance of the articulation is doubled and the rest are
      omitted.

    * Staccato, Tenuto rule => "If two repeated notes appear to be tied, but either is marked
      staccato or tenuto, they are treated as slurred instead of tied." (BMTM, 112)



.. function:: getRawSegments(music21Part, segmentBreaks=[])


    Takes in a :class:`~music21.stream.Part` and a segmentBreaks list which
    contains (measureNumber, offsetStart) tuples. These tuples determine how
    the Part is divided up into segments (i.e. instances of
    :class:`~music21.braille.segment.BrailleSegment`). This method assumes
    that the Part is already divided up into measures
    (see :class:`~music21.stream.Measure`). An acceptable input is shown below.


    Two methods are called on each measure during the creation of segments:

    * :meth:`~music21.braille.segment.prepareBeamedNotes`
    * :meth:`~music21.braille.segment.extractBrailleElements`




    >>> from music21 import tinyNotation
    >>> tn = tinyNotation.TinyNotationStream("c4 c c e e e g g g c'2.","3/4")
    >>> tn = tn.makeNotation(cautionaryNotImmediateRepeat=False)
    >>> tn.show("text")
    {0.0} <music21.stream.Measure 1 offset=0.0>
        {0.0} <music21.meter.TimeSignature 3/4>
        {0.0} <music21.clef.TrebleClef>
        {0.0} <music21.note.Note C>
        {1.0} <music21.note.Note C>
        {2.0} <music21.note.Note C>
    {3.0} <music21.stream.Measure 2 offset=3.0>
        {0.0} <music21.note.Note E>
        {1.0} <music21.note.Note E>
        {2.0} <music21.note.Note E>
    {6.0} <music21.stream.Measure 3 offset=6.0>
        {0.0} <music21.note.Note G>
        {1.0} <music21.note.Note G>
        {2.0} <music21.note.Note G>
    {9.0} <music21.stream.Measure 4 offset=9.0>
        {0.0} <music21.note.Note C>
        {3.0} <music21.bar.Barline style=final>


    By default, there is no break anywhere within the Part,
    and a segmentList of size 1 is returned.




    >>> import copy
    >>> from music21.braille import segment
    >>> tnA = copy.deepcopy(tn)
    >>> segment.getRawSegments(tnA)[0]
    ---begin segment---
    <music21.braille.segment BrailleSegment>
    Measure 1, Signature Grouping 1:
    3/4
    ===
    Measure 1, Note Grouping 1:
    <music21.clef.TrebleClef>
    <music21.note.Note C>
    <music21.note.Note C>
    <music21.note.Note C>
    ===
    Measure 2, Note Grouping 1:
    <music21.note.Note E>
    <music21.note.Note E>
    <music21.note.Note E>
    ===
    Measure 3, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note G>
    <music21.note.Note G>
    ===
    Measure 4, Note Grouping 1:
    <music21.note.Note C>
    <music21.bar.Barline style=final>
    ===
    ---end segment---


    Now, a segment break occurs at measure 2, offset 1.0 within that measure.
    The two segments are shown below.




    >>> tnB = copy.deepcopy(tn)
    >>> allSegments = segment.getRawSegments(tnB, segmentBreaks=[(2,1.0)])
    >>> allSegments[0]
    ---begin segment---
    <music21.braille.segment BrailleSegment>
    Measure 1, Signature Grouping 1:
    3/4
    ===
    Measure 1, Note Grouping 1:
    <music21.clef.TrebleClef>
    <music21.note.Note C>
    <music21.note.Note C>
    <music21.note.Note C>
    ===
    Measure 2, Note Grouping 1:
    <music21.note.Note E>
    ===
    ---end segment---
    â  
    >>> allSegments[1]
    ---begin segment---
    <music21.braille.segment BrailleSegment>
    Measure 2, Note Grouping 1:
    <music21.note.Note E>
    <music21.note.Note E>
    ===
    Measure 3, Note Grouping 1:
    <music21.note.Note G>
    <music21.note.Note G>
    <music21.note.Note G>
    ===
    Measure 4, Note Grouping 1:
    <music21.note.Note C>
    <music21.bar.Barline style=final>
    ===
    ---end segment---



.. function:: prepareBeamedNotes(music21Measure)


    Takes in a :class:`~music21.stream.Measure` and labels beamed notes
    of smaller value than an 8th with beamStart and beamContinue keywords
    in accordance with beaming rules in braille music.


    A more in-depth explanation of beaming in braille can be found in
    Chapter 15 of Introduction to Braille Music Transcription, Second
    Edition, by Mary Turner De Garmo.




    >>> from music21.braille import segment
    >>> from music21 import tinyNotation
    >>> tn = tinyNotation.TinyNotationStream("c16 c c c d d d d", "2/4")
    >>> tn = tn.makeNotation(cautionaryNotImmediateRepeat=False)
    >>> tn.show("text")
    {0.0} <music21.stream.Measure 1 offset=0.0>
        {0.0} <music21.clef.TrebleClef>
        {0.0} <music21.meter.TimeSignature 2/4>
        {0.0} <music21.note.Note C>
        {0.25} <music21.note.Note C>
        {0.5} <music21.note.Note C>
        {0.75} <music21.note.Note C>
        {1.0} <music21.note.Note D>
        {1.25} <music21.note.Note D>
        {1.5} <music21.note.Note D>
        {1.75} <music21.note.Note D>
        {2.0} <music21.bar.Barline style=final>
    >>> measure = tn[0]
    >>> segment.prepareBeamedNotes(measure)
    >>> measure.notes[0].beamStart
    True
    >>> measure.notes[1].beamContinue
    True
    >>> measure.notes[2].beamContinue
    True
    >>> measure.notes[3].beamContinue
    True



.. function:: prepareSlurredNotes(music21Part, slurLongPhraseWithBrackets=True, showShortSlursAndTiesTogether=False, showLongSlursAndTiesTogether=False)


    Takes in a :class:`~music21.stream.Part` and three keywords:

    * slurLongPhraseWithBrackets
    * showShortSlursAndTiesTogether
    * showLongSlursAndTiesTogether


    For any slurs present in the Part, the appropriate notes are labeled
    with attributes indicating where to put the symbols that represent
    slurring in braille. For purposes of slurring in braille, there is
    a distinction between short and long phrases. In a short phrase, a
    slur covers up to four notes. A short slur symbol should follow each
    note except the last.




    >>> import copy
    >>> from music21.braille import segment
    >>> from music21 import spanner
    >>> from music21 import tinyNotation
    >>> short = tinyNotation.TinyNotationStream("c4 d e","3/4")
    >>> s1 = spanner.Slur(short.notes[0],short.notes[-1])
    >>> short.append(s1)
    >>> short.show("text")
    {0.0} <music21.meter.TimeSignature 3/4>
    {0.0} <music21.note.Note C>
    {1.0} <music21.note.Note D>
    {2.0} <music21.note.Note E>
    {3.0} <music21.spanner.Slur <music21.note.Note C><music21.note.Note E>>
    >>> shortA = copy.deepcopy(short)
    >>> segment.prepareSlurredNotes(shortA)
    >>> shortA.notes[0].shortSlur
    True
    >>> shortA.notes[1].shortSlur
    True


    In a long phrase, a slur covers more than four notes. There are two
    options for slurring long phrases. The first is by using the bracket
    slur. By default, slurLongPhraseWithBrackets is True. The opening
    bracket sign is put before the first note, and the closing bracket
    sign is put before the last note.




    >>> long = tinyNotation.TinyNotationStream("c8 d e f g a","3/4")
    >>> s2 = spanner.Slur(long.notes[0],long.notes[-1])
    >>> long.append(s2)
    >>> long.show("text")
    {0.0} <music21.meter.TimeSignature 3/4>
    {0.0} <music21.note.Note C>
    {0.5} <music21.note.Note D>
    {1.0} <music21.note.Note E>
    {1.5} <music21.note.Note F>
    {2.0} <music21.note.Note G>
    {2.5} <music21.note.Note A>
    {3.0} <music21.spanner.Slur <music21.note.Note C><music21.note.Note A>>
    >>> longA = copy.deepcopy(long)
    >>> segment.prepareSlurredNotes(longA)
    >>> longA.notes[0].beginLongBracketSlur
    True
    >>> longA.notes[-1].endLongBracketSlur
    True


    The other way is by using the double slur, setting slurLongPhraseWithBrackets
    to False. The opening sign of the double slur is put after the first note
    (i.e. before the second note) and the closing sign is put before the last
    note (i.e. before the second to last note).




    >>> longB = copy.deepcopy(long)
    >>> segment.prepareSlurredNotes(longB, slurLongPhraseWithBrackets=False)
    >>> longB.notes[1].beginLongDoubleSlur
    True
    >>> longB.notes[-2].endLongDoubleSlur
    True


    In the event that slurs and ties are shown together in print, the slur is
    redundant. Examples are shown for slurring a short phrase; the process is
    identical for slurring a long phrase.


    Below, a tie has been added between the first two notes of the short phrase
    defined above. If showShortSlursAndTiesTogether is set to its default value of
    False, then the slur on either side of the phrase is reduced by the amount that
    ties are present, as shown below.




    >>> from music21 import tie
    >>> short.notes[0].tie = tie.Tie("start")
    >>> shortB = copy.deepcopy(short)
    >>> segment.prepareSlurredNotes(shortB)
    >>> shortB.notes[0].shortSlur
    Traceback (most recent call last):
    AttributeError: 'Note' object has no attribute 'shortSlur'
    >>> shortB.notes[0].tie
    <music21.tie.Tie start>
    >>> shortB.notes[1].shortSlur
    True


    If showShortSlursAndTiesTogether is set to True, then the slurs and ties are
    shown together (i.e. the note has both a shortSlur and a tie).




    >>> shortC = copy.deepcopy(short)
    >>> segment.prepareSlurredNotes(shortC, showShortSlursAndTiesTogether=True)
    >>> shortC.notes[0].shortSlur
    True
    >>> shortC.notes[0].tie
    <music21.tie.Tie start>



.. function:: setAffinityCode(music21Object)


    Takes in a :class:`~music21.base.Music21Object`, and does two things:

    * Modifies the :attr:`~music21.base.Music21Object.classSortOrder` attribute of the
      object to fit the slightly modified ordering of objects in braille music.

    * Adds an affinity code to the object. This code indicates which surrounding
      objects the object should be grouped with.


    A BrailleSegmentException is raised if an affinity code cannot be assigned to
    the object.


    As seen in the following example, the affinity code of a :class:`~music21.note.Note`
    and a :class:`~music21.clef.TrebleClef` are the same, because they should be grouped
    together. However, the classSortOrder indicates that the TrebleClef should come first
    in the braille.



    >>> from music21.braille import segment
    >>> from music21 import note
    >>> from music21 import clef
    >>> n1 = note.Note("D5")
    >>> setAffinityCode(n1)
    >>> n1.affinityCode
    9
    >>> n1.classSortOrder
    10
    >>> c1 = clef.TrebleClef()
    >>> setAffinityCode(c1)
    >>> c1.affinityCode
    9
    >>> c1.classSortOrder
    7



.. function:: splitMeasure(music21Measure, value=2, beatDivisionOffset=0, useTimeSignature=None)


    Takes a :class:`~music21.stream.Measure`, divides it in two parts, and returns a
    :class:`~music21.stream.Part` containing the two halves. The parameters are as
    follows:

    * value => the number of partitions to split a time signature into. The first half will
      contain all elements found within the offsets of the first partition, while the last
      half will contain all other elements.
    * beatDivisionOffset => Adjusts the end offset of the first partition by a certain amount
      of beats to the left.
    * useTimeSignature => In the event that the Measure comes from the middle of a Part
      and thus does not define an explicit :class:`~music21.meter.TimeSignature`. If not
      provided, a TimeSignature is retrieved by using :meth:`~music21.stream.Measure.bestTimeSignature`.



.. function:: splitNoteGrouping(noteGrouping, value=2, beatDivisionOffset=0)


    Almost identical to :meth:`~music21.braille.segment.splitMeasure`, but
    functions on a :class:`~music21.braille.segment.BrailleElementGrouping`
    instead.



BrailleElementGrouping
----------------------

Inherits from: list

.. class:: BrailleElementGrouping()



    Intended to be a list of objects which should be displayed
    without a space in braille.



    >>> from music21.braille import segment
    >>> from music21 import note
    >>> bg = segment.BrailleElementGrouping()
    >>> bg.append(note.Note("C4"))
    >>> bg.append(note.Note("D4"))
    >>> bg.append(note.Rest())
    >>> bg.append(note.Note("F4"))
    >>> bg
    <music21.note.Note C>
    <music21.note.Note D>
    <music21.note.Rest rest>
    <music21.note.Note F>



    **BrailleElementGrouping** **attributes**

        .. attribute:: numRepeats

            The number of times this grouping is repeated.


        .. attribute:: withHyphen

            If True, this grouping will end with a music hyphen.


        .. attribute:: keySignature

            The last :class:`~music21.key.KeySignature` preceding the grouping.


        .. attribute:: showClefSigns

            If true, clef signs are shown in braille. Representation of music in braille is not                 dependent upon clefs and staves, so the clef signs would be displayed for referential or historical purposes.


        .. attribute:: timeSignature

            The last :class:`~music21.meter.TimeSignature` preceding the grouping.


        .. attribute:: descendingChords

            True if a :class:`~music21.chord.Chord` should be spelled from highest to lowest pitch                 in braille, False if the opposite is the case.


        Attributes without Documentation: `upperFirstInNoteFingering`

    **BrailleElementGrouping** **methods**

        Methods inherited from list: :meth:`~__builtin__.list.append`, :meth:`~__builtin__.list.count`, :meth:`~__builtin__.list.extend`, :meth:`~__builtin__.list.index`, :meth:`~__builtin__.list.insert`, :meth:`~__builtin__.list.pop`, :meth:`~__builtin__.list.remove`, :meth:`~__builtin__.list.reverse`, :meth:`~__builtin__.list.sort`


BrailleSegment
--------------

Inherits from: :class:`~collections.defaultdict`, dict

.. class:: BrailleSegment()



    A segment is "a group of measures occupying more than one braille line."
    Music is divided into segments so as to "present the music to the reader
    in a meaningful manner and to give him convenient reference points to
    use in memorization" (BMTM, 71).



    **BrailleSegment** **attributes**

        .. attribute:: cancelOutgoingKeySig

            If True, the previous key signature should be cancelled immediately before a new key signature is encountered.


        .. attribute:: endHyphen

            If True, then the last :class:`~music21.braille.segment.BrailleElementGrouping` of this segment will be followed by a music hyphen.                 The last grouping is incomplete, because a segment break occured in the middle of a measure.


        .. attribute:: dummyRestLength

            For a given positive integer n, adds n "dummy rests" near the beginning of a segment. Designed for test purposes, as they                 are used to demonstrate measure division at the end of braille lines.


        .. attribute:: measureNumberWithDot

            If True, then the initial measure number of this segment should be followed by a dot. This segment                 is starting in the middle of a measure.


        .. attribute:: showHeading

            If True, then a braille heading is displayed. See :meth:`~music21.braille.basic.transcribeHeading` for more details on headings.


        .. attribute:: showFirstMeasureNumber

            If True, then a measure number is shown following the heading (if applicable) and preceding the music.


        .. attribute:: showHand

            If set to "right" or "left", shows the corresponding hand sign at the beginning of the first line.


        .. attribute:: suppressOctaveMarks

            If True, then all octave marks are suppressed. Designed for test purposes, as octave marks were not presented                 until Chapter 7 of BMTM.


        .. attribute:: maxLineLength

            The maximum amount of braille characters that should be present in a line. The standard is 40 characters.


        Attributes inherited from :class:`~collections.defaultdict`: :attr:`~collections.defaultdict.default_factory`

    **BrailleSegment** **methods**

        .. method:: addDummyRests(brailleText)

            No documentation.


        .. method:: addMeasureNumber(brailleText)


            Takes in a braille text instance and adds a measure number



        .. method:: consolidate()






        .. method:: extractHeading(brailleText)


            Extract a :class:`~music21.key.KeySignature`, :class:`~music21.meter.TimeSignature,
            :class:`~music21.tempo.TempoText` and :class:`~music21.tempo.MetronomeMark` and
            add an appropriate braille heading to the brailleText object inputted.



            >>> from music21.braille import segment
            >>> from music21 import key
            >>> from music21 import meter
            >>> from music21 import tempo




        .. method:: extractInaccordGrouping(brailleText)

            No documentation.


        .. method:: extractLongExpressionGrouping(brailleText)

            No documentation.


        .. method:: extractNoteGrouping(brailleText)

            No documentation.


        .. method:: extractSignatureGrouping(brailleText)

            No documentation.


        .. method:: extractTempoTextGrouping(brailleText)

            No documentation.


        .. method:: transcribe()


            Heading (if applicable)
            Measure Number
            Rest of Note Groupings



        Methods inherited from :class:`~collections.defaultdict`: :meth:`~collections.defaultdict.copy`

        Methods inherited from dict: :meth:`~__builtin__.dict.clear`, :meth:`~__builtin__.dict.fromkeys`, :meth:`~__builtin__.dict.get`, :meth:`~__builtin__.dict.has_key`, :meth:`~__builtin__.dict.items`, :meth:`~__builtin__.dict.iteritems`, :meth:`~__builtin__.dict.iterkeys`, :meth:`~__builtin__.dict.itervalues`, :meth:`~__builtin__.dict.keys`, :meth:`~__builtin__.dict.pop`, :meth:`~__builtin__.dict.popitem`, :meth:`~__builtin__.dict.setdefault`, :meth:`~__builtin__.dict.update`, :meth:`~__builtin__.dict.values`, :meth:`~__builtin__.dict.viewitems`, :meth:`~__builtin__.dict.viewkeys`, :meth:`~__builtin__.dict.viewvalues`


