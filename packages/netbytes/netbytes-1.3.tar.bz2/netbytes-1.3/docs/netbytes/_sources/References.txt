Public References
=================

.. function:: build(model)

    :rtype: :class:`Node` instance

    :arg str model: model used to builf the actions tree

    Parse the *model* and build a tree according to it

.. function:: p_build(model[,filename])

    :rtype: :class:`Node` instance

    :arg str model: model used to builf the actions tree
    :arg str filenamename: filename used to store or load a serialized copy of the built tree. The defaults value is '.actions_tree'

    This function is the same as :func:`build` except that it make an SHA512 checksum of the model, and compare it with the one stored in the file named *filename*. If the file exists and the checksum stored in it is the same, it loads and return the previously built tree. Else, it build the tree, creates the file *filename* and store in it the checksum and the pickled tree.

.. function:: data_encode(iterable[, size_num_bytes])

    :rtype: :obj:`str`

    :arg iterable iterable: the *iterable* object must contain only :obj:`str`
    :arg int size_num_bytes: number of bytes that will be used to represent a size, default is 2

    returns a :obj:`str` containing all the :obj:`str` in *iterable* along with their size

.. function:: data_decode(data[, size_num_bytes])

    :rtype: :obj:`list`

    :arg str data: the :obj:`str` produced by :func:`data_encode`
    :arg int size_num_bytes: number of bytes that will be used to represent a size, default is 2

    return all the original :obj:`str`
    be sure to use the same *size_num_bytes* as the one you used in :func:`data_encode`

.. function:: p_data_encode(iterable[, size_num_bytes])

    :rtype: :obj:`str`

    same as :meth:`data_encode`, except that *iterable* can be populated by any "pickleable" object. Uses *pickle.dumps(* obj *,2)* to serialize objects.

.. function:: p_data_decode(iterable[, size_num_bytes])

    :rtype: :obj:`list`

    recovers the list of objects serialized by :func:`p_data_decode`


