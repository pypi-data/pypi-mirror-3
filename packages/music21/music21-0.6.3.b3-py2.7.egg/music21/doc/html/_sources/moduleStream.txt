.. _moduleStream:

music21.stream
==============

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED. Edit the .py file directly

.. module:: music21.stream

The :class:`~music21.stream.Stream` and its subclasses, a subclass of the :class:`~music21.base.Music21Object`, is the fundamental container of offset-positioned notation and musical elements in music21. Common Stream subclasses, such as the :class:`~music21.stream.Measure` and :class:`~music21.stream.Score` objects, are defined in this module.




Stream
------

Inherits from: :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Stream(givenElements=None, *args, **keywords)


    This is the fundamental container for Music21Objects;
    objects may be ordered and/or placed in time based on
    offsets from the start of this container's offset.


    Like the base class, Music21Object, Streams have offsets,
    priority, id, and groups
    they also have an elements attribute which returns a list of elements;


    The Stream has a duration that is usually the
    release time of the chronologically last element in the Stream (that is,
    the highest onset plus duration of any element in the Stream).
    However, it can either explicitly set in which case we say that the
    duration is unlinked.


    Streams may be embedded within other Streams.


    The first element passed to the Stream is an optional list,
    tuple, or other Stream of music21 objects which is used to
    populate the Stream by inserting each object at its `.offset`
    property.  Other arguments and keywords are ignored, but are
    allowed so that subclassing the Stream is easier.




    >>> from music21 import *
    >>> s1 = stream.Stream()
    >>> s1.append(note.HalfNote('C#4'))
    >>> s1.append(note.QuarterNote('D5'))
    >>> s1.duration.quarterLength
    3.0
    >>> for thisNote in s1.notes:
    ...     print thisNote.octave
    4
    5


    Demonstration of starting a Stream with other elements,
    including embedded Streams (in this case, :class:`music21.stream.Part`,
    a Stream subclass):




    >>> c1 = clef.TrebleClef()
    >>> c1.offset = 0.0
    >>> n1 = note.EighthNote("E-6")
    >>> n1.offset = 1.0
    >>> p1 = stream.Part()
    >>> p1.offset = 0.0
    >>> p1.id = 'embeddedPart'
    >>> p1.append(note.Rest()) # quarter rest
    >>> s2 = stream.Stream([c1, n1, p1])
    >>> s2.show('text')
    {0.0} <music21.clef.TrebleClef>
    {0.0} <music21.stream.Part embeddedPart>
        {0.0} <music21.note.Rest rest>
    {1.0} <music21.note.Note E->




    **Stream** **attributes**

        .. attribute:: isFlat

            Boolean describing whether this Stream contains embedded sub-Streams or Stream subclasses (not flat).


        .. attribute:: autoSort

            Boolean describing whether the Stream is automatically sorted by offset whenever necessary.


        .. attribute:: isSorted

            Boolean describing whether the Stream is sorted or not.


        .. attribute:: flattenedRepresentationOf

            When this flat Stream is derived from another non-flat stream, a reference to the source Stream is stored here.


        Attributes without Documentation: `isMeasure`, `isStream`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.groups`

    **Stream** **properties**

        .. attribute:: notes


            The notes property of a Stream returns a new Stream object
            that consists only of the notes (including
            :class:`~music21.note.Note`,
            :class:`~music21.chord.Chord`, etc.) found
            in the stream. This excludes :class:`~music21.note.Rest` objects.


            In versions of music21 before alpha 6, the "notes" property
            also returned rests.  Thus you may find some old programs that
            use "notes" and expect to find rests.  These programs should
            be converted to use notesAndRests




            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> k1 = key.KeySignature(0) # key of C
            >>> n1 = note.Note('B')
            >>> r1 = note.Rest()
            >>> c1 = chord.Chord(['A', 'B-'])
            >>> s1.append([k1, n1, r1, c1])
            >>> s1.show('text')
            {0.0} <music21.key.KeySignature of no sharps or flats>
            {0.0} <music21.note.Note B>
            {1.0} <music21.note.Rest rest>
            {2.0} <music21.chord.Chord A B->
            ⁠ 
            >>> s1.notes.show('text')
            {0.0} <music21.note.Note B>
            {2.0} <music21.chord.Chord A B->



        .. attribute:: pitches


            Returns all :class:`~music21.pitch.Pitch` objects found in any
            element in the Stream as a Python List. Elements such as
            Streams, and Chords will have their Pitch objects accumulated as
            well. For that reason, a flat representation is not required.


            Pitch objects are returned in a List, not a Stream.  This usage
            differs from the .notes property, but makes sense since Pitch
            objects usually have by default a Duration of zero. This is an important difference
            between them and :class:`music21.note.Note` objects.




            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> partOnePitches = a.parts[0].pitches
            >>> len(partOnePitches)
            25
            >>> partOnePitches[0:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4]


            Note that the pitches returned above are
            objects, not text:




            >>> partOnePitches[0].octave
            4


            Since pitches are found from within internal objects,
            flattening the stream is not required:




            >>> len(a.pitches)
            104


            Pitch objects are also retrieved when stored directly on a Stream.




            >>> from music21 import *
            >>> pitch1 = pitch.Pitch()
            >>> st1 = stream.Stream()
            >>> st1.append(pitch1)
            >>> foundPitches = st1.pitches
            >>> len(foundPitches)
            1
            >>> foundPitches[0] is pitch1
            True



            Chords get their pitches found as well:



            >>> c = chord.Chord(['C4','E4','G4'])
            >>> n = note.Note('F#4')
            >>> m = stream.Measure()
            >>> m.append(n)
            >>> m.append(c)
            >>> m.pitches
            [F#4, C4, E4, G4]




        .. attribute:: atSoundingPitch


            Get or set the atSoundingPith status. Valid values are True, False, and 'unknown'.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.atSoundingPitch = True
            >>> s.atSoundingPitch = False
            >>> s.atSoundingPitch = 'unknown'
            >>> s.atSoundingPitch
            'unknown'
            >>> s.atSoundingPitch = 'junk'
            Traceback (most recent call last):
            StreamException: not a valid at sounding pitch value: junk



        .. attribute:: beat

            No documentation.


        .. attribute:: beatDuration

            unlike other Music21Objects, streams always have beatDuration of None


        .. attribute:: beatStr

            unlike other Music21Objects, streams always have beatStr (beat string) of None


        .. attribute:: beatStrength

            unlike other Music21Objects, streams always have beatStrength of None


        .. attribute:: derivationChain

            Return a list Stream subclasses that this Stream was derved from. This provides a way to obtain all Streams that this element passed through, such as those created by getElementsByClass or flat searches.



            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('GeneralNote')
            >>> s3 = s2.getElementsByClass('Note')
            >>> s3.derivationChain == [s2, s1]
            True



        .. attribute:: derivationMethod


            Returns or sets a string representing how
            this stream was derived from another stream.


            There are currently no limitations on this string.
            This might change.

            For instance:



            >>> from music21 import *
            >>> s1 = converter.parse("C2 D2", "2/4")
            >>> s1m = s1.makeMeasures()
            >>> s1m1 = s1m.measure(1)
            >>> s1m1.derivesFrom is s1m
            True
            >>> s1m1.derivationMethod
            'measure'
            >>> s1m1.derivationMethod = 'getElementsByClass'
            >>> s1m1.derivationMethod
            'getElementsByClass'



        .. attribute:: derivesFrom

            Return a reference to the Stream that created this Stream, if such a Stream exists.



            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('Note')
            >>> s2.derivesFrom == s1
            True



        .. attribute:: duration


            Returns the total duration of the Stream, from the beginning of the stream until the end of the final element.
            May be set independently by supplying a Duration object.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> q = note.QuarterNote()
            >>> a.repeatInsert(q, [0,1,2,3])
            >>> a.highestOffset
            3.0
            >>> a.highestTime
            4.0
            >>> a.duration.quarterLength
            4.0


            Advanced usage: override the duration from what is set:




            >>> newDuration = duration.Duration("half")
            >>> newDuration.quarterLength
            2.0
            ⁠ 
            >>> a.duration = newDuration
            >>> a.duration.quarterLength
            2.0


            Note that the highestTime for the stream is the same
            whether duration is overriden or not:




            >>> a.highestTime
            4.0



        .. attribute:: elements

            The low-level storage list of all Streams. Directly getting, setting, and manipulating this list is reserved for advanced usage.

            When setting .elements, a list of Music21Objects can be provided, or a complete Stream. If a complete Stream is provided, elements are extracted from that Stream. This has the advantage of transferring offset correctly and geting _endElements.



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(10))
            >>> b = stream.Stream()
            >>> b.repeatInsert(note.Note("C"), range(10))
            >>> b.offset = 6
            >>> c = stream.Stream()
            >>> c.repeatInsert(note.Note("C"), range(10))
            >>> c.offset = 12
            >>> b.insert(c)
            >>> b.isFlat
            False
            >>> a.isFlat
            True
            >>> a.elements = b # assigning from a Stream
            >>> a.isFlat
            False
            >>> len(a.flat.notes) == len(b.flat.notes) == 20
            True



        .. attribute:: finalBarline


            Get or set the final barline of this Stream's Measures, if and only if there are Measures defined as elements in this Stream. This method will not create Measures if non exist. Setting a final barline to a Stream that does not have Measure will raise an exception.

            This property also works on Scores that contain one or more Parts. In that case a lost of barlines can be used to set the final barline.



            >>> from music21 import *
            >>> s = corpus.parse('bwv66.6')
            >>> s.finalBarline = 'none'
            >>> s.finalBarline
            [<music21.bar.Barline style=none>, <music21.bar.Barline style=none>, <music21.bar.Barline style=none>, <music21.bar.Barline style=none>]




        .. attribute:: flat


            A very important read-only property that returns a new Stream
            that has all sub-containers "flattened" within it,
            that is, it returns a new Stream where no elements nest within
            other elements.


            Here is a simple example of the usefulness of .flat.  We
            will create a Score with two Parts in it, each with two Notes:




            >>> from music21 import *
            ⁠ 
            >>> sc = stream.Score()
            >>> p1 = stream.Part()
            >>> p1.id = 'part1'
            >>> n1 = note.Note('C4')
            >>> n2 = note.Note('D4')
            >>> p1.append(n1)
            >>> p1.append(n2)



            >>> p2 = stream.Part()
            >>> p2.id = 'part2'
            >>> n3 = note.Note('E4')
            >>> n4 = note.Note('F4')
            >>> p2.append(n3)
            >>> p2.append(n4)
            ⁠ 
            >>> sc.insert(0, p1)
            >>> sc.insert(0, p2)


            When we look at sc, we will see only the two parts:




            >>> sc.elements
            [<music21.stream.Part part1>, <music21.stream.Part part2>]


            we can get at the notes by using the indices of the
            stream to get the parts and then looking at the .elements
            there:




            >>> sc[0].elements
            [<music21.note.Note C>, <music21.note.Note D>]
            >>> sc.getElementById('part2').elements
            [<music21.note.Note E>, <music21.note.Note F>]


            but if we want to get all the notes, the easiest way
            is via calling .flat on sc and looking at the elements
            there:




            >>> sc.flat.elements
            [<music21.note.Note C>, <music21.note.Note E>, <music21.note.Note D>, <music21.note.Note F>]


            Flattening a stream is a great way to get at all the notes in
            a larger piece.  For instance if we load a four-part
            Bach chorale into music21 from the integrated corpus, it
            will appear at first that there are no notes in the piece:




            >>> bwv66 = corpus.parse('bach/bwv66.6')
            >>> len(bwv66.notes)
            0


            This is because all the notes in the piece lie within :class:`music21.stream.Measure`
            objects and those measures lie within :class:`music21.stream.Part`
            objects.  It'd be a pain to navigate all the way through all those
            objects just to count notes.  Fortunately we can get a Stream of
            all the notes in the piece with .flat.notes and then use the
            length of that Stream to count notes:




            >>> bwv66flat = bwv66.flat
            >>> len(bwv66flat.notes)
            165



            If you look back to our simple example of four notes above,
            you can see that the E (the first note in part2) comes before the D
            (the second note of part1).  This is because the flat stream
            is automatically sorted like all streams are by default.  The
            next example shows how to change this behavior.




            >>> s = stream.Stream()
            >>> s.autoSort = False
            >>> s.repeatInsert(note.Note("C#"), [0, 2, 4])
            >>> s.repeatInsert(note.Note("D-"), [1, 3, 5])
            >>> s.isSorted
            False
            >>> g = ""
            >>> for myElement in s:
            ...    g += "%s: %s; " % (myElement.offset, myElement.name)
            >>> g
            '0.0: C#; 2.0: C#; 4.0: C#; 1.0: D-; 3.0: D-; 5.0: D-; '
            >>> y = s.sorted
            >>> y.isSorted
            True
            >>> g = ""
            >>> for myElement in y:
            ...    g += "%s: %s; " % (myElement.offset, myElement.name)
            >>> g
            '0.0: C#; 1.0: D-; 2.0: C#; 3.0: D-; 4.0: C#; 5.0: D-; '
            ⁠ 
            >>> q = stream.Stream()
            >>> for i in range(5):
            ...   p = stream.Stream()
            ...   p.repeatInsert(music21.Music21Object(), range(5))
            ...   q.insert(i * 10, p)
            >>> len(q)
            5
            >>> qf = q.flat
            >>> len(qf)
            25
            >>> qf[24].offset
            44.0



        .. attribute:: highestOffset

            Get start time of element with the highest offset in the Stream.
            Note the difference between this property and highestTime
            which gets the end time of the highestOffset




            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for offset in [0, 4, 8]:
            ...     n = note.WholeNote('G#')
            ...     stream1.insert(offset, n)
            >>> stream1.highestOffset
            8.0
            >>> stream1.highestTime
            12.0



        .. attribute:: highestTime


            Returns the maximum of all Element offsets plus their Duration
            in quarter lengths. This value usually represents the last
            "release" in the Stream.


            Stream.duration is usually equal to the highestTime
            expressed as a Duration object, but it can be set separately
            for advanced operations.


            Example: Insert a dotted half note at position 0 and see where
            it cuts off:




            >>> from music21 import *
            >>> n = note.Note('A-')
            >>> n.quarterLength = 3
            >>> p1 = stream.Stream()
            >>> p1.insert(0, n)
            >>> p1.highestTime
            3.0


            Now insert in the same stream, the dotted half note
            at positions 1, 2, 3, 4 and see when the final note cuts off:





            >>> p1.repeatInsert(n, [1, 2, 3, 4])
            >>> p1.highestTime
            7.0



        .. attribute:: isGapless

            No documentation.


        .. attribute:: lily


            returns or sets the lilypond output for the Stream.
            Note that (for now at least), setting the Lilypond output for a Stream does not
            change the stream itself.  It's just a way of overriding what is printed when .lily
            is called.



            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.append(clef.BassClef())
            >>> s1.append(meter.TimeSignature("3/4"))
            >>> k1 = key.KeySignature(5)
            >>> k1.mode = 'minor'
            >>> s1.append(k1)
            >>> s1.append(note.Note("B-3"))   # quarter note
            >>> s1.append(note.HalfNote("C#2"))
            >>> s1.lily
             { \clef "bass"  \time 3/4  \key gis \minor bes4 cis,2  }




        .. attribute:: lowestOffset


            Get the start time of the Element with the lowest offset in the Stream.



            >>> from music21 import *
            ⁠ 
            >>> stream1 = stream.Stream()
            >>> for x in range(3,5):
            ...     n = note.Note('G#')
            ...     stream1.insert(x, n)
            ...
            >>> stream1.lowestOffset
            3.0


            If the Stream is empty, then the lowest offset is 0.0:




            >>> stream2 = stream.Stream()
            >>> stream2.lowestOffset
            0.0




        .. attribute:: metadata


            Get or set the :class:`~music21.metadata.Metadata` object
            found at the beginning (offset 0) of this Stream.



            >>> from music21 import *
            ⁠ 
            >>> s = stream.Stream()
            >>> s.metadata = metadata.Metadata()
            >>> s.metadata.composer = 'frank'
            >>> s.metadata.composer
            'frank'



        .. attribute:: midiFile

            Get or set a :class:`music21.midi.base.MidiFile` object.



        .. attribute:: musicxml

            Return a complete MusicXML reprsentatoin as a string.



        .. attribute:: mx

            Create and return a musicxml Score object.



            >>> from music21 import *
            >>> n1 = note.Note()
            >>> measure1 = stream.Measure()
            >>> measure1.insert(n1)
            >>> str1 = stream.Stream()
            >>> str1.insert(measure1)
            >>> mxScore = str1.mx



        .. attribute:: notesAndRests


            The notesAndRests property of a Stream returns a new Stream object
            that consists only of the notes and rests (including
            :class:`~music21.note.Note`,
            :class:`~music21.chord.Chord`,
            :class:`~music21.note.Rest`, etc.) found
            in the stream.


            In versions of music21 before alpha 6, the "notes" property
            also returned rests.  Thus you may find some old programs that
            use "notes" and expect to find rests.  These programs should
            be converted to use notesAndRests





            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> k1 = key.KeySignature(0) # key of C
            >>> n1 = note.Note('B')
            >>> c1 = chord.Chord(['A', 'B-'])
            >>> s1.append([k1, n1, c1])
            >>> s1.show('text')
            {0.0} <music21.key.KeySignature of no sharps or flats>
            {0.0} <music21.note.Note B>
            {1.0} <music21.chord.Chord A B->
            ⁠ 
            >>> notes1 = s1.notesAndRests
            >>> notes1.show('text')
            {0.0} <music21.note.Note B>
            {1.0} <music21.chord.Chord A B->



        .. attribute:: offsetMap


            Returns a list where each element is a dictionary
            consisting of the 'offset' of each element in a stream, the
            'endTime' (that is, the offset plus the duration) and the
            'element' itself.  Also contains a 'voiceIndex' entry which
            contains the voice number of the element, or None if there
            are no voices.



            >>> from music21 import *
            >>> n1 = note.QuarterNote()
            >>> c1 = clef.AltoClef()
            >>> n2 = note.HalfNote()
            >>> s1 = stream.Stream()
            >>> s1.append([n1, c1, n2])
            >>> om = s1.offsetMap
            >>> om[2]['offset']
            1.0
            >>> om[2]['endTime']
            3.0
            >>> om[2]['element'] is n2
            True
            >>> om[2]['voiceIndex']



        .. attribute:: rootDerivation

            Return a reference to the oldest source of this Stream; that is, chain calls to derivesFrom until we get to a Stream that cannot be further derived.



            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('Note')
            >>> s2.derivesFrom == s1
            True



        .. attribute:: seconds


            Get or set the the duration of this Stream in seconds, assuming that this object contains a :class:`~music21.tempo.MetronomeMark` or :class:`~music21.tempo.MetricModulation`.



            >>> from music21 import *
            >>> s = corpus.parse('bwv66.6') # piece without a tempo
            >>> sFlat = s.flat
            >>> sFlat.insert(0, tempo.MetronomeMark('adagio'))
            >>> sFlat.seconds
            38.57142857...



        .. attribute:: secondsMap


            Returns a list where each element is a dictionary consisting of the 'offsetSeconds' in seconds of each element in a Stream, the 'duration' in seconds, the 'endTimeSeconds' in seconds (that is, the offset plus the duration), and the 'element' itself. Also contains a 'voiceIndex' entry which contains the voice number of the element, or None if there
            are no voices.



            >>> from music21 import *
            >>> mm1 = tempo.MetronomeMark(number=120)
            >>> n1 = note.QuarterNote()
            >>> c1 = clef.AltoClef()
            >>> n2 = note.HalfNote()
            >>> s1 = stream.Stream()
            >>> s1.append([mm1, n1, c1, n2])
            >>> om = s1.secondsMap
            >>> om[3]['offsetSeconds']
            0.5
            >>> om[3]['endTimeSeconds']
            1.5
            >>> om[3]['element'] is n2
            True
            >>> om[3]['voiceIndex']



        .. attribute:: semiFlat


            Returns a flat-like Stream representation.
            Stream sub-classed containers, such as Measure or Part,
            are retained in the output Stream, but positioned at their
            relative offset.



            >>> from music21 import *
            >>> s = stream.Stream()
            ⁠ 
            >>> p1 = stream.Part()
            >>> p1.id = 'part1'
            >>> n1 = note.Note('C5')
            >>> p1.append(n1)



            >>> p2 = stream.Part()
            >>> p2.id = 'part2'
            >>> n2 = note.Note('D5')
            >>> p2.append(n2)
            ⁠ 
            >>> s.insert(0, p1)
            >>> s.insert(0, p2)
            >>> sf = s.semiFlat
            >>> sf.elements
            [<music21.stream.Part part1>, <music21.note.Note C>, <music21.stream.Part part2>, <music21.note.Note D>]
            >>> sf[0]
            <music21.stream.Part part1>
            >>> sf[1]
            <music21.note.Note C>
            >>> sf[0][0]
            <music21.note.Note C>




        .. attribute:: sorted


            Returns a new Stream where all the elements are sorted according to offset time, then
            priority, then classSortOrder (so that, for instance, a Clef at offset 0 appears before
            a Note at offset 0)

            if this Stream is not flat, then only the highest elements are sorted.  To sort all,
            run myStream.flat.sorted

            For instance, here is an unsorted Stream



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.autoSort = False # if true, sorting is automatic
            >>> s.insert(1, note.Note("D"))
            >>> s.insert(0, note.Note("C"))
            >>> s.show('text')
            {1.0} <music21.note.Note D>
            {0.0} <music21.note.Note C>


            But a sorted version of the Stream puts the C first:




            >>> s.sorted.show('text')
            {0.0} <music21.note.Note C>
            {1.0} <music21.note.Note D>


            While the original stream remains unsorted:




            >>> s.show('text')
            {1.0} <music21.note.Note D>
            {0.0} <music21.note.Note C>




        .. attribute:: spannerBundle

            A high-level object for Spanner management. This is only a gettable property.



        .. attribute:: spanners


            Return all :class:`~music21.spanner.Spanner` objects
            (things such as Slurs, long trills, or anything that
            connects many objects)
            into a :class:`~music21.stream.Stream` or Stream subclass.




            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(0, spanner.Slur())
            >>> s.insert(0, spanner.Slur())
            >>> len(s.spanners)
            2



        .. attribute:: voices

            Return all :class:`~music21.stream.Voices` objects in a :class:`~music21.stream.Stream` or Stream subclass.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(0, stream.Voice())
            >>> s.insert(0, stream.Voice())
            >>> len(s.voices)
            2



        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Stream** **methods**

        .. method:: append(others)


            Add a Music21Object (including another Stream) to the end of the current Stream.

            If given a list, will append each element in order after the previous one.

            The "end" of the stream is determined by the `highestTime` property
            (that is the latest "release" of an object, or directly after the last
            element ends).

            runs fast for multiple addition and will preserve isSorted if True




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> notes = []
            >>> for x in range(0,3):
            ...     n = note.Note('G#')
            ...     n.duration.quarterLength = 3
            ...     notes.append(n)
            >>> a.append(notes[0])
            >>> a.highestOffset, a.highestTime
            (0.0, 3.0)
            >>> a.append(notes[1])
            >>> a.highestOffset, a.highestTime
            (3.0, 6.0)
            >>> a.append(notes[2])
            >>> a.highestOffset, a.highestTime
            (6.0, 9.0)
            >>> notes2 = []


            since notes are not embedded in Elements here, their offset
            changes when they are added to a stream!




            >>> for x in range(0,3):
            ...     n = note.Note("A-")
            ...     n.duration.quarterLength = 3
            ...     n.offset = 0
            ...     notes2.append(n)
            >>> a.append(notes2) # add em all again
            >>> a.highestOffset, a.highestTime
            (15.0, 18.0)
            >>> a.isSequence()
            True


            Adding a note that already has an offset set does nothing different
            from above!  That is, it is still added to the end of the Stream:




            >>> n3 = note.Note("B-")
            >>> n3.offset = 1
            >>> n3.duration.quarterLength = 3
            >>> a.append(n3)
            >>> a.highestOffset, a.highestTime
            (18.0, 21.0)
            >>> n3.getOffsetBySite(a)
            18.0



        .. method:: insert(offsetOrItemOrList, itemOrNone=None, ignoreSort=False, setActiveSite=True)


            Inserts an item(s) at the given offset(s).

            If `ignoreSort` is True then the inserting does not
            change whether the Stream is sorted or not (much faster if you're going to be inserting dozens
            of items that don't change the sort status)


            The `setActiveSite` parameter should nearly always be True; only for
            advanced Stream manipulation would you not change
            the activeSite after inserting an element.


            Has three forms: in the two argument form, inserts an element at the given offset:




            >>> from music21 import *
            ⁠ 
            >>> st1 = stream.Stream()
            >>> st1.insert(32, note.Note("B-"))
            >>> st1.highestOffset
            32.0


            In the single argument form with an object, inserts the element at its stored offset:




            >>> n1 = note.Note("C#")
            >>> n1.offset = 30.0
            >>> st1 = stream.Stream()
            >>> st1.insert(n1)
            >>> st2 = stream.Stream()
            >>> st2.insert(40.0, n1)
            >>> n1.getOffsetBySite(st1)
            30.0


            In single argument form with a list, the list should contain pairs that alternate
            offsets and items; the method then, obviously, inserts the items
            at the specified offsets:




            >>> n1 = note.Note("G")
            >>> n2 = note.Note("F#")
            >>> st3 = stream.Stream()
            >>> st3.insert([1.0, n1, 2.0, n2])
            >>> n1.getOffsetBySite(st3)
            1.0
            >>> n2.getOffsetBySite(st3)
            2.0
            >>> len(st3)
            2




        .. method:: insertAndShift(offsetOrItemOrList, itemOrNone=None)

            Insert an item at a specified or native offset, and shit any elements found in the Stream to start at the end of the added elements.

            This presently does not shift elements that have durations that extend into the lowest insert position.



            >>> from music21 import *
            ⁠ 
            >>> st1 = stream.Stream()
            >>> st1.insertAndShift(32, note.Note("B-"))
            >>> st1.highestOffset
            32.0
            >>> st1.insertAndShift(32, note.Note("B-"))
            >>> st1.highestOffset
            33.0


            In the single argument form with an object, inserts the element at its stored offset:




            >>> n1 = note.Note("C#")
            >>> n1.offset = 30.0
            >>> n2 = note.Note("C#")
            >>> n2.offset = 30.0
            >>> st1 = stream.Stream()
            >>> st1.insertAndShift(n1)
            >>> st1.insertAndShift(n2) # should shift offset of n1
            >>> n1.getOffsetBySite(st1)
            31.0
            >>> n2.getOffsetBySite(st1)
            30.0
            >>> st2 = stream.Stream()
            >>> st2.insertAndShift(40.0, n1)
            >>> st2.insertAndShift(40.0, n2)
            >>> n1.getOffsetBySite(st2)
            41.0


            In single argument form with a list, the list should contain pairs that alternate
            offsets and items; the method then, obviously, inserts the items
            at the specified offsets:




            >>> n1 = note.Note("G")
            >>> n2 = note.Note("F#")
            >>> st3 = stream.Stream()
            >>> st3.insertAndShift([1.0, n1, 2.0, n2])
            >>> n1.getOffsetBySite(st3)
            1.0
            >>> n2.getOffsetBySite(st3)
            2.0
            >>> len(st3)
            2



        .. method:: transpose(value, inPlace=False, classFilterList=['Note', 'Chord'])

            Transpose all specified classes in the
            Stream by the
            user-provided value. If the value is an integer, the
            transposition is treated in half steps. If the value is
            a string, any Interval string specification can be
            provided.

            returns a new Stream by default, but if the
            optional "inPlace" key is set to True then
            it modifies pitches in place.



            >>> from music21 import *
            ⁠ 
            >>> aInterval = interval.Interval('d5')



            >>> aStream = corpus.parse('bach/bwv324.xml')
            >>> part = aStream.parts[0]
            >>> aStream.parts[0].pitches[:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4]
            >>> bStream = aStream.parts[0].flat.transpose('d5')
            >>> bStream.pitches[:10]
            [F5, A-5, F5, F5, F5, F5, G-5, F5, E-5, E-5]
            >>> aStream.parts[0].pitches[:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4]
            >>> cStream = bStream.flat.transpose('a4')
            >>> cStream.pitches[:10]
            [B5, D6, B5, B5, B5, B5, C6, B5, A5, A5]
            ⁠ 
            >>> cStream.flat.transpose(aInterval, inPlace=True)
            >>> cStream.pitches[:10]
            [F6, A-6, F6, F6, F6, F6, G-6, F6, E-6, E-6]



        .. method:: augmentOrDiminish(amountToScale, inPlace=False)


            Given a number greater than zero,
            multiplies the current quarterLength of the
            duration of each element by this number
            as well as their offset and returns a new Stream.
            Or if `inPlace` is
            set to True, modifies the durations of each
            element within the stream.


            A number of .5 will halve the durations and relative
            offset positions; a number of 2 will double the
            durations and relative offset positions.



            Note that the default for inPlace is the opposite
            of what it is for augmentOrDiminish on a Duration.
            This is done purposely to reflect the most common
            usage.




            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note()
            >>> s.repeatAppend(n, 10)
            >>> s.highestOffset, s.highestTime
            (9.0, 10.0)
            >>> s1 = s.augmentOrDiminish(2)
            >>> s1.highestOffset, s1.highestTime
            (18.0, 20.0)
            >>> s1 = s.augmentOrDiminish(.5)
            >>> s1.highestOffset, s1.highestTime
            (4.5, 5.0)



        .. method:: scaleOffsets(amountToScale, anchorZero='lowest', anchorZeroRecurse=None, inPlace=True)


            Scale all offsets by a multiplication factor given
            in `amountToScale`. Durations are not altered.


            To augment or diminish a Stream,
            see the :meth:`~music21.stream.Stream.augmentOrDiminish` method.


            The `anchorZero` parameter determines if and/or where
            the zero offset is established for the set of
            offsets in this Stream before processing.
            Offsets are shifted to make either the lower
            or upper values the new zero; then offsets are scaled; then the shifts are removed. Accepted values are None (no offset shifting), "lowest", or "highest".


            The `anchorZeroRecurse` parameter determines the
            anchorZero for all embedded Streams, and Streams
            embedded within those Streams. If the lowest offset
            in an embedded Stream is non-zero, setting this value
            to None will a the space between the start of that
            Stream and the first element to be scaled. If the
            lowest offset in an embedded Stream is non-zero,
            setting this value to 'lowest' will not alter the
            space between the start of that Stream and the first
            element to be scaled.


            To shift all the elements in a Stream, see the
            :meth:`~music21.stream.Stream.shiftElements` method.





        .. method:: scaleDurations(amountToScale, inPlace=True)

            Scale all durations by a provided scalar. Offsets are not modified.

            To augment or diminish a Stream, see the :meth:`~music21.stream.Stream.augmentOrDiminish` method.




        .. method:: addGroupForElements(group, classFilter=None)


            Add the group to the groups attribute of all elements.
            if `classFilter` is set then only those elements whose objects
            belong to a certain class (or for Streams which are themselves of
            a certain class) are set.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> a.repeatAppend(note.Note('A-'), 30)
            >>> a.repeatAppend(note.Rest(), 30)
            >>> a.addGroupForElements('flute')
            >>> a[0].groups
            ['flute']
            >>> a.addGroupForElements('quietTime', note.Rest)
            >>> a[0].groups
            ['flute']
            >>> a[50].groups
            ['flute', 'quietTime']
            >>> a[1].groups.append('quietTime') # set one note to it
            >>> a[1].step = "B"
            >>> b = a.getElementsByGroup('quietTime')
            >>> len(b)
            31
            >>> c = b.getElementsByClass(note.Note)
            >>> len(c)
            1
            >>> c[0].name
            'B-'




        .. method:: allPlayingWhileSounding(el, elStream=None, requireClass=False)


            Returns a new Stream of elements in this stream that sound
            at the same time as `el`, an element presumably in another Stream.


            The offset of this new Stream is set to el's offset, while the
            offset of elements within the Stream are adjusted relative to
            their position with respect to the start of el.  Thus, a note
            that is sounding already when el begins would have a negative
            offset.  The duration of otherStream is forced
            to be the length of el -- thus a note sustained after el ends
            may have a release time beyond that of the duration of the Stream.


            as above, elStream is an optional Stream to look up el's offset in.


            The method always returns a Stream, but it might be an empty Stream.




        .. method:: analyze(*args, **keywords)


            Runs a particular analytical method on the contents of the
            stream to find its ambitus (range) or key.


            ambitus -- runs :class:`~music21.analysis.discrete.Ambitus`
            key -- runs :class:`~music21.analysis.discrete.KrumhanslSchmuckler`


            Some of these methods can take additional arguments.  For details on
            these arguments, see
            :func:`~music21.analysis.discrete.analyzeStream`.


            Example:




            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv66.6')
            >>> s.analyze('ambitus')
            <music21.interval.Interval m21>
            >>> s.analyze('key')
            <music21.key.Key of f# minor>


            Example: music21 allows you to automatically run an
            analysis to get the key of a piece or excerpt not
            based on the key signature but instead on the
            frequency with which some notes are used as opposed
            to others (first described by Carol Krumhansl).  For
            instance, a piece with mostly Cs and Gs, some Fs,
            and Ds, but fewer G#s, C#s, etc. is more likely to
            be in the key of C major than in D-flat major
            (or A minor, etc.).  You can easily get this analysis
            from a stream by running:




            >>> myStream = corpus.parse('luca/gloria')
            >>> analyzedKey = myStream.analyze('key')
            >>> analyzedKey
            <music21.key.Key of F major>


            analyzedKey is a :class:`~music21.key.Key`
            object with a few extra parameters.
            correlationCoefficient shows how well this key fits the
            profile of a piece in that key:




            >>> analyzedKey.correlationCoefficient
            0.86715...


            alternateInterpretations is a list of the other
            possible interpretations sorted from most likely to least:




            >>> analyzedKey.alternateInterpretations
            [<music21.key.Key of d minor>, <music21.key.Key of C major>, <music21.key.Key of g minor>,...]


            Each of these can be examined in turn to see its correlation coefficient:




            >>> analyzedKey.alternateInterpretations[1].correlationCoefficient
            0.788528...
            >>> analyzedKey.alternateInterpretations[22].correlationCoefficient
            -0.86728...




        .. method:: attachIntervalsBetweenStreams(cmpStream)

            For each element in self, creates an interval.Interval object in the element's
            editorial that is the interval between it and the element in cmpStream that
            is sounding at the moment the element in srcStream is attacked.


            Remember that if you are comparing two streams with measures, etc.,
            you'll need to flatten each stream as follows:




            >>> stream1.flat.attachIntervalsBetweenStreams(stream2.flat)


            Example usage:




            >>> from music21 import *
            >>> s1 = converter.parse('C4 d8 e f# g A2 d2', '7/4')
            >>> s2 = converter.parse('g4 e8 d c4   a2 r2', '7/4')
            >>> s1.attachIntervalsBetweenStreams(s2)
            >>> for n in s1.notes:
            ...     if n.editorial.harmonicInterval is None: print "None" # if other voice had a rest...
            ...     else: print n.editorial.harmonicInterval.directedName
            P12
            M2
            M-2
            A-4
            P-5
            P8
            None



        .. method:: attachMelodicIntervals()

            For each element in self, creates an interval.Interval object in the element's
            editorial that is the interval between it and the previous element in the stream. Thus,
            the first element will have a value of None.


            >>> from music21 import *
            >>> s1 = converter.parse('C4 d8 e f# g A2 d2', '7/4')
            >>> s1.attachMelodicIntervals()
            >>> for n in s1.notes:
            ...     if n.editorial.melodicInterval is None: print None
            ...     else: print n.editorial.melodicInterval.directedName
            None
            M9
            M2
            M2
            m2
            m-7
            P4



        .. method:: attributeCount(classFilterList, attrName='quarterLength')

            Return a dictionary of attribute usage for one or more classes provided in a the `classFilterList` list and having the attribute specified by `attrName`.



            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.parts[0].flat.attributeCount(note.Note, 'quarterLength')
            {1.0: 12, 2.0: 11, 4.0: 2}



        .. method:: bestClef(allowTreble8vb=False)

            Returns the clef that is the best fit for notes and chords found in this Stream.

            This does not automatically get a flat representation of the Stream.



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in range(30):
            ...    n = note.Note()
            ...    n.midi = random.choice(range(60,72))
            ...    a.insert(n)
            >>> b = a.bestClef()
            >>> b.line
            2
            >>> b.sign
            'G'
            ⁠ 
            >>> c = stream.Stream()
            >>> for x in range(30):
            ...    n = note.Note()
            ...    n.midi = random.choice(range(35,55))
            ...    c.insert(n)
            >>> d = c.bestClef()
            >>> d.line
            4
            >>> d.sign
            'F'



        .. method:: chordify(addTies=True, displayTiedAccidentals=False, addPartIdAsGroup=False, removeRedundantPitches=True, toSoundingPitch=True)


            Create a chordal reduction of polyphonic music, where each
            change to a new pitch results in a new chord. If a Score or
            Part of Measures is provided, a Stream of Measures will be
            returned. If a flat Stream of notes, or a Score of such
            Streams is provided, no Measures will be returned.

            This functionlaity works by splitting all Durations in
            all parts, or if multi-part by all unique offsets. All
            simultaneous durations are then gathered into single chords.

            If `addPartIdAsGroup` is True, all elements found in the
            Stream will have their source Part id added to the
            element's Group.  These groups names are useful
            for partially "de-chordifying" the output.

            The `addTies` parameter currently does not work for pitches in Chords.

            If `toSoundingPitch` is True, all parts that define one or more transpositions will be transposed to sounding pitch before chordification. True by default.




            >>> from music21 import *
            >>> s = stream.Score()
            >>> p1 = stream.Part()
            >>> p1.insert(4, note.Note("C#"))
            >>> p1.insert(5.3, note.Rest())
            >>> p2 = stream.Part()
            >>> p2.insert(2.12, note.HalfNote("D-"))
            >>> p2.insert(5.5, note.Rest())
            >>> s.insert(0, p1)
            >>> s.insert(0, p2)
            >>> cc = s.chordify()
            >>> cc.show('text')
            {0.0} <music21.note.Rest rest>
            {2.12} <music21.chord.Chord D->
            {4.0} <music21.chord.Chord C# D->
            {4.12} <music21.chord.Chord C#>
            {5.0} <music21.note.Rest rest>




        .. method:: expandRepeats(copySpanners=True)

            Expand this Stream with repeats. Nested repeats given with :class:`~music21.bar.Repeat` objects, or repeats and sections designated with :class:`~music21.repeat.RepeatExpression` objects, are all expanded.

            This method always returns a new Stream, with deepcopies of all contained elements at all levels.



        .. method:: explode()


            Create a multi-part extraction from a single polyphonic Part.


            Currently just runs :meth:`~music21.stream.Stream.voicesToParts`
            but that will change as part explosion develops, and this
            method will use our best available quick method for part
            extraction.



        .. method:: extendDuration(objName, inPlace=True)

            Given a Stream and an object class name, go through the Stream
            and find each instance of the desired object. The time between
            adjacent objects is then assigned to the duration of each object.
            The last duration of the last object is assigned to extend to the
            end of the Stream.


            If `inPlace` is True, this is done in-place; if `inPlace` is
            False, this returns a modified deep copy.




            >>> from music21 import *
            ⁠ 
            >>> stream1 = stream.Stream()
            >>> n = note.QuarterNote()
            >>> n.duration.quarterLength
            1.0
            >>> stream1.repeatInsert(n, [0, 10, 20, 30, 40])



            >>> dyn = dynamics.Dynamic('ff')
            >>> stream1.insert(15, dyn)
            >>> sort1 = stream1.sorted
            >>> sort1[-1].offset # offset of last element
            40.0
            >>> sort1.duration.quarterLength # total duration
            41.0
            >>> len(sort1)
            6




            >>> stream2 = sort1.flat.extendDuration(note.GeneralNote)
            >>> len(stream2)
            6
            >>> stream2[0].duration.quarterLength
            10.0
            >>> stream2[1].duration.quarterLength # all note durs are 10
            10.0
            >>> stream2[-1].duration.quarterLength # or extend to end of stream
            1.0
            >>> stream2.duration.quarterLength
            41.0
            >>> stream2[-1].offset
            40.0




        .. method:: extendDurationAndGetBoundaries(objName, inPlace=True)

            Extend the Duration of elements specified by objName; then, collect a dictionary for every matched element of objName class, where the matched element is the value and the key is the start,end offset value.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(3, dynamics.Dynamic('mf'))
            >>> s.insert(7, dynamics.Dynamic('f'))
            >>> s.insert(12, dynamics.Dynamic('ff'))
            >>> s.extendDurationAndGetBoundaries('Dynamic')
            {(7.0, 12.0): <music21.dynamics.Dynamic f >, (3.0, 7.0): <music21.dynamics.Dynamic mf >, (12.0, 12.0): <music21.dynamics.Dynamic ff >}




        .. method:: extendTies(ignoreRests=False, pitchAttr='nameWithOctave')

            Connect any adjacent pitch space values that are the same with a Tie. Adjacent pitches can be Chords, Notes, or Voices.

            If `ignoreRests` is True, rests that occur between events will not be
            considered in matching pitches.

            The `pitchAttr` determines the pitch attribute that is used for comparison. Any valid pitch attribute name can be used.



        .. method:: extractContext(searchElement, before=4.0, after=4.0, maxBefore=None, maxAfter=None, forceOutputClass=None)


            Extracts elements around the given element within (before)
            quarter notes and (after) quarter notes (default 4), and
            returns a new Stream.



            >>> from music21 import *
            >>> qn = note.QuarterNote()
            >>> qtrStream = stream.Stream()
            >>> qtrStream.repeatInsert(qn, [0, 1, 2, 3, 4, 5])
            >>> hn = note.HalfNote()
            >>> hn.name = "B-"
            >>> qtrStream.append(hn)
            >>> qtrStream.repeatInsert(qn, [8, 9, 10, 11])
            >>> hnStream = qtrStream.extractContext(hn, 1.0, 1.0)
            >>> hnStream.show('text')
            {5.0} <music21.note.Note C>
            {6.0} <music21.note.Note B->
            {8.0} <music21.note.Note C>



        .. method:: findConsecutiveNotes(skipRests=False, skipChords=False, skipUnisons=False, skipOctaves=False, skipGaps=False, getOverlaps=False, noNone=False, **keywords)


            Returns a list of consecutive *pitched* Notes in a Stream.  A single "None" is placed in the list
            at any point there is a discontinuity (such as if there is a rest between two pitches), unless the `noNone` parameter is True.

            How to determine consecutive pitches is a little tricky and there are many options.

            The `skipUnison` parameter uses the midi-note value (.ps) to determine unisons, so enharmonic transitions (F# -> Gb) are
            also skipped if skipUnisons is true.  We believe that this is the most common usage.  However, because
            of this, you cannot completely be sure that the x.findConsecutiveNotes() - x.findConsecutiveNotes(skipUnisons = True)
            will give you the number of P1s in the piece, because there could be d2's in there as well.

            See Test.testFindConsecutiveNotes() for usage details.




        .. method:: findGaps(minimumQuarterLength=0.001)

            Returns either (1) a Stream containing Elements (that wrap the None object) whose offsets and durations are the length of gaps in the Stream
            or (2) None if there are no gaps.

            N.B. there may be gaps in the flattened representation of the stream
            but not in the unflattened.  Hence why "isSequence" calls self.flat.isGapless



        .. method:: flattenUnnecessaryVoices(force=False, inPlace=True)

            If this Stream defines one or more internal voices, do the following:

            * If there is more than one voice, and a voice has no elements,
              remove that voice.
            * If there is only one voice left that has elements, place those
              elements in the parent Stream.
            * If `force` is True, even if there is more than one Voice left,
              all voices will be flattened.



        .. method:: getClefs(searchActiveSite=False, searchContext=True, returnDefault=True)

            Collect all :class:`~music21.clef.Clef` objects in this Stream in a new Stream. Optionally search the activeSite Stream and/or contexts.

            If no Clef objects are defined, get a default using :meth:`~music21.stream.Stream.bestClef`



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> b = clef.AltoClef()
            >>> a.insert(0, b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getClefs()
            >>> len(c) == 1
            True



        .. method:: getElementAfterElement(element, classList=None)

            given an element, get the next element.  If classList is specified,
            check to make sure that the element is an instance of the class list



            >>> from music21 import *
            ⁠ 
            >>> st1 = stream.Stream()
            >>> n1 = note.Note()
            >>> n2 = note.Note()
            >>> r3 = note.Rest()
            >>> st1.append([n1, n2, r3])
            >>> t2 = st1.getElementAfterElement(n1)
            >>> t2 is n2
            True
            >>> t3 = st1.getElementAfterElement(t2)
            >>> t3 is r3
            True
            >>> t4 = st1.getElementAfterElement(t3)
            >>> t4



            >>> st1.getElementAfterElement("hi")
            Traceback (most recent call last):
            StreamException: ...
            >>> t5 = st1.getElementAfterElement(n1, [note.Rest])
            >>> t5 is r3
            True
            >>> t6 = st1.getElementAfterElement(n1, [note.Rest, note.Note])
            >>> t6 is n2
            True



        .. method:: getElementAfterOffset(offset, classList=None)

            Get element after a provided offset

            TODO: write this



        .. method:: getElementAtOrAfter(offset, classList=None)

            Given an offset, find the element at this offset, or with the offset
            greater than and nearest to.

            TODO: write this



        .. method:: getElementAtOrBefore(offset, classList=None)

            Given an offset, find the element at this offset, or with the offset
            less than and nearest to.

            Return one element or None if no elements are at or preceded by this
            offset.

            If the `classList` parameter is provided with a list of class names or strings, the only objects that will returned are objects that are instances of these classes or subclasses of these classes.



            >>> from music21 import *
            ⁠ 
            >>> stream1 = stream.Stream()
            >>> x = note.Note('D4')
            >>> x.id = 'x'
            >>> y = note.Note('E4')
            >>> y.id = 'y'
            >>> z = note.Rest()
            >>> z.id = 'z'



            >>> stream1.insert(20, x)
            >>> stream1.insert(10, y)
            >>> stream1.insert( 0, z)
            ⁠ 
            >>> b = stream1.getElementAtOrBefore(21)
            >>> b.offset, b.id
            (20.0, 'x')



            >>> b = stream1.getElementAtOrBefore(19)
            >>> b.offset, b.id
            (10.0, 'y')
            ⁠ 
            >>> b = stream1.getElementAtOrBefore(0)
            >>> b.offset, b.id
            (0.0, 'z')
            >>> b = stream1.getElementAtOrBefore(0.1)
            >>> b.offset, b.id
            (0.0, 'z')



            You can give a list of acceptable classes to return, and non-matching
            elements will be ignored




            >>> c = stream1.getElementAtOrBefore(100, [music21.clef.TrebleClef, music21.note.Rest])
            >>> c.offset, c.id
            (0.0, 'z')


            Getting an object via getElementAtOrBefore sets the activeSite
            for that object to the Stream, and thus sets its offset




            >>> stream2 = stream.Stream()
            >>> stream2.insert(100.5, x)
            >>> x.offset
            100.5
            >>> d = stream1.getElementAtOrBefore(20)
            >>> d is x
            True
            >>> x.activeSite is stream1
            True
            >>> x.offset
            20.0




        .. method:: getElementBeforeElement(element, classList=None)

            given an element, get the element before

            TODO: write this



        .. method:: getElementBeforeOffset(offset, classList=None)

            Get element before (and not at) a provided offset.

            If the `classList` parameter is provided with a list of class names or strings, the only objects that will returned are objects that are instances of these classes or subclasses of these classes.



            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> x = note.Note('D4')
            >>> x.id = 'x'
            >>> y = note.Note('E4')
            >>> y.id = 'y'
            >>> z = note.Rest()
            >>> z.id = 'z'
            >>> stream1.insert(20, x)
            >>> stream1.insert(10, y)
            >>> stream1.insert( 0, z)
            ⁠ 
            >>> b = stream1.getElementBeforeOffset(21)
            >>> b.offset, b.id
            (20.0, 'x')
            >>> b = stream1.getElementBeforeOffset(20)
            >>> b.offset, b.id
            (10.0, 'y')



            >>> b = stream1.getElementBeforeOffset(10)
            >>> b.offset, b.id
            (0.0, 'z')
            ⁠ 
            >>> b = stream1.getElementBeforeOffset(0)
            >>> b == None
            True
            >>> b = stream1.getElementBeforeOffset(0.1)
            >>> b.offset, b.id
            (0.0, 'z')



        .. method:: getElementById(id, classFilter=None)

            Returns the first encountered element for a given id. Return None
            if no match. Note: this uses the id attribute stored on elements, which may not be the same as id(e).



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> ew = note.Note()
            >>> a.insert(0, ew)
            >>> a[0].id = 'green'
            >>> None == a.getElementById(3)
            True
            >>> a.getElementById('green').id
            'green'
            >>> a.getElementById('Green').id  # case does not matter
            'green'


            Getting an element by getElementById changes its activeSite




            >>> b = stream.Stream()
            >>> b.append(ew)
            >>> ew.activeSite is b
            True
            >>> ew2 = a.getElementById('green')
            >>> ew2 is ew
            True
            >>> ew2.activeSite is a
            True
            >>> ew.activeSite is a
            True



        .. method:: getElementByObjectId(objId)

            Low-level tool to get an element based only on the object id.

            This is not the same as getElementById, which refers to the id attribute which may be manually set and not unique.



        .. method:: getElementsByClass(classFilterList, returnStreamSubClass=True)

            Return a list of all Elements that match one or more classes in the `classFilterList`. A single class can be provided to the `classFilterList` parameter.



            >>> from music21 import *
            >>> a = stream.Score()
            >>> a.repeatInsert(note.Rest(), range(10))
            >>> for x in range(4):
            ...     n = note.Note('G#')
            ...     n.offset = x * 3
            ...     a.insert(n)
            >>> found = a.getElementsByClass(note.Note)
            >>> len(found)
            4
            >>> found[0].pitch.accidental.name
            'sharp'
            >>> b = stream.Stream()
            >>> b.repeatInsert(note.Rest(), range(15))
            >>> a.insert(b)
            >>> # here, it gets elements from within a stream
            >>> # this probably should not do this, as it is one layer lower
            >>> found = a.getElementsByClass(note.Rest)
            >>> len(found)
            10
            >>> found = a.flat.getElementsByClass(note.Rest)
            >>> len(found)
            25
            >>> found.__class__.__name__
            'Score'



        .. method:: getElementsByGroup(groupFilterList)




            >>> from music21 import *
            ⁠ 
            >>> n1 = note.Note("C")
            >>> n1.groups.append('trombone')
            >>> n2 = note.Note("D")
            >>> n2.groups.append('trombone')
            >>> n2.groups.append('tuba')
            >>> n3 = note.Note("E")
            >>> n3.groups.append('tuba')
            >>> s1 = stream.Stream()
            >>> s1.append(n1)
            >>> s1.append(n2)
            >>> s1.append(n3)
            >>> tboneSubStream = s1.getElementsByGroup("trombone")
            >>> for thisNote in tboneSubStream:
            ...     print(thisNote.name)
            C
            D
            >>> tubaSubStream = s1.getElementsByGroup("tuba")
            >>> for thisNote in tubaSubStream:
            ...     print(thisNote.name)
            D
            E



        .. method:: getElementsByOffset(offsetStart, offsetEnd=None, includeEndBoundary=True, mustFinishInSpan=False, mustBeginInSpan=True, classList=None)


            Returns a Stream containing all Music21Objects that
            are found at a certain offset or within a certain
            offset time range (given the start and optional stop values).


            There are several attributes that govern how this range is
            determined:


            If `mustFinishInSpan` is True then an event that begins
            between offsetStart and offsetEnd but which ends after offsetEnd
            will not be included.  The default is False.


            For instance, a half note at offset 2.0 will be found in
            getElementsByOffset(1.5, 2.5) or getElementsByOffset(1.5, 2.5,
            mustFinishInSpan = False) but not by getElementsByOffset(1.5, 2.5,
            mustFinishInSpan = True).


            The `includeEndBoundary` option determines if an element
            begun just at the offsetEnd should be included.  For instance,
            the half note at offset 2.0 above would be found by
            getElementsByOffset(0, 2.0) or by getElementsByOffset(0, 2.0,
            includeEndBoundary = True) but not by getElementsByOffset(0, 2.0,
            includeEndBoundary = False).


            Setting includeEndBoundary to False at the same time as
            mustFinishInSpan is set to True is probably NOT what you want to do
            unless you want to find things like clefs at the end of the region
            to display as courtesy clefs.


            The `mustBeginInSpan` option determines whether notes or other
            objects that do not begin in the region but are still sounding
            at the beginning of the region are excluded.  The default is
            True -- that is, these notes will not be included.
            For instance the half note at offset 2.0 from above would not be found by
            getElementsByOffset(3.0, 3.5) or getElementsByOffset(3.0, 3.5,
            mustBeginInSpan = True) but it would be found by
            getElementsByOffset(3.0, 3.5, mustBeginInSpan = False)


            This chart, and the examples below, demonstrate the various
            features of getElementsByOffset.  It is one of the most complex
            methods of music21 but also one of the most powerful, so it
            is worth learning at least the basics.





                .. image:: images/getElementsByOffset.*
                        :width: 600





            >>> from music21 import *
            ⁠ 
            >>> st1 = stream.Stream()
            >>> n0 = note.Note("C")
            >>> n0.duration.type = "half"
            >>> n0.offset = 0
            >>> st1.insert(n0)
            >>> n2 = note.Note("D")
            >>> n2.duration.type = "half"
            >>> n2.offset = 2
            >>> st1.insert(n2)
            >>> out1 = st1.getElementsByOffset(2)
            >>> len(out1)
            1
            >>> out1[0].step
            'D'
            >>> out2 = st1.getElementsByOffset(1, 3)
            >>> len(out2)
            1
            >>> out2[0].step
            'D'
            >>> out3 = st1.getElementsByOffset(1, 3, mustFinishInSpan = True)
            >>> len(out3)
            0
            >>> out4 = st1.getElementsByOffset(1, 2)
            >>> len(out4)
            1
            >>> out4[0].step
            'D'
            >>> out5 = st1.getElementsByOffset(1, 2, includeEndBoundary = False)
            >>> len(out5)
            0
            >>> out6 = st1.getElementsByOffset(1, 2, includeEndBoundary = False, mustBeginInSpan = False)
            >>> len(out6)
            1
            >>> out6[0].step
            'C'
            >>> out7 = st1.getElementsByOffset(1, 3, mustBeginInSpan = False)
            >>> len(out7)
            2
            >>> [el.step for el in out7]
            ['C', 'D']





            >>> a = stream.Stream()
            >>> n = note.Note('G')
            >>> n.quarterLength = .5
            >>> a.repeatInsert(n, range(8))
            >>> b = stream.Stream()
            >>> b.repeatInsert(a, [0, 3, 6])
            >>> c = b.getElementsByOffset(2,6.9)
            >>> len(c)
            2
            >>> c = b.flat.getElementsByOffset(2,6.9)
            >>> len(c)
            10



        .. method:: getElementsNotOfClass(classFilterList)

            Return a list of all Elements that do not match the one or more classes in the `classFilterList`. A single class can be provided to the `classFilterList` parameter.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Rest(), range(10))
            >>> for x in range(4):
            ...     n = note.Note('G#')
            ...     n.offset = x * 3
            ...     a.insert(n)
            >>> found = a.getElementsNotOfClass(note.Note)
            >>> len(found)
            10



            >>> b = stream.Stream()
            >>> b.repeatInsert(note.Rest(), range(15))
            >>> a.insert(b)
            >>> # here, it gets elements from within a stream
            >>> # this probably should not do this, as it is one layer lower
            >>> found = a.flat.getElementsNotOfClass(note.Rest)
            >>> len(found)
            4
            >>> found = a.flat.getElementsNotOfClass(note.Note)
            >>> len(found)
            25



        .. method:: getInstrument(searchActiveSite=True, returnDefault=True)

            Return the first Instrument found in this Stream.



        .. method:: getInstruments(searchActiveSite=True, returnDefault=True)


            Search this stream or activeSite streams for
            :class:`~music21.instrument.Instrument` objects, otherwise
            return a default Instrument



            >>> from music21 import *
            >>> s = stream.Score()
            >>> p1 = stream.Part()
            >>> p1.insert(instrument.Violin())
            >>> m1p1 = stream.Measure()
            >>> m1p1.append(note.Note('g'))
            >>> p1.append(m1p1)
            ⁠ 
            >>> p2 = stream.Part()
            >>> p2.insert(instrument.Viola())
            >>> m1p2 = stream.Measure()
            >>> m1p2.append(note.Note('f#'))
            >>> p2.append(m1p2)



            >>> s.insert(0, p1)
            >>> s.insert(0, p2)
            >>> p1.getInstrument(returnDefault=False).instrumentName
            'Violin'
            >>> p2.getInstrument(returnDefault=False).instrumentName
            'Viola'



        .. method:: getKeySignatures(searchActiveSite=True, searchContext=True)

            Collect all :class:`~music21.key.KeySignature` objects in this Stream in a new Stream. Optionally search the activeSite stream and/or contexts.

            If no KeySignature objects are defined, returns an empty Stream



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> b = key.KeySignature(3)
            >>> a.insert(0, b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getKeySignatures()
            >>> len(c) == 1
            True



        .. method:: getOffsetByElement(obj)

            Given an object, return the offset of that object in the context of
            this Stream. This method can be called on a flat representation to return the ultimate position of a nested structure.

            If the object is not found in the Stream, None is returned.



            >>> from music21 import *
            ⁠ 
            >>> n1 = note.Note('A')
            >>> n2 = note.Note('B')



            >>> s1 = stream.Stream()
            >>> s1.insert(10, n1)
            >>> s1.insert(100, n2)
            ⁠ 
            >>> s2 = stream.Stream()
            >>> s2.insert(10, s1)



            >>> s2.flat.getOffsetBySite(n1) # this will not work
            Traceback (most recent call last):
            DefinedContextsException: ...
            ⁠ 
            >>> s2.flat.getOffsetByElement(n1)
            20.0
            >>> s2.flat.getOffsetByElement(n2)
            110.0



        .. method:: getOverlaps(includeDurationless=True, includeEndBoundary=False)


            Find any elements that overlap. Overlaping might include elements
            that have no duration but that are simultaneous.
            Whether elements with None durations are included is determined by
            includeDurationless.

            This method returns a dictionary, where keys
            are the start time of the first overlap and
            value are a list of all objects included in
            that overlap group.

            This example demonstrates end-joing overlaps: there are four
            quarter notes each following each other. Whether or not
            these count as overlaps
            is determined by the includeEndBoundary parameter.



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#')
            ...     n.duration = duration.Duration('quarter')
            ...     n.offset = x * 1
            ...     a.insert(n)
            ...
            >>> d = a.getOverlaps(True, False)
            >>> len(d)
            0
            >>> d = a.getOverlaps(True, True) # including coincident boundaries
            >>> len(d)
            1
            >>> len(d[0])
            4
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,13,13,13]:
            ...     n = note.Note('G#')
            ...     n.duration = duration.Duration('half')
            ...     n.offset = x
            ...     a.insert(n)
            ...
            >>> d = a.getOverlaps()
            >>> len(d[0])
            4
            >>> len(d[13])
            3
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,3,3,3]:
            ...     n = note.Note('G#')
            ...     n.duration = duration.Duration('whole')
            ...     n.offset = x
            ...     a.insert(n)
            ...
            >>> # default is to not include coincident boundaries
            >>> d = a.getOverlaps()
            >>> len(d[0])
            7




        .. method:: getSimultaneous(includeDurationless=True)

            Find and return any elements that start at the same time.



            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#')
            ...     n.offset = x * 0
            ...     stream1.insert(n)
            ...
            >>> b = stream1.getSimultaneous()
            >>> len(b[0]) == 4
            True
            >>> stream2 = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#')
            ...     n.offset = x * 3
            ...     stream2.insert(n)
            ...
            >>> d = stream2.getSimultaneous()
            >>> len(d) == 0
            True



        .. method:: getTimeSignatures(searchContext=True, returnDefault=True, sortByCreationTime=True)


            Collect all :class:`~music21.meter.TimeSignature` objects in this stream.
            If no TimeSignature objects are defined, get a default (4/4 or whatever
            is defined in the defaults.py file).




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> b = meter.TimeSignature('3/4')
            >>> a.insert(b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getTimeSignatures()
            >>> len(c) == 1
            True



        .. method:: groupCount()

            Get a dictionary for each groupId and the count of instances.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> a.repeatAppend(n, 30)
            >>> a.addGroupForElements('P1')
            >>> a.groupCount()
            {'P1': 30}
            >>> a[12].groups.append('green')
            >>> a.groupCount()
            {'P1': 30, 'green': 1}



        .. method:: groupElementsByOffset(returnDict=False)


            Returns a List of lists in which each entry in the
            main list is a list of elements occurring at the same time.
            list is ordered by offset (since we need to sort the list
            anyhow in order to group the elements), so there is
            no need to call stream.sorted before running this.

            it is DEFINITELY a feature that this method does not
            find elements within substreams that have the same
            absolute offset.  See Score.lily for how this is
            useful.  For the other behavior, call Stream.flat first.




        .. method:: hasElement(obj)

            Return True if an element, provided as an argument, is contained in this Stream.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> s.append(n1)
            >>> s.hasElement(n1)
            True



        .. method:: hasElementByObjectId(objId)

            Return True if an element object id, provided as an argument, is contained in this Stream.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> s.append(n1)
            >>> s.hasElementByObjectId(id(n1))
            True
            >>> s.hasElementByObjectId(id(n2))
            False



        .. method:: hasElementOfClass(className, forceFlat=False)

            Given a single class name as string, return True or False if an element with the specified class is found. The Stream must be flat, and only a single class name can be given.



        .. method:: hasMeasures()

            Return a boolean value showing if this Stream contains Measures



        .. method:: hasPartLikeStreams()

            Return a boolean value showing if this Stream contains multiple Parts, or Part-like sub-Streams.



        .. method:: hasVoices()

            Return a boolean value showing if this Stream contains Voices



        .. method:: haveAccidentalsBeenMade()

            If Accidentals.displayStatus is None for all contained pitches, it as assumed that accidentals have not been set for display and/or makeAccidentals has not been run. If any Accidental has displayStatus other than None, this method returns True, regardless of if makeAccidentals has actually been run.



        .. method:: haveBeamsBeenMade()

            If any Note in this Stream has .beams defined, it as assumed that Beams have not been set and/or makeBeams has not been run. If any Beams exist, this method returns True, regardless of if makeBeams has actually been run.



        .. method:: index(obj)

            Return the first matched index for the specified object.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            ⁠ 
            >>> s.insert(0, n1)
            >>> s.insert(5, n2)
            >>> len(s)
            2
            >>> s.index(n1)
            0
            >>> s.index(n2)
            1


        .. method:: insertAtNativeOffset(item)

            Inserts an item at the offset that was defined before the item was inserted into a Stream.

            That is item.getOffsetBySite(None); in fact, the entire code is self.insert(item.getOffsetBySite(None), item)



            >>> from music21 import *
            ⁠ 
            >>> n1 = note.Note("F-")
            >>> n1.offset = 20.0
            >>> stream1 = stream.Stream()
            >>> stream1.append(n1)
            >>> n1.getOffsetBySite(stream1)
            0.0
            >>> n1.offset
            0.0
            >>> stream2 = stream.Stream()
            >>> stream2.insertAtNativeOffset(n1)
            >>> stream2[0].offset
            20.0
            >>> n1.getOffsetBySite(stream2)
            20.0



        .. method:: insertIntoNoteOrChord(offset, noteOrChord)

            Insert a Note or Chord into an offset position in this Stream. If there is another Note or Chord in this position, create a new Chord that combines the pitches of the inserted chord. If there is a Rest in this position, the Rest is replaced by the Note or Chord. The duration of the previously-found chord will remain the same in the new Chord.



        .. method:: internalize(container=None, classFilterList=['GeneralNote'])


            Gather all notes and related classes of this Stream
            and place inside a new container (like a Voice) in this Stream.



        .. method:: invertDiatonic(inversionNote=<music21.note.Note C>, inPlace=True)


            inverts a stream diatonically around the given note (by default, middle C)

            For pieces where the key signature
            does not change throughout the piece it is MUCH faster than
            for pieces where the key signature changes.

            Here in this test, we put Ciconia's Quod Jactatur (a single voice
            piece that should have a canon solution: see trecento.quodJactatur)
            into 3 flats (instead of its original 1 flat) in measure 1, but
            into 5 sharps in measure 2 and then invert around F4, creating
            a new piece.



            >>> from music21 import *
            >>> qj = corpus.parse('ciconia/quod_jactatur').parts[0]
            >>> qj.measures(1,2).show('text')
            {0.0} <music21.instrument.Instrument P1: MusicXML Part: Grand Piano>
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.clef.Treble8vbClef>
                {0.0} <music21.key.KeySignature of 1 flat>
                {0.0} <music21.meter.TimeSignature 2/4>
                {0.0} <music21.layout.SystemLayout>
                {0.0} <music21.note.Note C>
                {1.5} <music21.note.Note D>
            {2.0} <music21.stream.Measure 2 offset=2.0>
                {0.0} <music21.note.Note E>
                {0.5} <music21.note.Note D>
                {1.0} <music21.note.Note C>
                {1.5} <music21.note.Note D>
            >>> k1 = qj.flat.getElementsByClass(key.KeySignature)[0]
            >>> qj.flat.replace(k1, key.KeySignature(-3))
            >>> qj.getElementsByClass(stream.Measure)[1].insert(0, key.KeySignature(5))
            >>> qj2 = qj.invertDiatonic(note.Note('F4'), inPlace = False)
            >>> qj2.measures(1,2).show('text')
            {0.0} <music21.instrument.Instrument P1: MusicXML Part: Grand Piano>
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.clef.Treble8vbClef>
                {0.0} <music21.key.KeySignature of 3 flats>
                {0.0} <music21.meter.TimeSignature 2/4>
                {0.0} <music21.layout.SystemLayout>
                {0.0} <music21.note.Note B->
                {1.5} <music21.note.Note A->
            {2.0} <music21.stream.Measure 2 offset=2.0>
                {0.0} <music21.key.KeySignature of 5 sharps>
                {0.0} <music21.note.Note G#>
                {0.5} <music21.note.Note A#>
                {1.0} <music21.note.Note B>
                {1.5} <music21.note.Note A#>



        .. method:: isSequence(includeDurationless=True, includeEndBoundary=False)

            A stream is a sequence if it has no overlaps.



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,3,3,3]:
            ...     n = note.Note('G#')
            ...     n.duration = duration.Duration('whole')
            ...     n.offset = x * 1
            ...     a.insert(n)
            ...
            >>> a.isSequence()
            False



        .. method:: isTwelveTone()

            Return true if this Stream only employs twelve-tone equal-tempered pitch values.



        .. method:: makeAccidentals(pitchPast=None, pitchPastMeasure=None, useKeySignature=True, alteredPitches=None, searchKeySignatureByContext=False, cautionaryPitchClass=True, cautionaryAll=False, inPlace=True, overrideStatus=False, cautionaryNotImmediateRepeat=True, lastNoteWasTied=False)


            A method to set and provide accidentals given various conditions and contexts.

            `pitchPast` is a list of pitches preceeding this pitch in this measure.

            `pitchPastMeasure` is a list of pitches preceeding this pitch but in a previous measure.


            If `useKeySignature` is True, a :class:`~music21.key.KeySignature` will be searched
            for in this Stream or this Stream's defined contexts. An alternative KeySignature
            can be supplied with this object and used for temporary pitch processing.

            If `alteredPitches` is a list of modified pitches (Pitches with Accidentals) that
            can be directly supplied to Accidental processing. These are the same values obtained
            from a :class:`music21.key.KeySignature` object using the
            :attr:`~music21.key.KeySignature.alteredPitches` property.

            If `cautionaryPitchClass` is True, comparisons to past accidentals are made regardless
            of register. That is, if a past sharp is found two octaves above a present natural,
            a natural sign is still displayed.

            If `cautionaryAll` is True, all accidentals are shown.

            If `overrideStatus` is True, this method will ignore any current `displayStatus` stetting
            found on the Accidental. By default this does not happen. If `displayStatus` is set to
            None, the Accidental's `displayStatus` is set.

            If `cautionaryNotImmediateRepeat` is True, cautionary accidentals will be displayed for
            an altered pitch even if that pitch had already been displayed as altered.

            If `lastNoteWasTied` is True, assume that the first note of the stream was tied
            to the previous note.  TODO: make more robust for tied chords with only some pitches tied...

            The :meth:`~music21.pitch.Pitch.updateAccidentalDisplay` method is used to determine if
            an accidental is necessary.

            This will assume that the complete Stream is the context of evaluation. For smaller context
            ranges, call this on Measure objects.

            If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy.




        .. method:: makeBeams(inPlace=True)

            Return a new Measure, or Stream of Measures, with beams applied to all notes. Measures with Voices will process voices independently.

            In the process of making Beams, this method also updates tuplet types. This is destructive and thus changes an attribute of Durations in Notes.

            If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy.



            >>> from music21 import *
            ⁠ 
            >>> aMeasure = stream.Measure()
            >>> aMeasure.timeSignature = meter.TimeSignature('4/4')
            >>> aNote = note.Note()
            >>> aNote.quarterLength = .25
            >>> aMeasure.repeatAppend(aNote,16)
            >>> bMeasure = aMeasure.makeBeams()



        .. method:: makeChords(minimumWindowSize=0.125, includePostWindow=True, removeRedundantPitches=True, useExactOffsets=False, gatherArticulations=True, gatherExpressions=True, inPlace=False, transferGroupsToPitches=False, makeRests=True)


            Gathers simultaneously sounding :class:`~music21.note.Note` objects
            into :class:`~music21.chord.Chord` objects, each of which
            contains all the pitches sounding together.


            If useExactOffsets is True (default = False), then do an exact
            makeChords using the offsets in the piece.
            If this parameter is set, then minimumWindowSize is ignored.


            This first example puts a part with three quarter notes (C4, D4, E4)
            together with a part consisting of a half note (C#5) and a
            quarter note (E#5) to make two Chords, the first containing the
            three :class:`~music21.pitch.Pitch` objects sounding at the
            beginning, the second consisting of the two Pitches sounding
            on offset 2.0 (beat 3):




            >>> from music21 import *
            >>> p1 = stream.Part()
            >>> p1.append([note.QuarterNote("C4"), note.QuarterNote("D4"), note.QuarterNote("E4"), note.QuarterNote("B2")])
            >>> p2 = stream.Part()
            >>> p2.append([note.HalfNote("C#5"), note.QuarterNote("E#5"), chord.Chord(["E4","G5","C#7"])])
            >>> sc1 = stream.Score()
            >>> sc1.insert(0, p1)
            >>> sc1.insert(0, p2)
            >>> scChords = sc1.flat.makeChords()
            >>> scChords.show('text')
            {0.0} <music21.chord.Chord C4 C#5 D4>
            {2.0} <music21.chord.Chord E4 E#5>
            {3.0} <music21.chord.Chord B2 E4 G5 C#7>


            The gathering of elements, starting from offset 0.0, uses
            the `minimumWindowSize`, in quarter lengths, to collect
            all Notes that start between 0.0 and the minimum window
            size (this permits overlaps within a minimum tolerance).


            After collection, the maximum duration of collected elements
            is found; this duration is then used to set the new
            starting offset. A possible gap then results between the end
            of the window and offset specified by the maximum duration;
            these additional notes are gathered in a second pass if
            `includePostWindow` is True.


            The new start offset is shifted to the larger of either
            the minimum window or the maximum duration found in the
            collected group. The process is repeated until all offsets
            are covered.


            Each collection of Notes is formed into a Chord. The Chord
            is given the longest duration of all constituents, and is
            inserted at the start offset of the window from which it
            was gathered.


            Chords can gather both articulations and expressions from found Notes
            using `gatherArticulations` and `gatherExpressions`.

            If `transferGroupsToPitches` is True, and group defined on the source elements Groups object will be transfered to the Pitch objects conatained in the resulting Chord.

            The resulting Stream, if not in-place, can also gather
            additional objects by placing class names in the `collect` list.
            By default, TimeSignature and KeySignature objects are collected.





        .. method:: makeImmutable()

            Clean this Stream: for self and all elements, purge all dead locations and remove all non-contained sites. Further, restore all active sites



        .. method:: makeMeasures(meterStream=None, refStreamOrTimeRange=None, searchContext=False, innerBarline=None, finalBarline='final', bestClef=False, inPlace=False)


            Takes a stream and places all of its elements into
            measures (:class:`~music21.stream.Measure` objects)
            based on the :class:`~music21.meter.TimeSignature` objects
            placed within
            the stream. If no TimeSignatures are found in the
            stream, a default of 4/4 is used.


            If `inPlace` is True, the original Stream is modified and lost
            if `inPlace` is False, this returns a modified deep copy.


            Many advanced features are provided:


            (1) If a `meterStream` is provided, the TimeSignatures in this
            stream are used instead of any
            found in the Stream. Alternatively, a single TimeSignature object
            can be provided in lieu of the stream. This feature lets you
            test out how a group of notes might be interpreted as measures
            in a number of different metrical schemes.


            (2) If `refStreamOrTimeRange` is provided, this Stream or List
            is used to give the span that you want to make measures for
            necessary to fill empty rests at the ends or beginnings of
            Streams, etc.  Say for instance you'd like to make a complete
            score from a short ossia section, then you might use another
            Part from the Score as a `refStreamOrTimeRange` to make sure
            that the appropriate measures of rests are added at either side.


            (3) If `innerBarline` is not None, the specified Barline object or string-specification of Barline style will be used to create Barline objects between every created Measure. The default is None.

            (4) If `finalBarline` is not None, the specified Barline object or string-specification of Barline style will be used to create a Barline objects at the end of the last Measure. The default is 'final'.

            The `searchContext` parameter determines whether or not context searches are used to find Clef and other notation objects.

            Here is a simple example of makeMeasures:
            a single measure of 4/4 is created by from a stream
            containing only three quarter notes:




            >>> from music21 import *
            >>> sSrc = stream.Stream()
            >>> sSrc.append(note.QuarterNote('C4'))
            >>> sSrc.append(note.QuarterNote('D4'))
            >>> sSrc.append(note.QuarterNote('E4'))
            >>> sMeasures = sSrc.makeMeasures()
            >>> sMeasures.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.clef.TrebleClef>
                {0.0} <music21.meter.TimeSignature 4/4>
                {0.0} <music21.note.Note C>
                {1.0} <music21.note.Note D>
                {2.0} <music21.note.Note E>
                {3.0} <music21.bar.Barline style=final>


            Notice that the last measure is incomplete -- makeMeasures
            does not fill up incomplete measures.


            We can also check that the measure created has
            the correct TimeSignature:




            >>> sMeasures[0].timeSignature
            <music21.meter.TimeSignature 4/4>


            Now let's redo this work in 2/4 by putting a TimeSignature
            of 2/4 at the beginning of the stream and rerunning
            makeMeasures. Now we will have two measures, each with
            correct measure numbers:




            >>> sSrc.insert(0.0, meter.TimeSignature('2/4'))
            >>> sMeasuresTwoFour = sSrc.makeMeasures()
            >>> sMeasuresTwoFour.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.meter.TimeSignature 2/4>
                {0.0} <music21.clef.TrebleClef>
                {0.0} <music21.note.Note C>
                {1.0} <music21.note.Note D>
            {2.0} <music21.stream.Measure 2 offset=2.0>
                {0.0} <music21.note.Note E>
                {1.0} <music21.bar.Barline style=final>


            Let us put 10 quarter notes in a Part.
            After we run makeMeasures, we will have
            3 measures of 4/4 in a new Part object. This experiment
            demonstrates that running makeMeasures does not
            change the type of Stream you are using:




            >>> sSrc = stream.Part()
            >>> n = note.Note('E-4')
            >>> n.quarterLength = 1
            >>> sSrc.repeatAppend(n, 10)
            >>> sMeasures = sSrc.makeMeasures()
            >>> len(sMeasures.getElementsByClass('Measure'))
            3
            >>> sMeasures.__class__.__name__
            'Part'


            Demonstrate what makeMeasures will do with inPlace == True:




            >>> sScr = stream.Stream()
            >>> sScr.insert(0, clef.TrebleClef())
            >>> sScr.insert(0, meter.TimeSignature('3/4'))
            >>> sScr.append(note.Note('C4', quarterLength = 3.0))
            >>> sScr.append(note.Note('D4', quarterLength = 3.0))
            >>> sScr.makeMeasures(inPlace = True)
            >>> sScr.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.meter.TimeSignature 3/4>
                {0.0} <music21.clef.TrebleClef>
                {0.0} <music21.note.Note C>
            {3.0} <music21.stream.Measure 2 offset=3.0>
                {0.0} <music21.note.Note D>
                {3.0} <music21.bar.Barline style=final>


            If after running makeMeasures you run makeTies, it will also split
            long notes into smaller notes with ties.  Lyrics and articulations
            are attached to the first note.  Expressions (fermatas,
            etc.) will soon be attached to the last note but this is not yet done:




            >>> p1 = stream.Part()
            >>> p1.append(meter.TimeSignature('3/4'))
            >>> longNote = note.Note("D#4")
            >>> longNote.quarterLength = 7.5
            >>> longNote.articulations = [articulations.Staccato()]
            >>> longNote.lyric = "hi"
            >>> p1.append(longNote)
            >>> partWithMeasures = p1.makeMeasures()
            >>> dummy = partWithMeasures.makeTies(inPlace = True)
            >>> partWithMeasures.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0>
                {0.0} <music21.meter.TimeSignature 3/4>
                {0.0} <music21.clef.TrebleClef>
                {0.0} <music21.note.Note D#>
            {3.0} <music21.stream.Measure 2 offset=3.0>
                {0.0} <music21.note.Note D#>
            {6.0} <music21.stream.Measure 3 offset=6.0>
                {0.0} <music21.note.Note D#>
                {1.5} <music21.bar.Barline style=final>
            ⁠ 
            >>> allNotes = partWithMeasures.flat.notes
            >>> [allNotes[0].articulations, allNotes[1].articulations, allNotes[2].articulations]
            [[<music21.articulations.Staccato>], [], []]
            >>> [allNotes[0].lyric, allNotes[1].lyric, allNotes[2].lyric]
            ['hi', None, None]



        .. method:: makeMutable(recurse=True)

            No documentation.


        .. method:: makeNotation(meterStream=None, refStreamOrTimeRange=None, inPlace=False, bestClef=False, **subroutineKeywords)


            This method calls a sequence of Stream methods on this Stream to prepare notation, including creating voices for overlapped regions, Measures if necessary, creating ties, beams, and accidentals.


            If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy.


            makeAccidentalsKeywords can be a dict specifying additional parameters to send to makeAccidentals




            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note('g')
            >>> n.quarterLength = 1.5
            >>> s.repeatAppend(n, 10)
            >>> sMeasures = s.makeNotation()
            >>> len(sMeasures.getElementsByClass('Measure'))
            4
            >>> sMeasures.getElementsByClass('Measure')[-1].rightBarline.style
            'final'



        .. method:: makeRests(refStreamOrTimeRange=None, fillGaps=False, timeRangeFromBarDuration=False, inPlace=True)


            Given a Stream with an offset not equal to zero,
            fill with one Rest preeceding this offset. This can be called on any Stream, a Measure alone, or a Measure that contains Voices.

            If `refStreamOrTimeRange` is provided as a Stream, this
            Stream is used to get min and max offsets. If a list is provided,
            the list assumed to provide minimum and maximum offsets. Rests will
            be added to fill all time defined within refStream.

            If `fillGaps` is True, this will create rests in any time regions that have no active elements.

            If `timeRangeFromBarDuration` is True, and the calling Stream is a Measure with a TimeSignature, the time range will be determined based on the .barDuration property.

            If `inPlace` is True, this is done in-place; if `inPlace` is False,
            this returns a modified deepcopy.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> a.insert(20, note.Note())
            >>> len(a)
            1
            >>> a.lowestOffset
            20.0
            >>> b = a.makeRests()
            >>> len(b)
            2
            >>> b.lowestOffset
            0.0



        .. method:: makeTies(meterStream=None, inPlace=True, displayTiedAccidentals=False)


            Given a stream containing measures, examine each element in the
            Stream. If the elements duration extends beyond the measure's boundary,
            create a tied entity, placing the split Note in the next Measure.


            Note that this method assumes that there is appropriate space
            in the next Measure: this will not shift Note objects, but instead allocate
            them evenly over barlines. Generally, makeMeasures is called prior
            to calling this method.


            If `inPlace` is True, this is done in-place;
            if `inPlace` is False, this returns a modified deep copy.




            >>> from music21 import *
            ⁠ 
            >>> d = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 12
            >>> d.repeatAppend(n, 10)
            >>> d.repeatInsert(n, [x+.5 for x in range(10)])
            >>> x = d.makeMeasures()
            >>> x = x.makeTies()




        .. method:: makeTupletBrackets(inPlace=True)

            Given a Stream of mixed durations, the first and last tuplet of any group of tuplets must be designated as the start and end.

            Need to not only look at Notes, but components within Notes, as these might contain additional tuplets.



        .. method:: makeVoices(inPlace=True, fillGaps=True)

            If this Stream has overlapping Notes or Chords, this method will isolate all overlaps in unique Voices, and place those Voices in the Stream.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(0, note.Note('C4', quarterLength=4))
            >>> s.repeatInsert(note.Note('b-4', quarterLength=.5), [x*.5 for x in range(0,8)])
            >>> s.makeVoices(inPlace=True)
            >>> len(s.voices)
            2
            >>> [n.pitch for n in s.voices[0].notes]
            [C4]
            >>> [n.pitch for n in s.voices[1].notes]
            [B-4, B-4, B-4, B-4, B-4, B-4, B-4, B-4]



        .. method:: measure(measureNumber, collect=['Clef', 'TimeSignature', 'Instrument', 'KeySignature'], searchContext=False)

            Given a measure number, return a single :class:`~music21.stream.Measure` object if the Measure number exists, otherwise return None.

            This method is distinguished from :meth:`~music21.stream.Stream.measures` in that this method returns a single Measure object, not a Stream containing one or more Measure objects.



            >>> from music21 import *
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.parts[0].measure(3)
            <music21.stream.Measure 3 offset=0.0>



        .. method:: measureOffsetMap(classFilterList=None)


            If this Stream contains Measures, provide a dictionary
            whose keys are the offsets of the start of each measure
            and whose values are a list of references
            to the :class:`~music21.stream.Measure` objects that start
            at that offset.


            Even in normal music there may be more than
            one Measure starting at each offset because each
            :class:`~music21.stream.Part` might define its own Measure.
            However, you are unlikely to encounter such things unless you
            run Score.semiFlat, which retains all the containers found in
            the score.


            The offsets are always measured relative to the
            calling Stream (self).


            You can specify a `classFilterList` argument as a list of classes
            to find instead of Measures.  But the default will of course
            find Measure objects.


            Example 1: This Bach chorale is in 4/4 without a pickup, so
            as expected, measures are found every 4 offsets, until the
            weird recitation in m. 7 which in our edition lasts 10 beats
            and thus causes a gap in measureOffsetMap from 24.0 to 34.0.





            .. image:: images/streamMeasureOffsetMapBWV324.*
                    :width: 572






            >>> from music21 import *
            >>> chorale = corpus.parse('bach/bwv324.xml')
            >>> alto = chorale.parts['alto']
            >>> altoMeasures = alto.measureOffsetMap()
            >>> sorted(altoMeasures.keys())
            [0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 34.0, 38.0]


            altoMeasures is a dictionary (hash) of the measures
            that are found in the alto part, so we can get
            the measure beginning on offset 4.0 (measure 2)
            and display it (though it's the only measure
            found at offset 4.0, there might be others as
            in example 2, so we need to call altoMeasures[4.0][0]
            to get this measure.):




            >>> altoMeasures[4.0]
            [<music21.stream.Measure 2 offset=4.0>]
            >>> altoMeasures[4.0][0].show('text')
            {0.0} <music21.note.Note D>
            {1.0} <music21.note.Note D#>
            {2.0} <music21.note.Note E>
            {3.0} <music21.note.Note F#>


            Example 2: How to get all the measures from all parts (not the
            most efficient way, but it works!).  Note that
            you first need to call semiFlat, which finds all containers
            (and other elements) nested inside all parts:




            >>> choraleSemiFlat = chorale.semiFlat
            >>> choraleMeasures = choraleSemiFlat.measureOffsetMap()
            >>> choraleMeasures[4.0]
            [<music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>]







        .. method:: measureTemplate(fillWithRests=True)

            If this Stream contains measures, return a new Stream with new Measures populated with the same characteristics of those found in this Stream.



        .. method:: measures(numberStart, numberEnd, collect=['Clef', 'TimeSignature', 'Instrument', 'KeySignature'], gatherSpanners=True, searchContext=False)

            Get a region of Measures based on a start and end Measure number, were the boundary numbers are both included. That is, a request for measures 4 through 10 will return 7 Measures, numbers 4 through 10.

            Additionally, any number of associated classes can be gathered as well. Associated classes are the last found class relevant to this Stream or Part.

            While all elements in the source are made available in the extracted region, new Measure objects are created and returned.



            >>> from music21 import *
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> b = a.parts[0].measures(4,6)
            >>> len(b.getElementsByClass('Measure'))
            3




        .. method:: melodicIntervals(*skipArgs, **skipKeywords)

            Returns a Stream of :class:`~music21.interval.Interval` objects
            between Notes (and by default, Chords) that follow each other in a stream.
            the offset of the Interval is the offset of the beginning of the interval
            (if two notes are adjacent, then this offset is equal to the offset of
            the second note, but if skipRests is set to True or there is a gap
            in the Stream, then these two numbers
            will be different).


            See :meth:`~music21.stream.Stream.findConsecutiveNotes` in this class for
            a discussion of what is meant by default for "consecutive notes", and
            which keywords such as skipChords, skipRests, skipUnisons, etc. can be
            used to change that behavior.


            The interval between a Note and a Chord (or between two chords) is the
            interval to the first pitch of the Chord (pitches[0]) which is usually the lowest.
            For more complex interval calculations,
            run :meth:`~music21.stream.Stream.findConsecutiveNotes` and then calculate
            your own intervals directly.


            Returns an empty Stream if there are not at least two elements found by
            findConsecutiveNotes.




            >>> from music21 import *
            >>> s1 = tinyNotation.TinyNotationStream("c4 d' r b b'", "3/4")
            >>> s1.show()






            .. image:: images/streamMelodicIntervals1.*
                    :width: 246






            >>> intervalStream1 = s1.melodicIntervals()
            >>> intervalStream1.show('text')
            {1.0} <music21.interval.Interval M9>
            {4.0} <music21.interval.Interval P8>


            Using the skip attributes from :meth:`~music21.stream.Stream.findConsecutiveNotes`,
            we can alter which intervals are reported:




            >>> intervalStream2 = s1.melodicIntervals(skipRests = True, skipOctaves=True)
            >>> intervalStream2.show('text')
            {1.0} <music21.interval.Interval M9>
            {2.0} <music21.interval.Interval m-3>
            ⁠ 
            >>> m3 = intervalStream2[1]
            >>> m3.directedNiceName
            'Descending Minor Third'



        .. method:: mergeElements(other, classFilterList=None)

            Given another Stream, store references of each element in the other Stream in this Stream. This does not make copies of any elements, but simply stores all of them in this Stream.

            Optionally, provide a list of classes to exclude with the `classFilter` list.

            This method provides functionality like a shallow copy, but manages locations properly, only copies elements, and permits filtering by class type.



            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s2 = stream.Stream()
            >>> n1 = note.Note('f#')
            >>> n2 = note.Note('g')
            >>> s1.append(n1)
            >>> s1.append(n2)
            >>> s2.mergeElements(s1)
            >>> len(s2)
            2
            >>> s1[0] is s2[0]
            True
            >>> s1[1] is s2[1]
            True



        .. method:: metronomeMarkBoundaries(srcObj=None)

            Return a list of offset start, offset end, MetronomeMark triples for all TempoIndication objects found in this Stream or a Stream provided by srcObj.

            If no MetronomeMarks are found, or an initial region does not have a MetronomeMark, a mark of quarter equal to 120 is provided as default.

            Note that if other TempoIndication objets are defined, they will be converted to MetronomeMarks and returned here



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.repeatAppend(note.Note(), 8)
            >>> s.insert([6, tempo.MetronomeMark(number=240)])
            >>> s.metronomeMarkBoundaries()
            [(0.0, 6.0, <music21.tempo.MetronomeMark animato Quarter=120>), (6.0, 8.0, <music21.tempo.MetronomeMark Quarter=240>)]



        .. method:: pitchAttributeCount(pitchAttr='name')

            Return a dictionary of pitch class usage (count) by selecting an attribute of the Pitch object.



            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.pitchAttributeCount('pitchClass')
            {0: 3, 2: 25, 3: 3, 4: 14, 6: 15, 7: 13, 9: 17, 11: 14}
            >>> a.pitchAttributeCount('name')
            {u'A': 17, u'C': 3, u'B': 14, u'E': 14, u'D': 25, u'G': 13, u'D#': 3, u'F#': 15}
            >>> a.pitchAttributeCount('nameWithOctave')
            {u'E3': 4, u'G4': 2, u'F#4': 2, u'A2': 2, u'E2': 1, u'G2': 1, u'D3': 9, u'D#3': 1, u'B4': 7, u'A3': 5, u'F#3': 13, u'A4': 10, u'B2': 3, u'B3': 4, u'C3': 2, u'E4': 9, u'D4': 14, u'D5': 2, u'D#4': 2, u'C5': 1, u'G3': 10}



        .. method:: playingWhenAttacked(el, elStream=None)


            Given an element (from another Stream) returns the single element
            in this Stream that is sounding while the given element starts.


            If there are multiple elements sounding at the moment it is
            attacked, the method returns the first element of the same class
            as this element, if any. If no element
            is of the same class, then the first element encountered is
            returned. For more complex usages, use allPlayingWhileSounding.


            Returns None if no elements fit the bill.


            The optional elStream is the stream in which el is found.
            If provided, el's offset
            in that Stream is used.  Otherwise, the current offset in
            el is used.  It is just
            in case you are paranoid that el.offset might not be what
            you want, because of some fancy manipulation of
            el.activeSite




            >>> from music21 import *
            ⁠ 
            >>> n1 = note.Note("G#")
            >>> n2 = note.Note("D#")
            >>> s1 = stream.Stream()
            >>> s1.insert(20.0, n1)
            >>> s1.insert(21.0, n2)
            >>> n3 = note.Note("C#")
            >>> s2 = stream.Stream()
            >>> s2.insert(20.0, n3)
            >>> s1.playingWhenAttacked(n3).name
            'G#'
            >>> n3.setOffsetBySite(s2, 20.5)
            >>> s1.playingWhenAttacked(n3).name
            'G#'
            >>> n3.setOffsetBySite(s2, 21.0)
            >>> n3.offset
            21.0
            >>> s1.playingWhenAttacked(n3).name
            'D#'



            Optionally, specify the site to get the offset from:





            >>> n3.setOffsetBySite(None, 100)
            >>> n3.activeSite = None
            >>> s1.playingWhenAttacked(n3)
            <BLANKLINE>
            >>> s1.playingWhenAttacked(n3, s2).name
            'D#'





        .. method:: plot(*args, **keywords)

            Given a method and keyword configuration arguments, create and display a plot.

            Note: plot() requires the Python package matplotib to be installed.

            For details on arguments this function takes, see :func:`~music21.graph.plotStream`.

            Available plots include the following Plot classes:

            :class:`~music21.graph.PlotHistogramPitchSpace`
            :class:`~music21.graph.PlotHistogramPitchClass`
            :class:`~music21.graph.PlotHistogramQuarterLength`

            :class:`~music21.graph.PlotScatterPitchSpaceQuarterLength`
            :class:`~music21.graph.PlotScatterPitchClassQuarterLength`
            :class:`~music21.graph.PlotScatterPitchClassOffset`
            :class:`~music21.graph.PlotScatterPitchSpaceDynamicSymbol`

            :class:`~music21.graph.PlotHorizontalBarPitchSpaceOffset`
            :class:`~music21.graph.PlotHorizontalBarPitchClassOffset`

            :class:`~music21.graph.PlotScatterWeightedPitchSpaceQuarterLength`
            :class:`~music21.graph.PlotScatterWeightedPitchClassQuarterLength`
            :class:`~music21.graph.PlotScatterWeightedPitchSpaceDynamicSymbol`

            :class:`~music21.graph.Plot3DBarsPitchSpaceQuarterLength`

            :class:`~music21.graph.PlotWindowedKrumhanslSchmuckler`
            :class:`~music21.graph.PlotWindowedKrumhanslKessler`
            :class:`~music21.graph.PlotWindowedAardenEssen`
            :class:`~music21.graph.PlotWindowedSimpleWeights`
            :class:`~music21.graph.PlotWindowedBellmanBudge`
            :class:`~music21.graph.PlotWindowedTemperleyKostkaPayne`
            :class:`~music21.graph.PlotWindowedAmbitus`

            :class:`~music21.graph.PlotDolan`



            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv57.8')
            >>> s.plot('pianoroll')




            .. image:: images/PlotHorizontalBarPitchSpaceOffset.*
                    :width: 600





        .. method:: pop(index)

            Return and remove the object found at the user-specified index value. Index values are those found in `elements` and are not necessary offset order.



            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(10))
            >>> junk = a.pop(0)
            >>> len(a)
            9



        .. method:: quantize(quarterLengthDivisors=[4, 3], processOffsets=True, processDurations=False)


            Quantize time values in this Stream by snapping offsets
            and/or durations to the nearest multiple of a quarter length value
            given as one or more divisors of 1 quarter length. The quantized
            value found closest to a divisor multiple will be used.


            The `quarterLengthDivisors` provides a flexible way to provide quantization
            settings. For example, [2] will snap all events to eighth note grid.
            [4, 3] will snap events to sixteenth notes and eighth note triplets,
            whichever is closer. [4, 6] will snap events to sixteenth notes and
            sixteenth note triplets.




            >>> from music21 import *
            >>> n = note.Note()
            >>> n.quarterLength = .49
            >>> s = stream.Stream()
            >>> s.repeatInsert(n, [0.1, .49, .9, 1.51])
            >>> s.quantize([4], processOffsets=True, processDurations=True)
            >>> [e.offset for e in s]
            [0.0, 0.5, 1.0, 1.5]
            >>> [e.duration.quarterLength for e in s]
            [0.5, 0.5, 0.5, 0.5]



        .. method:: realizeOrnaments()


            Realize all ornaments on a stream


            Creates a new stream that contains all realized ornaments in addition
            to other elements in the original stream.




            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> m1 = stream.Measure()
            >>> m1.timeSignature = meter.TimeSignature("4/4")
            >>> n1 = note.WholeNote("C4")
            >>> n1.expressions.append(expressions.Mordent())
            >>> m1.append(n1)
            >>> m2 = stream.Measure()
            >>> n2 = note.WholeNote("D4")
            >>> m2.append(n2)
            >>> s1.append(m1)
            >>> s1.append(m2)
            >>> s1.recurse()
            [<music21.stream.Stream ...>, <music21.stream.Measure 0 offset=0.0>, <music21.meter.TimeSignature 4/4>, <music21.note.Note C>, <music21.stream.Measure 0 offset=4.0>, <music21.note.Note D>]
            >>> s2 = s1.realizeOrnaments()
            >>> s2.recurse()
            [<music21.stream.Stream ...>, <music21.stream.Measure 0 offset=0.0>, <music21.meter.TimeSignature 4/4>, <music21.note.Note C>, <music21.note.Note B>, <music21.note.Note C>, <music21.stream.Measure 0 offset=4.0>, <music21.note.Note D>]




        .. method:: recurse(direction='downward', streamsOnly=False, restoreActiveSites=True, skipDuplicates=True, classFilter=[])

            Return a list of all Music21Objects, starting with self, continuing with self's elements, and whenever finding a Stream subclass in self, that Stream subclasse's elements.



        .. method:: remove(target, firstMatchOnly=True)


            Remove an object from this Stream. Additionally, this Stream is
            removed from the object's sites in :class:`~music21.base.DefinedContexts`.


            By default, only the first match is removed. This can be adjusted with the `firstMatchOnly` parameters.




            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> # copies of an object are not the same as the object
            >>> n3 = copy.deepcopy(n2)
            >>> s.insert(10, n1)
            >>> s.insert(5, n2)
            >>> s.remove(n1)
            >>> len(s)
            1
            >>> s.insert(20, n3)
            >>> s.remove(n3)
            >>> [e for e in s] == [n2]
            True


            No error is raised if the target is not found.




            >>> s.remove(n3)




        .. method:: removeByClass(classFilterList)

            Remove all elements from the Stream based on one or more classes given in a list.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.append(meter.TimeSignature('4/4'))
            >>> s.repeatAppend(note.Note("C"), 8)
            >>> len(s)
            9
            >>> s.removeByClass('GeneralNote')
            >>> len(s)
            1
            >>> len(s.notes)
            0



        .. method:: removeByNotOfClass(classFilterList)

            Remove all elements not of the specified class or subclass in the Steam in place.



        .. method:: repeatAppend(item, numberOfTimes)


            Given an object and a number, run append that many times on
            a deepcopy of the object.
            numberOfTimes should of course be a positive integer.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.duration.quarterLength
            40.0
            >>> a[9].offset
            36.0



        .. method:: repeatInsert(item, offsets)


            Given an object, create a deep copy of each object at
            each positions specified by
            the offset list:



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note('G-')
            >>> n.quarterLength = 1



            >>> a.repeatInsert(n, [0, 2, 3, 4, 4.5, 5, 6, 7, 8, 9, 10, 11, 12])
            >>> len(a)
            13
            >>> a[10].offset
            10.0



        .. method:: replace(target, replacement, firstMatchOnly=False, allTargetSites=True)

            Given a `target` object, replace all references of that object with
            references to the supplied `replacement` object.

            If `allTargetSites` is True (as it is by default), all sites that
            have a reference for the replacement will be similarly changed.
            This is useful for altering both a flat and nested representation.



        .. method:: restoreActiveSites()

            Restore all active sites for all elements from this Stream downward.



        .. method:: setDerivation(target)

            Manually set the Stream that this Stream was derived from. This operation is generally completed automatically.



        .. method:: setupPickleScaffold()

            Prepare this stream and all of its contents for pickling, that
            is, serializing and storing an object representation on disk.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.setupPickleScaffold()



        .. method:: shiftElements(offset, classFilterList=None)


            Add the given offset value to every offset of
            the objects found in the Stream. Objects that are
            specifically placed at the end of the Stream via
            .storeAtEnd() (such as right barlines) are
            not affected.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(0,10))
            >>> a.shiftElements(30)
            >>> a.lowestOffset
            30.0
            >>> a.shiftElements(-10)
            >>> a.lowestOffset
            20.0



        .. method:: simultaneousAttacks(stream2)


            returns an ordered list of offsets where elements are started (attacked)
            at the same time in both self and stream2.


            In this example, we create one stream of Qtr, Half, Qtr, and one of Half, Qtr, Qtr.
            There are simultaneous attacks at offset 0.0 (the beginning) and at offset 3.0,
            but not at 1.0 or 2.0:




            >>> from music21 import *
            ⁠ 
            >>> st1 = stream.Stream()
            >>> st2 = stream.Stream()
            >>> st1.append([note.QuarterNote(), note.HalfNote(), note.QuarterNote()])
            >>> st2.append([note.HalfNote(), note.QuarterNote(), note.QuarterNote()])
            >>> print st1.simultaneousAttacks(st2)
            [0.0, 3.0]



        .. method:: sliceAtOffsets(offsetList, target=None, addTies=True, inPlace=False, displayTiedAccidentals=False)

            Given a list of quarter lengths, slice and optionally tie all Durations at these points.



            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 4
            >>> s.append(n)
            >>> post = s.sliceAtOffsets([1, 2, 3], inPlace=True)
            >>> [(e.offset, e.quarterLength) for e in s]
            [(0.0, 1.0), (1.0, 1.0), (2.0, 1.0), (3.0, 1.0)]



        .. method:: sliceByBeat(target=None, addTies=True, inPlace=False, displayTiedAccidentals=False)

            Slice all elements in the Stream that have a Duration at the offsets determined to be the beat from the local TimeSignature.



        .. method:: sliceByGreatestDivisor(addTies=True, inPlace=False)

            Slice all :class:`~music21.duration.Duration` objects on all Notes of this Stream. Duration are sliced according to the approximate GCD found in all durations.



        .. method:: sliceByQuarterLengths(quarterLengthList, target=None, addTies=True, inPlace=False)


            Slice all :class:`~music21.duration.Duration` objects on all Notes of this Stream.
            Duration are sliced according to values provided in `quarterLengthList` list.
            If the sum of these values is less than the Duration, the values are accumulated
            in a loop to try to fill the Duration. If a match cannot be found, an
            Exception is raised.

            If `target` == None, the entire Stream is processed. Otherwise, only the element
            specified is manipulated.



        .. method:: sort(force=False)


            Sort this Stream in place by offset, then priority, then
            standard class sort order (e.g., Clefs before KeySignatures before
            TimeSignatures).

            Note that Streams automatically sort themsevlves unless
            autoSort is set to False (as in the example below)

            If `force` is True, a sort will be attempted regardless of any other parameters.



            >>> from music21 import *
            >>> n1 = note.Note('a')
            >>> n2 = note.Note('b')
            >>> s = stream.Stream()
            >>> s.autoSort = False
            >>> s.insert(100, n2)
            >>> s.insert(0, n1) # now a has a lower offset by higher index
            >>> [n.name for n in s]
            ['B', 'A']
            >>> s.sort()
            >>> [n.name for n in s]
            ['A', 'B']



        .. method:: splitAtQuarterLength(quarterLength, retainOrigin=True, addTies=True, displayTiedAccidentals=False, searchContext=True, delta=1e-06)

            This method overrides the method on Music21Object to provide similar functionality for Streams. Most arguments are passed to Music21Object.splitAtQuarterLength.



        .. method:: splitByClass(classObj, fx)


            Given a stream, get all objects of type classObj and divide them into
            two new streams depending on the results of fx.
            Fx should be a lambda or other function on elements.
            All elements where fx returns True go in the first stream.
            All other elements are put in the second stream.


            If classObj is None then all elements are returned.  ClassObj
            can also be a list of classes.


            In this example, we will create 50 notes from midi note 30 (two
            octaves and a tritone below middle C) to midi note 80 (an octave
            and a minor sixth above middle C) and add them to a Stream.
            We then create a lambda function to split between those notes
            below middle C (midi note 60) and those above
            (google "lambda functions in Python" for more information on
            what these powerful tools are).




            >>> from music21 import *
            ⁠ 
            >>> stream1 = stream.Stream()
            >>> for x in range(30,81):
            ...     n = note.Note()
            ...     n.midi = x
            ...     stream1.append(n)
            >>> fx = lambda n: n.midi < 60
            >>> b, c = stream1.splitByClass(note.Note, fx)


            Stream b now contains all the notes below middle C,
            that is, 30 notes, beginning with F#1 and ending with B3
            while Stream c has the 21 notes from C4 to A-5:




            >>> len(b)
            30
            >>> (b[0].nameWithOctave, b[-1].nameWithOctave)
            ('F#1', 'B3')
            >>> len(c)
            21
            >>> (c[0].nameWithOctave, c[-1].nameWithOctave)
            ('C4', 'G#5')



        .. method:: storeAtEnd(itemOrList, ignoreSort=False)


            Inserts an item or items at the end of the Stream,
            stored in the special box (called _endElements).

            This method is useful for putting things such as
            right bar lines or courtesy clefs that should always
            be at the end of a Stream no matter what else is appended
            to it

            As sorting is done only by priority and class,
            it cannot avoid setting isSorted to False.




        .. method:: stripTies(inPlace=False, matchByPitch=False, retainContainers=False)


            Find all notes that are tied; remove all tied notes,
            then make the first of the tied notes have a duration
            equal to that of all tied constituents. Lastly,
            remove the formerly-tied notes.


            This method can be used on Stream and Stream subclasses.
            When used on a Score, Parts and Measures are retained.


            If `retainContainers` is False (by default), this method only
            returns Note objects; Measures and other structures are stripped
            from the Stream. Set `retainContainers` to True to remove ties
            from a :class:`~music21.part.Part` Stream that contains
            :class:`~music21.stream.Measure` Streams, and get back a
            multi-Measure structure.


            Presently, this only works if tied notes are sequentual; ultimately
            this will need to look at .to and .from attributes (if they exist)


            In some cases (under makeMeasures()) a continuation note will not have a
            Tie object with a stop attribute set. In that case, we need to look
            for sequential notes with matching pitches. The `matchByPitch` option can
            be used to use this technique.




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 6
            >>> a.append(n)
            >>> m = a.makeMeasures()
            >>> m.makeTies()
            >>> len(m.flat.notes)
            2
            >>> m = m.stripTies()
            >>> len(m.flat.notes)
            1
            >>>



        .. method:: teardownPickleScaffold()

            After rebuilding this stream from pickled storage, prepare this as a normal Stream.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.setupPickleScaffold()
            >>> a.teardownPickleScaffold()



        .. method:: toSoundingPitch(inPlace=True)

            If not at sounding pitch, transpose all Pitch elements to sounding pitch. The atSoundingPitch property is used to determine if transposition is necessary.



        .. method:: toWrittenPitch(inPlace=True)

            If not at written pitch, transpose all Pitch elements to written pitch. The atSoundingPitch property is used to determine if transposition is necessary.



        .. method:: transferOffsetToElements()

            Transfer the offset of this stream to all internal elements; then set
            the offset of this stream to zero.



            >>> from music21 import *
            ⁠ 
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(0,10))
            >>> a.offset = 30
            >>> a.transferOffsetToElements()
            >>> a.lowestOffset
            30.0
            >>> a.offset
            0.0
            >>> a.offset = 20
            >>> a.transferOffsetToElements()
            >>> a.lowestOffset
            50.0



        .. method:: trimPlayingWhileSounding(el, elStream=None, requireClass=False, padStream=False)


            Returns a Stream of deepcopies of elements in otherStream that sound at the same time as`el. but
            with any element that was sounding when el. begins trimmed to begin with el. and any element
            sounding when el ends trimmed to end with el.

            if padStream is set to true then empty space at the beginning and end is filled with a generic
            Music21Object, so that no matter what otherStream is the same length as el.

            Otherwise is the same as allPlayingWhileSounding -- but because these elements are deepcopies,
            the difference might bite you if you're not careful.

            Note that you can make el an empty stream of offset X and duration Y to extract exactly
            that much information from otherStream.




        .. method:: voicesToParts()

            If this Stream defines one or more voices, extract each into a Part, returning a Score.

            If this Stream has no voice, return the Stream as a Part within a Score.



        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.removeNonContainedLocations`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Measure
-------

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Measure(*args, **keywords)

    A representation of a Measure organized as a Stream.

    All properties of a Measure that are Music21 objects are found as part of
    the Stream's elements.



    **Measure** **attributes**

        .. attribute:: number

            A number representing the displayed or shown Measure number as presented in a written Score.


        .. attribute:: timeSignatureIsNew

            Boolean describing if the TimeSignature is different than the previous Measure.


        .. attribute:: layoutWidth

            A suggestion for layout width, though most rendering systems do not support this designation. Use :class:`~music21.layout.SystemLayout` objects instead.


        .. attribute:: clefIsNew

            Boolean describing if the Clef is different than the previous Measure.


        .. attribute:: keyIsNew

            Boolean describing if KeySignature is different than the previous Measure.


        .. attribute:: numberSuffix

            If a Measure number has a string annotation, such as "a" or similar, this string is stored here.


        Attributes without Documentation: `isMeasure`, `filled`, `paddingRight`, `paddingLeft`

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isStream`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.groups`

    **Measure** **properties**

        .. attribute:: barDuration

            Return the bar duration, or the Duration specified by the TimeSignature, regardless of what elements are found in this Measure or the highest time. TimeSignature is found first within the Measure, or within a context based search.



        .. attribute:: clef




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Measure()
            >>> a.clef = clef.TrebleClef()
            >>> a.clef.sign  # clef is an element
            'G'



        .. attribute:: keySignature




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Measure()
            >>> a.keySignature = key.KeySignature(0)
            >>> a.keySignature.sharps
            0



        .. attribute:: leftBarline


            Get or set the left barline, or the Barline object
            found at offset zero of the Measure.  Can be set either with a string
            representing barline style or a bar.Barline() object or None.
            Note that not all bars have
            barline objects here -- regular barlines don't need them.



        .. attribute:: musicxml

            Provide a complete MusicXML representation of the measure.



        .. attribute:: mx


            Return a music21.musicxml.Measure object,
            populated with notes, chords, rests
            and a music21.musixcml.Attributes object,
            populated with time, meter, key, etc

            Not needed for most users.  Call myMeasure.show('musicxml') or
            myMeasure.write('musicxml') instead.



            >>> from music21 import *
            ⁠ 
            >>> a = note.Note()
            >>> a.quarterLength = 4
            >>> b = stream.Measure()
            >>> b.insert(0, a)
            >>> len(b)
            1
            >>> mxMeasure = b.mx
            >>> len(mxMeasure)
            1



        .. attribute:: rightBarline

            Get or set the right barline, or the Barline object found at the offset equal to the bar duration.



            >>> from music21 import *
            >>> b = bar.Barline('final')
            >>> m = stream.Measure()
            >>> print m.rightBarline
            None
            >>> m.rightBarline = b
            >>> m.rightBarline.style
            'final'




        .. attribute:: timeSignature




            >>> from music21 import *
            ⁠ 
            >>> a = stream.Measure()
            >>> a.timeSignature = meter.TimeSignature('2/4')
            >>> a.timeSignature.numerator, a.timeSignature.denominator
            (2, 4)



        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.atSoundingPitch`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.finalBarline`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.notesAndRests`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.seconds`, :attr:`~music21.stream.Stream.secondsMap`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spannerBundle`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Measure** **methods**

        .. method:: addRepeat()

            No documentation.


        .. method:: addTimeDependentDirection(time, direction)

            No documentation.


        .. method:: barDurationProportion(barDuration=None)

            Return a floating point value greater than 0 showing the proportion of the bar duration that is filled based on the highest time of all elements. 0.0 is empty, 1.0 is filled; 1.5 specifies of an overflow of half.

            Bar duration refers to the duration of the Measure as suggested by the TimeSignature. This value cannot be determined without a Time Signature.

            An already-obtained Duration object can be supplied with the `barDuration` optional argument.



            >>> from music21 import *
            >>> m = stream.Measure()
            >>> m.timeSignature = meter.TimeSignature('3/4')
            >>> n = note.Note()
            >>> n.quarterLength = 1
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            0.33333...
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            0.66666...
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            1.0
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            1.33333...



        .. method:: bestTimeSignature()

            Given a Measure with elements in it, get a TimeSignature that contains all elements.

            Note: this does not yet accommodate triplets.



        .. method:: makeNotation(inPlace=False)

            This method calls a sequence of Stream methods on this Measure to prepare notation.

            If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy.



            >>> from music21 import *
            >>> m = stream.Measure()
            >>> n1 = note.Note('g#')
            >>> n2 = note.Note('g')
            >>> m.append([n1, n2])
            >>> m.makeNotation(inPlace=True)
            >>> m.notes[1].pitch.accidental
            <accidental natural>



        .. method:: measureNumberWithSuffix()

            No documentation.


        .. method:: mergeAttributes(other)


            Given another Measure, configure all non-element attributes of this
            Measure with the attributes of the other Measure. No elements
            will be changed or copied.

            This method is necessary because Measures, unlike some Streams,
            have attributes independent of any stored elements.



        .. method:: padAsAnacrusis()

            Given an incompletely filled Measure, adjust the paddingLeft value to to represent contained events as shifted to fill the right-most duration of the bar.

            Calling this method will overwrite any previously set paddingLeft value, based on the current TimeSignature-derived `barDuration` attribute.



            >>> from music21 import *
            >>> m = stream.Measure()
            >>> m.timeSignature = meter.TimeSignature('3/4')
            >>> n = note.Note()
            >>> n.quarterLength = 1
            >>> m.append(copy.deepcopy(n))
            >>> m.padAsAnacrusis()
            >>> m.paddingLeft
            2.0
            >>> m.timeSignature = meter.TimeSignature('5/4')
            >>> m.padAsAnacrusis()
            >>> m.paddingLeft
            4.0



        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attachMelodicIntervals`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.chordify`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extendDurationAndGetBoundaries`, :meth:`~music21.stream.Stream.extendTies`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.flattenUnnecessaryVoices`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getInstruments`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasElementByObjectId`, :meth:`~music21.stream.Stream.hasElementOfClass`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.haveAccidentalsBeenMade`, :meth:`~music21.stream.Stream.haveBeamsBeenMade`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.insertIntoNoteOrChord`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.isTwelveTone`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeImmutable`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeMutable`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.makeVoices`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measureTemplate`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.metronomeMarkBoundaries`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.realizeOrnaments`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.removeByClass`, :meth:`~music21.stream.Stream.removeByNotOfClass`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.restoreActiveSites`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitAtQuarterLength`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.toSoundingPitch`, :meth:`~music21.stream.Stream.toWrittenPitch`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.removeNonContainedLocations`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Opus
----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Opus(*args, **keywords)

    A Stream subclass for handling multi-work music encodings. Many ABC files, for example, define multiple works or parts within a single file.



    **Opus** **attributes**

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isStream`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.groups`

    **Opus** **properties**

        .. attribute:: scores

            Return all :class:`~music21.stream.Score` objects in a :class:`~music21.stream.Opus`.



            >>> from music21 import *



        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.atSoundingPitch`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.finalBarline`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.notesAndRests`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.seconds`, :attr:`~music21.stream.Stream.secondsMap`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spannerBundle`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Opus** **methods**

        .. method:: getNumbers()

            Return a list of all numbers defined in this Opus.



            >>> from music21 import *
            >>> o = corpus.parse('josquin/ovenusbant')
            >>> o.getNumbers()
            ['1', '2', '3']



        .. method:: getScoreByNumber(opusMatch)

            Get Score objects from this Stream by number.
            Performs title search using the
            :meth:`~music21.metadata.Metadata.search` method,
            and returns the first result.



            >>> from music21 import *
            >>> o = corpus.parse('josquin/ovenusbant')
            >>> o.getNumbers()
            ['1', '2', '3']
            >>> s = o.getScoreByNumber(2)
            >>> s.metadata.title
            'O Venus bant'
            >>> s.metadata.alternativeTitle
            'Tenor'



        .. method:: getScoreByTitle(titleMatch)

            Get Score objects from this Stream by a title. Performs title search using the :meth:`~music21.metadata.Metadata.search` method, and returns the first result.



            >>> from music21 import *
            >>> o = corpus.parse('essenFolksong/erk5')
            >>> s = o.getScoreByTitle('Vrienden, kommt alle gaere')
            >>> s = o.getScoreByTitle('(.*)kommt(.*)') # regular expression
            >>> s.metadata.title
            'Vrienden, kommt alle gaere'



        .. method:: mergeScores()

            Some Opus object represent numerous scores that are individual parts of the same work. This method will treat each contained Score as a Part, merging and returning a single Score with merged Metadata.



            >>> from music21 import *
            >>> o = corpus.parse('josquin/milleRegrets')
            >>> s = o.mergeScores()
            >>> s.metadata.title
            'Mille regrets'
            >>> len(s.parts)
            4



        .. method:: show(fmt=None, app=None)


            Displays an object in a format provided by the fmt argument or, if not provided, the format set in the user's Environment.

            This method overrides the behavior specified in :class:`~music21.base.Music21Object`.



        .. method:: write(fmt=None, fp=None)


            Displays an object in a format provided by the fmt argument or, if not provided, the format set in the user's Environment.

            This method overrides the behavior specified in :class:`~music21.base.Music21Object`.



        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attachMelodicIntervals`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.chordify`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extendDurationAndGetBoundaries`, :meth:`~music21.stream.Stream.extendTies`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.flattenUnnecessaryVoices`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getInstruments`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasElementByObjectId`, :meth:`~music21.stream.Stream.hasElementOfClass`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.haveAccidentalsBeenMade`, :meth:`~music21.stream.Stream.haveBeamsBeenMade`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.insertIntoNoteOrChord`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.isTwelveTone`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeImmutable`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeMutable`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.makeVoices`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measureTemplate`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.metronomeMarkBoundaries`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.realizeOrnaments`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.removeByClass`, :meth:`~music21.stream.Stream.removeByNotOfClass`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.restoreActiveSites`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitAtQuarterLength`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.toSoundingPitch`, :meth:`~music21.stream.Stream.toWrittenPitch`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.removeNonContainedLocations`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Part
----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Part(*args, **keywords)

    A Stream subclass for designating music that is
    considered a single part.

    May be enclosed in a staff (for instance, 2nd and 3rd trombone
    on a single staff), may enclose staves (piano treble and piano bass),
    or may not enclose or be enclosed by a staff (in which case, it
    assumes that this part fits on one staff and shares it with no other
    part




PartStaff
---------

Inherits from: :class:`~music21.stream.Part`, :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: PartStaff(*args, **keywords)

    A Part subclass for designating music that is represented on a single staff but may only be one of many staffs for a single part.





Score
-----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Score(*args, **keywords)

    A Stream subclass for handling multi-part music.

    Absolutely optional (the largest containing Stream in a piece could be
    a generic Stream, or a Part, or a Staff).  And Scores can be
    embedded in other Scores (in fact, our original thought was to call
    this class a Fragment because of this possibility of continuous
    embedding), but we figure that many people will like calling the largest
    container a Score and that this will become a standard.



    **Score** **attributes**

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isStream`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.groups`

    **Score** **properties**

        .. attribute:: lily


            returns the lily code for a score.



        .. attribute:: parts

            Return all :class:`~music21.stream.Part` objects in a :class:`~music21.stream.Score`.



            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv66.6')
            >>> parts = s.parts
            >>> len(parts)
            4



        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.atSoundingPitch`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.finalBarline`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.notesAndRests`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.seconds`, :attr:`~music21.stream.Stream.secondsMap`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spannerBundle`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Score** **methods**

        .. method:: expandRepeats()

            Expand all repeats, as well as all repeat indications given by text expressions such as D.C. al Segno.

            This method always returns a new Stream, with deepcopies of all contained elements at all level.

            NOTE: This implementation is still incomplete.



        .. method:: flattenParts(classFilterList=['Note', 'Chord'])

            Join all Parts into a single Part with all elements found in each Measure.



        .. method:: implode()

            Reduce a polyphonic work into one or more staves.



        .. method:: measure(measureNumber, collect=[<class 'music21.clef.Clef'>, <class 'music21.meter.TimeSignature'>, <class 'music21.instrument.Instrument'>, <class 'music21.key.KeySignature'>], gatherSpanners=True)


            Given a measure number,
            return a single :class:`~music21.stream.Measure` object if the Measure number exists, otherwise return None.


            This method overrides the :meth:`~music21.stream.Stream.measures` method on Stream.
            This creates a new Score stream that has the
            same measure range for all Parts.




            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> # contains 1 measure
            >>> len(a.measure(3).parts[0].getElementsByClass('Measure'))
            1



        .. method:: measureOffsetMap(classFilterList=None)


            This method overrides the
            :meth:`~music21.stream.Stream.measureOffsetMap` method of Stream.
            This creates a map based on all contained Parts in this Score.
            Measures found in multiple Parts with the same offset will be
            appended to the same list.


            If no parts are found in the score, then the normal
            :meth:`~music21.stream.Stream.measureOffsetMap` routine is called.


            This method is smart and does not assume that all Parts
            have measures with identical offsets.



        .. method:: measures(numberStart, numberEnd, collect=['Clef', 'TimeSignature', 'Instrument', 'KeySignature'], gatherSpanners=True, searchContext=False)

            This method override the :meth:`~music21.stream.Stream.measures` method on Stream. This creates a new Score stream that has the same measure range for all Parts.



        .. method:: partsToVoices(voiceAllocation=2, permitOneVoicePerPart=False)

            Given a multi-part :class:`~music21.stream.Score`, return a new Score that combines parts into voices.

            The `voiceAllocation` parameter can be an integer: if so, this many parts will each be grouped into one part as voices

            The `permitOneVoicePerPart` parameter, if True, will encode a single voice inside a single Part, rather than leaving a single part alone.



        .. method:: sliceByGreatestDivisor(inPlace=True, addTies=True)


            Slice all duration of all part by the minimum duration
            that can be summed to each concurrent duration.

            Overrides method defined on Stream.



        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attachMelodicIntervals`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.chordify`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extendDurationAndGetBoundaries`, :meth:`~music21.stream.Stream.extendTies`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.flattenUnnecessaryVoices`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getInstruments`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasElementByObjectId`, :meth:`~music21.stream.Stream.hasElementOfClass`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.haveAccidentalsBeenMade`, :meth:`~music21.stream.Stream.haveBeamsBeenMade`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.insertIntoNoteOrChord`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.isTwelveTone`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeImmutable`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeMutable`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.makeVoices`, :meth:`~music21.stream.Stream.measureTemplate`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.metronomeMarkBoundaries`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.realizeOrnaments`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.removeByClass`, :meth:`~music21.stream.Stream.removeByNotOfClass`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.restoreActiveSites`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitAtQuarterLength`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.toSoundingPitch`, :meth:`~music21.stream.Stream.toWrittenPitch`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.removeNonContainedLocations`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


SpannerStorage
--------------

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: SpannerStorage(*arguments, **keywords)


    For advanced use. This Stream subclass is used inside of a Spanner object to provide object storage.

    This subclass name can be used to search in an object's DefinedContexts and find any and all locations that are SpannerStorage objects.

    A `spannerParent` keyword argument must be provided by the Spanner in creation.



    **SpannerStorage** **attributes**

        Attributes without Documentation: `spannerParent`

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isStream`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.isSpanner`, :attr:`~music21.base.Music21Object.groups`

    **SpannerStorage** **properties**

        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.atSoundingPitch`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.finalBarline`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.notesAndRests`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.seconds`, :attr:`~music21.stream.Stream.secondsMap`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spannerBundle`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **SpannerStorage** **methods**

        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attachMelodicIntervals`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.chordify`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extendDurationAndGetBoundaries`, :meth:`~music21.stream.Stream.extendTies`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.flattenUnnecessaryVoices`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getInstruments`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasElementByObjectId`, :meth:`~music21.stream.Stream.hasElementOfClass`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.haveAccidentalsBeenMade`, :meth:`~music21.stream.Stream.haveBeamsBeenMade`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.insertIntoNoteOrChord`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.isTwelveTone`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeImmutable`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeMutable`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.makeVoices`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measureTemplate`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.metronomeMarkBoundaries`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.realizeOrnaments`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.removeByClass`, :meth:`~music21.stream.Stream.removeByNotOfClass`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.restoreActiveSites`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitAtQuarterLength`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.toSoundingPitch`, :meth:`~music21.stream.Stream.toWrittenPitch`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.hasSpannerSite`, :meth:`~music21.base.Music21Object.isClassOrSubclass`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.next`, :meth:`~music21.base.Music21Object.previous`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.removeNonContainedLocations`, :meth:`~music21.base.Music21Object.searchActiveSiteByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


StreamIterator
--------------



.. class:: StreamIterator(srcStream)

    A simple Iterator object used to handle iteration of Streams and other
    list-like objects.



    **StreamIterator** **methods**

        .. method:: next()

            No documentation.



Voice
-----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Voice(givenElements=None, *args, **keywords)


    A Stream subclass for declaring that all the music in the
    stream belongs to a certain "voice" for analysis or display
    purposes.

    Note that both Finale's Layers and Voices as concepts are
    considered Voices here.




